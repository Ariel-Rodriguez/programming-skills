{
  "benchmarks": [
    {
      "benchmark_id": "ollama-rnj-1-8b-20260213-231753",
      "timestamp": "2026-02-13T23:17:53",
      "provider": "ollama",
      "model": "rnj-1:8b",
      "skills": [
        {
          "skill_name": "ps-all-principles-compressed",
          "skill_version": "1.0.0",
          "provider": "ollama",
          "model": "rnj-1:8b",
          "timestamp": "2026-02-13T23:17:53",
          "baseline_rating": "regular",
          "skill_rating": "good",
          "improvement": "yes",
          "reasoning": "Baseline rated: regular | With Skill rated: good\n\nSolution B demonstrates better adherence to the principles with explicit state validation, better error handling, and clearer separation of concerns. It follows the guidelines more completely, particularly in areas like explicit state invariants, illegal states unrepresentable, functional core, imperative shell, explicit boundaries, single-direction data flow, local reasoning, explicit error handling, deterministic resource lifecycle, policy/mechanism separation, and composition over coordination.",
          "before_code": "// Test: mini_app_full_stack_architecture_challenge\nBelow is a simplified version of a backend system in Python using Flask for the Task Tracker. This is a high-level implementation and does not include all the features and error handling as would be required for production use. It includes the core functionality as described in the requirements.\n\n```python\nfrom flask import Flask, request, jsonify\nfrom datetime import datetime, timedelta\nfrom collections import defaultdict\n\napp = Flask(__name__)\n\ntasks = {}\ntask_id_counter = 1\n\n# Status lifecycle\nstatus_lifecycle = {\n    \"draft\": [\"active\"],\n    \"active\": [\"blocked\", \"done\"],\n    \"blocked\": [\"active\", \"done\"],\n    \"done\": [\"archived\"],\n    \"archived\": []\n}\n\n# Priority overdue times\npriority_overdue_times = {\n    \"high\": timedelta(hours=24),\n    \"medium\": timedelta(hours=72),\n    \"low\": timedelta(hours=72)\n}\n\ndef is_overdue(task):\n    if not task['due_date']:\n        return False\n    due_date = datetime.fromisoformat(task['due_date'])\n    overdue_time = priority_overdue_times[task['priority']]\n    return datetime.now() - due_date > overdue_time\n\n@app.route('/tasks', methods=['POST'])\ndef create_task():\n    global task_id_counter\n    data = request.json\n    task = {\n        'id': task_id_counter,\n        'title': data['title'],\n        'description': data['description'],\n        'priority': data['priority'],\n        'assignee': data['assignee'],\n        'created': datetime.now().isoformat(),\n        'due_date': data.get('due_date'),\n        'status': 'draft',\n        'checklist': []\n    }\n    tasks[task_id_counter] = task\n    task_id_counter += 1\n    return jsonify(task), 201\n\n@app.route('/tasks/<int:task_id>/activate', methods=['POST'])\ndef activate_task(task_id):\n    task = tasks.get(task_id)\n    if not task or task['status'] != 'draft':\n        return jsonify({'error': 'Invalid task'}), 400\n    task['status'] = 'active'\n    return jsonify(task), 200\n\n@app.route('/tasks/<int:task_id>/block', methods=['POST'])\ndef block_task(task_id):\n    task = tasks.get(task_id)\n    if not task or task['status'] != 'active':\n        return jsonify({'error': 'Invalid task'}), 400\n    task['status'] = 'blocked'\n    return jsonify(task), 200\n\n@app.route('/tasks/<int:task_id>/complete', methods=['POST'])\ndef complete_task(task_id):\n    task = tasks.get(task_id)\n    if not task or task['status'] != 'active' or not task['checklist']:\n        return jsonify({'error': 'Invalid task'}), 400\n    task['status'] = 'done'\n    return jsonify(task), 200\n\n@app.route('/tasks/<int:task_id>/archive', methods=['POST'])\ndef archive_task(task_id):\n    task = tasks.get(task_id)\n    if not task or task['status'] != 'done':\n        return jsonify({'error': 'Invalid task'}), 400\n    task['status'] = 'archived'\n    return jsonify(task), 200\n\n@app.route('/tasks', methods=['GET'])\ndef list_tasks():\n    status = request.args.get('status')\n    assignee = request.args.get('assignee')\n    priority = request.args.get('priority')\n    overdue = request.args.get('overdue') == 'true'\n    filtered_tasks = [\n        task for task in tasks.values()\n        if (not status or task['status'] == status) and\n           (not assignee or task['assignee'] == assignee) and\n           (not priority or task['priority'] == priority) and\n           (not overdue or is_overdue(task))\n    ]\n    return jsonify(filtered_tasks), 200\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\nThis code provides a basic implementation of the Task Tracker backend. It includes the core functionality as described in the requirements. However, it does not include all the features and error handling as would be required for production use. It is intended as a starting point for further development.\n\n// Test: legacy_refactor_all_principles\n# Refactor Plan for Legacy Task Service\n\n## High-Level Goals\n1. Introduce clear state transitions with explicit steps\n2. Implement explicit error handling and recovery\n3. Standardize naming and resource management\n4. Modularize business rules for easier updates\n\n## Milestones\n1. State transition refactoring (2 weeks)\n2. Error handling standardization (3 weeks)\n3. Naming standardization (1 week)\n4. Resource management (2 weeks)\n\n## Rollback Strategy\n- Maintain original code in parallel during refactoring\n- Add unit tests for critical paths\n- Implement feature flags for gradual rollout\n\n## Success Criteria\n- 90% reduction in ambiguous failures\n- 50% reduction in resource growth\n- 30% faster deployment cycles\n\n## Before/After Examples\n\n### State Transition Logic\nBefore:\n```python\ndef process_task(task):\n    if task.state == \"new\":\n        # complex logic\n        if random():\n            task.state = \"complete\"\n        else:\n            task.state = \"failed\"\n```\n\nAfter:\n```python\nclass TaskProcessor:\n    def __init__(self):\n        self.state_machine = StateMachine()\n    \n    def process(self, task):\n        for step in self.state_machine.steps:\n            if not step.execute(task):\n                return False\n        return True\n```\n\n### Error Handling\nBefore:\n```python\ntry:\n    # complex operation\nexcept Exception as e:\n    # vague error handling\n```\n\nAfter:\n```python\nclass ErrorHandler:\n    def handle(self, error):\n        specific_handler = self._get_specific_handler(error)\n        return specific_handler.handle(error)\n```\n\n### Naming Consistency\nBefore:\n```python\nclass User:\n    pass\n\nclass Customer:\n    pass\n```\n\nAfter:\n```python\nclass User:\n    pass\n\nclass UserAlias(User):\n    pass\n```\n\n## Implementation Plan\n1. Start with state transition refactoring\n2. Implement error handling standardization\n3. Standardize naming\n4. Add resource monitoring\n\n## Team Roles\n- 2 engineers: Core refactoring\n- 2 engineers: Testing and validation\n- 1 engineer: Documentation and training\n- 1 engineer: Monitoring and rollback",
          "after_code": "// Test: mini_app_full_stack_architecture_challenge\nI'll help you implement a Team Task Tracker backend following the principles outlined in the skill guidance. Let's break down the implementation step by step.\n\n## Step 1: Model state and invariants first\n\nFirst, let's define the valid states and transitions for our task tracker:\n\n```python\nfrom enum import Enum, auto\nfrom dataclasses import dataclass\nfrom typing import Optional, List\nfrom datetime import datetime, timedelta\nfrom uuid import UUID\n\nclass TaskStatus(Enum):\n    DRAFT = auto()\n    ACTIVE = auto()\n    BLOCKED = auto()\n    DONE = auto()\n    ARCHIVED = auto()\n\nclass Priority(Enum):\n    LOW = auto()\n    MEDIUM = auto()\n    HIGH = auto()\n\n@dataclass\nclass Task:\n    id: UUID\n    title: str\n    description: str\n    priority: Priority\n    assignee_email: str\n    created_at: datetime\n    due_date: Optional[datetime] = None\n    status: TaskStatus = TaskStatus.DRAFT\n    checklist: List[bool] = None  # Track checklist completion\n\n    def __post_init__(self):\n        if self.checklist is None:\n            self.checklist = []\n\n    def is_overdue(self) -> bool:\n        if self.due_date is None:\n            return False\n        \n        now = datetime.now()\n        if self.priority == Priority.HIGH:\n            return (now - self.due_date) > timedelta(hours=24)\n        else:\n            return (now - self.due_date) > timedelta(hours=72)\n```\n\n## Step 2: Separate core logic from effects\n\nLet's implement the core task operations:\n\n```python\nclass TaskService:\n    def __init__(self):\n        self.tasks: Dict[UUID, Task] = {}\n\n    def create_task(\n        self,\n        title: str,\n        description: str,\n        priority: Priority,\n        assignee_email: str,\n        due_date: Optional[datetime] = None\n    ) -> Task:\n        task = Task(\n            id=uuid4(),\n            title=title,\n            description=description,\n            priority=priority,\n            assignee_email=assignee_email,\n            created_at=datetime.now(),\n            due_date=due_date\n        )\n        self.tasks[task.id] = task\n        return task\n\n    def activate_task(self, task_id: UUID) -> Task:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(\"Task not found\")\n        \n        if task.status != TaskStatus.DRAFT:\n            raise ValueError(\"Can only activate draft tasks\")\n        \n        task.status = TaskStatus.ACTIVE\n        return task\n\n    def block_task(self, task_id: UUID, reason: str) -> Task:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(\"Task not found\")\n        \n        if task.status not in [TaskStatus.ACTIVE, TaskStatus.DONE]:\n            raise ValueError(\"Can only block active or done tasks\")\n        \n        task.status = TaskStatus.BLOCKED\n        return task\n\n    def complete_task(self, task_id: UUID) -> Task:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(\"Task not found\")\n        \n        if task.status != TaskStatus.ACTIVE:\n            raise ValueError(\"Can only complete active tasks\")\n        \n        if not task.checklist or all(task.checklist):\n            task.status = TaskStatus.DONE\n        else:\n            raise ValueError(\"Cannot complete task with incomplete checklist\")\n        \n        return task\n\n    def archive_task(self, task_id: UUID) -> Task:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(\"Task not found\")\n        \n        task.status = TaskStatus.ARCHIVED\n        return task\n\n    def list_tasks(self, status: Optional[TaskStatus] = None) -> List[Task]:\n        return [task for task in self.tasks.values() if status is None or task.status == status]\n\n    def add_checklist_item(self, task_id: UUID) -> Task:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(\"Task not found\")\n        \n        task.checklist.append(False)\n        return task\n\n    def toggle_checklist_item(self, task_id: UUID, item_index: int) -> Task:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(\"Task not found\")\n        \n        if item_index < 0 or item_index >= len(task.checklist):\n            raise ValueError(\"Invalid checklist item index\")\n        \n        task.checklist[item_index] = not task.checklist[item_index]\n        return task\n```\n\n## Step 3: Build explicit boundaries\n\nLet's implement the notification system and error handling:\n\n```python\nclass NotificationService:\n    def send_notification(self, task: Task, notification_type: str) -> None:\n        # In a real implementation, this would send an email or other notification\n        print(f\"Notification: {notification_type} for task {task.id}\")\n\nclass TaskServiceWithNotifications:\n    def __init__(self):\n        self.task_service = TaskService()\n        self.notification_service = NotificationService()\n\n    def create_task(self, *args, **kwargs) -> Task:\n        task = self.task_service.create_task(*args, **kwargs)\n        self.notification_service.send_notification(task, \"Task created\")\n        return task\n\n    def activate_task(self, task_id: UUID) -> Task:\n        task = self.task_service.activate_task(task_id)\n        self.notification_service.send_notification(task, \"Task activated\")\n        return task\n\n    # ... other methods would call notification_service as needed\n```\n\n## Step 4: Enforce one-way data flow and explicit dependencies\n\nLet's implement the overdue calculation and error handling:\n\n```python\nclass TaskServiceWithOverdue:\n    def is_overdue(self, task: Task) -> bool:\n        return task.is_overdue()\n\n    def list_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.task_service.tasks.values() \n                if self.is_overdue(task)]\n```\n\n## Step 5: Make failures explicit\n\nLet's implement error handling:\n\n```python\nfrom typing import Dict, Any\n\nclass TaskError(Exception):\n    def __init__(self, message: str, code: str, details: Optional[Dict[str, Any]] = None):\n        self.message = message\n        self.code = code\n        self.details = details or {}\n        super().__init__(self.message)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"message\": self.message,\n            \"code\": self.code,\n            \"details\": self.details\n        }\n\n# Example usage:\ntry:\n    task = task_service.create_task(...)\nexcept TaskError as e:\n    # Handle error\n```\n\n## Step 6: Control lifetime and mutation\n\nThe current implementation already follows good practices for resource management and mutation control.\n\n## Step 7: Separate policy from mechanism\n\nThe policy (business rules) and mechanism (implementation) are well separated in the code above.\n\n## Step 8: Compose small units\n\nThe code is composed of small, focused units that can be tested independently.\n\n## Final Implementation\n\nHere's a summary of the implementation:\n\n1. We've defined clear state transitions for tasks\n2. We've separated core logic from effects (notifications)\n3. We've enforced one-way data flow\n4. We've made failures explicit with error handling\n5. We've controlled resource lifetime\n6. We've separated policy from mechanism\n7. We've composed small units\n\nThe implementation follows all the principles outlined in the skill guidance.\n\n## Next Steps\n\nTo complete the implementation, you would:\n\n1. Add a web interface or API layer\n2. Add persistence (database) for task storage\n3. Add authentication and authorization\n4. Add more comprehensive testing\n5. Add monitoring and logging\n\nWould you like me to help with any of these next steps?\n\n// Test: legacy_refactor_all_principles\nI'll help you design a refactor plan for your legacy task service. Let's follow the principles from the skill guidance to create a predictable, testable, and structurally hard-to-misuse codebase.\n\n## Refactor Plan\n\n### Milestones\n1. **State Model Refactor** - Define explicit state transitions and invariants\n2. **Core Logic Separation** - Extract pure business logic from effects\n3. **Boundary Definition** - Implement ports/adapters\n4. **Error Handling** - Implement explicit error handling\n5. **Resource Management** - Implement deterministic lifecycle\n6. **Policy Separation** - Separate policy from mechanism\n\n### Rollback Strategy\n- Maintain backward compatibility during transition\n- Keep old implementation alongside new for comparison\n- Add feature flags to toggle new behavior\n\n### Success Criteria\n- 100% test coverage\n- No ambiguous error handling\n- Deterministic resource cleanup\n- Clear state transitions\n- Policy and mechanism separation\n\n## Before/After Examples\n\n### State Transition Logic (Before)\n```python\nclass TaskService:\n    def process(self):\n        # State changes occasionally skip steps\n        if random.random() < 0.3:\n            self.state = \"completed\"\n        else:\n            self.state = \"failed\"\n```\n\n### State Transition Logic (After)\n```python\nclass TaskService:\n    def process(self):\n        # Explicit state transitions\n        if self.can_complete():\n            self.state = \"completed\"\n        else:\n            self.state = \"failed\"\n    \n    def can_complete(self):\n        # Clear state validation\n        return not self.has_errors() and self.dependencies_met()\n```\n\n### Error Handling (Before)\n```python\ntry:\n    # Some operation\nexcept Exception as e:\n    # Generic error handling\n    pass\n```\n\n### Error Handling (After)\n```python\nclass TaskError(Exception):\n    pass\n\ndef process_with_error_handling():\n    try:\n        # Some operation\n    except TaskError as e:\n        # Specific error handling\n        return Result.Err(e)\n    return Result.Ok(value)\n```\n\n### Naming Consistency (Before)\n```python\n# Inconsistent naming\nclass Task:\n    pass\n\nclass task:\n    pass\n```\n\n### Naming Consistency (After)\n```python\n# Consistent naming\nclass Task:\n    pass\n```\n\n## Implementation Plan\n\n### 1. State Model Refactor\n- Define explicit state transitions and invariants\n- Use type system to enforce valid states\n- Implement state validation\n\n### 2. Core Logic Separation\n- Extract pure business logic from effects\n- Implement domain model as pure functions\n- Move IO/external dependencies to adapters\n\n### 3. Boundary Definition\n- Define ports in domain language\n- Implement adapters outside domain\n- Wire dependencies only at composition root\n\n### 4. Error Handling\n- Implement explicit error handling\n- Use Result/Either for expected failures\n- Distinguish domain vs infrastructure errors\n\n### 5. Resource Management\n- Implement deterministic lifecycle\n- Guarantee cleanup on success/failure paths\n- Assign one owner per resource\n\n### 6. Policy Separation\n- Separate policy from mechanism\n- Implement configuration as data\n- Use strategy pattern for algorithms\n\n### 7. Composition\n- Compose small units\n- Avoid Manager/Coordinator god objects\n- Use names that express responsibility\n\n## Success Criteria\n\n1. **State Management**\n- Explicit state transitions\n- Type-safe state validation\n- Clear error handling\n\n2. **Core Logic**\n- Pure business logic\n- No side effects in domain code\n- Clear separation of concerns\n\n3. **Boundaries**\n- Well-defined ports/adapters\n- No hidden dependencies\n- Clear ownership of resources\n\n4. **Error Handling**\n- Explicit error types\n- Clear error paths\n- No generic exceptions\n\n5. **Resource Management**\n- Deterministic cleanup\n- Clear ownership\n- No resource leaks\n\n6. **Policy Separation**\n- Configurable policy\n- Clear mechanism\n- Easy to modify behavior\n\n7. **Composition**\n- Small, focused units\n- No central coordinators\n- Clear responsibilities\n\n## Rollback Strategy\n\n1. **Incremental Changes**\n- Start with state model refactor\n- Gradually introduce pure functions\n- Add error handling incrementally\n\n2. **Testing**\n- Add unit tests for state transitions\n- Add integration tests for error handling\n- Add property-based tests for resource management\n\n3. **Monitoring**\n- Track key metrics during transition\n- Have rollback plan ready\n- Keep old implementation during transition\n\n## Final Architecture\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Service\n    participant Adapter\n    participant Storage\n    \n    User->>+Service: Request\n    Service->>+Adapter: External call\n    Adapter->>+Storage: Persist\n    Storage->>-Adapter: Success\n    Adapter->>-Service: Response\n    Service->>-User: Response\n```\n\nThis refactor plan follows the principles from the skill guidance:\n- Explicit state invariants\n- Illegal states unrepresentable\n- Functional core, imperative shell\n- Explicit boundaries via ports/adapters\n- Single-direction data flow\n- Local reasoning with explicit dependencies\n- Explicit error handling\n- Deterministic resource lifecycle\n- Policy/mechanism separation\n- Composition over coordination\n- Minimized mutation\n- Naming as design\n\nThe plan is incremental, testable, and structurally hard to misuse. It addresses the issues reported in the legacy system and provides a clear path forward.",
          "judgment": {
            "principle_better": "B",
            "quality_better": "B",
            "overall_better": "B",
            "option_a_rating": "regular",
            "option_b_rating": "good",
            "score": 100,
            "reasoning": "Solution B demonstrates better adherence to the principles with explicit state validation, better error handling, and clearer separation of concerns. It follows the guidelines more completely, particularly in areas like explicit state invariants, illegal states unrepresentable, functional core, imperative shell, explicit boundaries, single-direction data flow, local reasoning, explicit error handling, deterministic resource lifecycle, policy/mechanism separation, and composition over coordination."
          },
          "judge_error": false,
          "tests": [
            {
              "name": "mini_app_full_stack_architecture_challenge",
              "input": "Build a Team Task Tracker backend for small engineering teams.\n\nProduct requirements:\n1) Task data\n- Each task has: id, title, description, priority (low/medium/high), assignee email, created timestamp, optional due date, and current status.\n- Allowed status lifecycle: draft -> active -> blocked -> done -> archived.\n- A task can move only to the next logical stage in the lifecycle.\n- A task cannot be marked done unless at least one checklist item is completed.\n\n2) Features\n- Create task\n- Activate task\n- Block task with a required reason\n- Complete task\n- Archive task\n- List tasks with filters (status, assignee, priority, overdue)\n\n3) Notifications\n- Send a notification when a task is activated, blocked, completed, or archived.\n- If notification delivery fails, core task operation result must still be explicit and unambiguous.\n\n4) Overdue behavior\n- High priority tasks are overdue after 24 hours past due date.\n- Medium/low priority tasks are overdue after 72 hours past due date.\n- Overdue calculation must be consistent and testable.\n\n5) Reliability and consistency\n- If two updates happen close together, final task status must remain valid.\n- The system must avoid contradictory task states.\n- Failures must return clear machine-readable error outcomes.\n\n6) Deliverables\n- Implementation code (or detailed pseudocode)\n- API contract for all operations\n- Test cases covering status transitions, overdue rules, and failure scenarios",
              "expected": {
                "focus": "Does the solution apply all major principles together: explicit invariants/state machine, pure core + effectful shell, ports/adapters boundaries, unidirectional ownership flow, structured error types, explicit lifecycle cleanup, policy-mechanism separation, composition over coordinator, controlled mutation, and domain-driven naming?"
              },
              "baseline_response": "Below is a simplified version of a backend system in Python using Flask for the Task Tracker. This is a high-level implementation and does not include all the features and error handling as would be required for production use. It includes the core functionality as described in the requirements.\n\n```python\nfrom flask import Flask, request, jsonify\nfrom datetime import datetime, timedelta\nfrom collections import defaultdict\n\napp = Flask(__name__)\n\ntasks = {}\ntask_id_counter = 1\n\n# Status lifecycle\nstatus_lifecycle = {\n    \"draft\": [\"active\"],\n    \"active\": [\"blocked\", \"done\"],\n    \"blocked\": [\"active\", \"done\"],\n    \"done\": [\"archived\"],\n    \"archived\": []\n}\n\n# Priority overdue times\npriority_overdue_times = {\n    \"high\": timedelta(hours=24),\n    \"medium\": timedelta(hours=72),\n    \"low\": timedelta(hours=72)\n}\n\ndef is_overdue(task):\n    if not task['due_date']:\n        return False\n    due_date = datetime.fromisoformat(task['due_date'])\n    overdue_time = priority_overdue_times[task['priority']]\n    return datetime.now() - due_date > overdue_time\n\n@app.route('/tasks', methods=['POST'])\ndef create_task():\n    global task_id_counter\n    data = request.json\n    task = {\n        'id': task_id_counter,\n        'title': data['title'],\n        'description': data['description'],\n        'priority': data['priority'],\n        'assignee': data['assignee'],\n        'created': datetime.now().isoformat(),\n        'due_date': data.get('due_date'),\n        'status': 'draft',\n        'checklist': []\n    }\n    tasks[task_id_counter] = task\n    task_id_counter += 1\n    return jsonify(task), 201\n\n@app.route('/tasks/<int:task_id>/activate', methods=['POST'])\ndef activate_task(task_id):\n    task = tasks.get(task_id)\n    if not task or task['status'] != 'draft':\n        return jsonify({'error': 'Invalid task'}), 400\n    task['status'] = 'active'\n    return jsonify(task), 200\n\n@app.route('/tasks/<int:task_id>/block', methods=['POST'])\ndef block_task(task_id):\n    task = tasks.get(task_id)\n    if not task or task['status'] != 'active':\n        return jsonify({'error': 'Invalid task'}), 400\n    task['status'] = 'blocked'\n    return jsonify(task), 200\n\n@app.route('/tasks/<int:task_id>/complete', methods=['POST'])\ndef complete_task(task_id):\n    task = tasks.get(task_id)\n    if not task or task['status'] != 'active' or not task['checklist']:\n        return jsonify({'error': 'Invalid task'}), 400\n    task['status'] = 'done'\n    return jsonify(task), 200\n\n@app.route('/tasks/<int:task_id>/archive', methods=['POST'])\ndef archive_task(task_id):\n    task = tasks.get(task_id)\n    if not task or task['status'] != 'done':\n        return jsonify({'error': 'Invalid task'}), 400\n    task['status'] = 'archived'\n    return jsonify(task), 200\n\n@app.route('/tasks', methods=['GET'])\ndef list_tasks():\n    status = request.args.get('status')\n    assignee = request.args.get('assignee')\n    priority = request.args.get('priority')\n    overdue = request.args.get('overdue') == 'true'\n    filtered_tasks = [\n        task for task in tasks.values()\n        if (not status or task['status'] == status) and\n           (not assignee or task['assignee'] == assignee) and\n           (not priority or task['priority'] == priority) and\n           (not overdue or is_overdue(task))\n    ]\n    return jsonify(filtered_tasks), 200\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\nThis code provides a basic implementation of the Task Tracker backend. It includes the core functionality as described in the requirements. However, it does not include all the features and error handling as would be required for production use. It is intended as a starting point for further development.",
              "skill_response": "I'll help you implement a Team Task Tracker backend following the principles outlined in the skill guidance. Let's break down the implementation step by step.\n\n## Step 1: Model state and invariants first\n\nFirst, let's define the valid states and transitions for our task tracker:\n\n```python\nfrom enum import Enum, auto\nfrom dataclasses import dataclass\nfrom typing import Optional, List\nfrom datetime import datetime, timedelta\nfrom uuid import UUID\n\nclass TaskStatus(Enum):\n    DRAFT = auto()\n    ACTIVE = auto()\n    BLOCKED = auto()\n    DONE = auto()\n    ARCHIVED = auto()\n\nclass Priority(Enum):\n    LOW = auto()\n    MEDIUM = auto()\n    HIGH = auto()\n\n@dataclass\nclass Task:\n    id: UUID\n    title: str\n    description: str\n    priority: Priority\n    assignee_email: str\n    created_at: datetime\n    due_date: Optional[datetime] = None\n    status: TaskStatus = TaskStatus.DRAFT\n    checklist: List[bool] = None  # Track checklist completion\n\n    def __post_init__(self):\n        if self.checklist is None:\n            self.checklist = []\n\n    def is_overdue(self) -> bool:\n        if self.due_date is None:\n            return False\n        \n        now = datetime.now()\n        if self.priority == Priority.HIGH:\n            return (now - self.due_date) > timedelta(hours=24)\n        else:\n            return (now - self.due_date) > timedelta(hours=72)\n```\n\n## Step 2: Separate core logic from effects\n\nLet's implement the core task operations:\n\n```python\nclass TaskService:\n    def __init__(self):\n        self.tasks: Dict[UUID, Task] = {}\n\n    def create_task(\n        self,\n        title: str,\n        description: str,\n        priority: Priority,\n        assignee_email: str,\n        due_date: Optional[datetime] = None\n    ) -> Task:\n        task = Task(\n            id=uuid4(),\n            title=title,\n            description=description,\n            priority=priority,\n            assignee_email=assignee_email,\n            created_at=datetime.now(),\n            due_date=due_date\n        )\n        self.tasks[task.id] = task\n        return task\n\n    def activate_task(self, task_id: UUID) -> Task:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(\"Task not found\")\n        \n        if task.status != TaskStatus.DRAFT:\n            raise ValueError(\"Can only activate draft tasks\")\n        \n        task.status = TaskStatus.ACTIVE\n        return task\n\n    def block_task(self, task_id: UUID, reason: str) -> Task:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(\"Task not found\")\n        \n        if task.status not in [TaskStatus.ACTIVE, TaskStatus.DONE]:\n            raise ValueError(\"Can only block active or done tasks\")\n        \n        task.status = TaskStatus.BLOCKED\n        return task\n\n    def complete_task(self, task_id: UUID) -> Task:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(\"Task not found\")\n        \n        if task.status != TaskStatus.ACTIVE:\n            raise ValueError(\"Can only complete active tasks\")\n        \n        if not task.checklist or all(task.checklist):\n            task.status = TaskStatus.DONE\n        else:\n            raise ValueError(\"Cannot complete task with incomplete checklist\")\n        \n        return task\n\n    def archive_task(self, task_id: UUID) -> Task:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(\"Task not found\")\n        \n        task.status = TaskStatus.ARCHIVED\n        return task\n\n    def list_tasks(self, status: Optional[TaskStatus] = None) -> List[Task]:\n        return [task for task in self.tasks.values() if status is None or task.status == status]\n\n    def add_checklist_item(self, task_id: UUID) -> Task:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(\"Task not found\")\n        \n        task.checklist.append(False)\n        return task\n\n    def toggle_checklist_item(self, task_id: UUID, item_index: int) -> Task:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(\"Task not found\")\n        \n        if item_index < 0 or item_index >= len(task.checklist):\n            raise ValueError(\"Invalid checklist item index\")\n        \n        task.checklist[item_index] = not task.checklist[item_index]\n        return task\n```\n\n## Step 3: Build explicit boundaries\n\nLet's implement the notification system and error handling:\n\n```python\nclass NotificationService:\n    def send_notification(self, task: Task, notification_type: str) -> None:\n        # In a real implementation, this would send an email or other notification\n        print(f\"Notification: {notification_type} for task {task.id}\")\n\nclass TaskServiceWithNotifications:\n    def __init__(self):\n        self.task_service = TaskService()\n        self.notification_service = NotificationService()\n\n    def create_task(self, *args, **kwargs) -> Task:\n        task = self.task_service.create_task(*args, **kwargs)\n        self.notification_service.send_notification(task, \"Task created\")\n        return task\n\n    def activate_task(self, task_id: UUID) -> Task:\n        task = self.task_service.activate_task(task_id)\n        self.notification_service.send_notification(task, \"Task activated\")\n        return task\n\n    # ... other methods would call notification_service as needed\n```\n\n## Step 4: Enforce one-way data flow and explicit dependencies\n\nLet's implement the overdue calculation and error handling:\n\n```python\nclass TaskServiceWithOverdue:\n    def is_overdue(self, task: Task) -> bool:\n        return task.is_overdue()\n\n    def list_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.task_service.tasks.values() \n                if self.is_overdue(task)]\n```\n\n## Step 5: Make failures explicit\n\nLet's implement error handling:\n\n```python\nfrom typing import Dict, Any\n\nclass TaskError(Exception):\n    def __init__(self, message: str, code: str, details: Optional[Dict[str, Any]] = None):\n        self.message = message\n        self.code = code\n        self.details = details or {}\n        super().__init__(self.message)\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"message\": self.message,\n            \"code\": self.code,\n            \"details\": self.details\n        }\n\n# Example usage:\ntry:\n    task = task_service.create_task(...)\nexcept TaskError as e:\n    # Handle error\n```\n\n## Step 6: Control lifetime and mutation\n\nThe current implementation already follows good practices for resource management and mutation control.\n\n## Step 7: Separate policy from mechanism\n\nThe policy (business rules) and mechanism (implementation) are well separated in the code above.\n\n## Step 8: Compose small units\n\nThe code is composed of small, focused units that can be tested independently.\n\n## Final Implementation\n\nHere's a summary of the implementation:\n\n1. We've defined clear state transitions for tasks\n2. We've separated core logic from effects (notifications)\n3. We've enforced one-way data flow\n4. We've made failures explicit with error handling\n5. We've controlled resource lifetime\n6. We've separated policy from mechanism\n7. We've composed small units\n\nThe implementation follows all the principles outlined in the skill guidance.\n\n## Next Steps\n\nTo complete the implementation, you would:\n\n1. Add a web interface or API layer\n2. Add persistence (database) for task storage\n3. Add authentication and authorization\n4. Add more comprehensive testing\n5. Add monitoring and logging\n\nWould you like me to help with any of these next steps?"
            },
            {
              "name": "legacy_refactor_all_principles",
              "input": "A legacy task service has become hard to maintain. Teams report frequent regressions, unclear failures, and inconsistent behavior between environments.\n\nCurrent behavior problems:\n- State changes occasionally skip required steps.\n- Some responses are ambiguous (callers cannot tell what failed).\n- Resource usage grows during long-running operation.\n- Business rules are difficult to change without side effects.\n- Different parts of the system produce different names for the same concept.\n\nRequest:\n- Propose a concrete refactor plan that can be delivered incrementally.\n- Include clear milestones, rollback strategy, and success criteria.\n- Show representative before/after examples for: state transition logic, failure handling, and naming consistency.\n- Keep the plan compact but actionable for a team of 10 engineers.",
              "expected": {
                "focus": "Does the plan concretely separate domain/core from adapters, remove illegal states, enforce one-way data flow and explicit dependencies, replace generic exceptions with typed errors, and improve naming to reflect responsibility?"
              },
              "baseline_response": "# Refactor Plan for Legacy Task Service\n\n## High-Level Goals\n1. Introduce clear state transitions with explicit steps\n2. Implement explicit error handling and recovery\n3. Standardize naming and resource management\n4. Modularize business rules for easier updates\n\n## Milestones\n1. State transition refactoring (2 weeks)\n2. Error handling standardization (3 weeks)\n3. Naming standardization (1 week)\n4. Resource management (2 weeks)\n\n## Rollback Strategy\n- Maintain original code in parallel during refactoring\n- Add unit tests for critical paths\n- Implement feature flags for gradual rollout\n\n## Success Criteria\n- 90% reduction in ambiguous failures\n- 50% reduction in resource growth\n- 30% faster deployment cycles\n\n## Before/After Examples\n\n### State Transition Logic\nBefore:\n```python\ndef process_task(task):\n    if task.state == \"new\":\n        # complex logic\n        if random():\n            task.state = \"complete\"\n        else:\n            task.state = \"failed\"\n```\n\nAfter:\n```python\nclass TaskProcessor:\n    def __init__(self):\n        self.state_machine = StateMachine()\n    \n    def process(self, task):\n        for step in self.state_machine.steps:\n            if not step.execute(task):\n                return False\n        return True\n```\n\n### Error Handling\nBefore:\n```python\ntry:\n    # complex operation\nexcept Exception as e:\n    # vague error handling\n```\n\nAfter:\n```python\nclass ErrorHandler:\n    def handle(self, error):\n        specific_handler = self._get_specific_handler(error)\n        return specific_handler.handle(error)\n```\n\n### Naming Consistency\nBefore:\n```python\nclass User:\n    pass\n\nclass Customer:\n    pass\n```\n\nAfter:\n```python\nclass User:\n    pass\n\nclass UserAlias(User):\n    pass\n```\n\n## Implementation Plan\n1. Start with state transition refactoring\n2. Implement error handling standardization\n3. Standardize naming\n4. Add resource monitoring\n\n## Team Roles\n- 2 engineers: Core refactoring\n- 2 engineers: Testing and validation\n- 1 engineer: Documentation and training\n- 1 engineer: Monitoring and rollback",
              "skill_response": "I'll help you design a refactor plan for your legacy task service. Let's follow the principles from the skill guidance to create a predictable, testable, and structurally hard-to-misuse codebase.\n\n## Refactor Plan\n\n### Milestones\n1. **State Model Refactor** - Define explicit state transitions and invariants\n2. **Core Logic Separation** - Extract pure business logic from effects\n3. **Boundary Definition** - Implement ports/adapters\n4. **Error Handling** - Implement explicit error handling\n5. **Resource Management** - Implement deterministic lifecycle\n6. **Policy Separation** - Separate policy from mechanism\n\n### Rollback Strategy\n- Maintain backward compatibility during transition\n- Keep old implementation alongside new for comparison\n- Add feature flags to toggle new behavior\n\n### Success Criteria\n- 100% test coverage\n- No ambiguous error handling\n- Deterministic resource cleanup\n- Clear state transitions\n- Policy and mechanism separation\n\n## Before/After Examples\n\n### State Transition Logic (Before)\n```python\nclass TaskService:\n    def process(self):\n        # State changes occasionally skip steps\n        if random.random() < 0.3:\n            self.state = \"completed\"\n        else:\n            self.state = \"failed\"\n```\n\n### State Transition Logic (After)\n```python\nclass TaskService:\n    def process(self):\n        # Explicit state transitions\n        if self.can_complete():\n            self.state = \"completed\"\n        else:\n            self.state = \"failed\"\n    \n    def can_complete(self):\n        # Clear state validation\n        return not self.has_errors() and self.dependencies_met()\n```\n\n### Error Handling (Before)\n```python\ntry:\n    # Some operation\nexcept Exception as e:\n    # Generic error handling\n    pass\n```\n\n### Error Handling (After)\n```python\nclass TaskError(Exception):\n    pass\n\ndef process_with_error_handling():\n    try:\n        # Some operation\n    except TaskError as e:\n        # Specific error handling\n        return Result.Err(e)\n    return Result.Ok(value)\n```\n\n### Naming Consistency (Before)\n```python\n# Inconsistent naming\nclass Task:\n    pass\n\nclass task:\n    pass\n```\n\n### Naming Consistency (After)\n```python\n# Consistent naming\nclass Task:\n    pass\n```\n\n## Implementation Plan\n\n### 1. State Model Refactor\n- Define explicit state transitions and invariants\n- Use type system to enforce valid states\n- Implement state validation\n\n### 2. Core Logic Separation\n- Extract pure business logic from effects\n- Implement domain model as pure functions\n- Move IO/external dependencies to adapters\n\n### 3. Boundary Definition\n- Define ports in domain language\n- Implement adapters outside domain\n- Wire dependencies only at composition root\n\n### 4. Error Handling\n- Implement explicit error handling\n- Use Result/Either for expected failures\n- Distinguish domain vs infrastructure errors\n\n### 5. Resource Management\n- Implement deterministic lifecycle\n- Guarantee cleanup on success/failure paths\n- Assign one owner per resource\n\n### 6. Policy Separation\n- Separate policy from mechanism\n- Implement configuration as data\n- Use strategy pattern for algorithms\n\n### 7. Composition\n- Compose small units\n- Avoid Manager/Coordinator god objects\n- Use names that express responsibility\n\n## Success Criteria\n\n1. **State Management**\n- Explicit state transitions\n- Type-safe state validation\n- Clear error handling\n\n2. **Core Logic**\n- Pure business logic\n- No side effects in domain code\n- Clear separation of concerns\n\n3. **Boundaries**\n- Well-defined ports/adapters\n- No hidden dependencies\n- Clear ownership of resources\n\n4. **Error Handling**\n- Explicit error types\n- Clear error paths\n- No generic exceptions\n\n5. **Resource Management**\n- Deterministic cleanup\n- Clear ownership\n- No resource leaks\n\n6. **Policy Separation**\n- Configurable policy\n- Clear mechanism\n- Easy to modify behavior\n\n7. **Composition**\n- Small, focused units\n- No central coordinators\n- Clear responsibilities\n\n## Rollback Strategy\n\n1. **Incremental Changes**\n- Start with state model refactor\n- Gradually introduce pure functions\n- Add error handling incrementally\n\n2. **Testing**\n- Add unit tests for state transitions\n- Add integration tests for error handling\n- Add property-based tests for resource management\n\n3. **Monitoring**\n- Track key metrics during transition\n- Have rollback plan ready\n- Keep old implementation during transition\n\n## Final Architecture\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Service\n    participant Adapter\n    participant Storage\n    \n    User->>+Service: Request\n    Service->>+Adapter: External call\n    Adapter->>+Storage: Persist\n    Storage->>-Adapter: Success\n    Adapter->>-Service: Response\n    Service->>-User: Response\n```\n\nThis refactor plan follows the principles from the skill guidance:\n- Explicit state invariants\n- Illegal states unrepresentable\n- Functional core, imperative shell\n- Explicit boundaries via ports/adapters\n- Single-direction data flow\n- Local reasoning with explicit dependencies\n- Explicit error handling\n- Deterministic resource lifecycle\n- Policy/mechanism separation\n- Composition over coordination\n- Minimized mutation\n- Naming as design\n\nThe plan is incremental, testable, and structurally hard to misuse. It addresses the issues reported in the legacy system and provides a clear path forward."
            }
          ]
        }
      ]
    }
  ],
  "summary": {
    "total_benchmarks": 1,
    "leaderboard": [
      {
        "model": "rnj-1:8b",
        "provider": "ollama",
        "total_tested": 1,
        "improvements": 1,
        "improvement_rate": 100.0
      }
    ]
  },
  "unique_skills": [
    "ps-all-principles-compressed"
  ],
  "provider_models": [
    [
      "ollama",
      "rnj-1:8b"
    ]
  ]
}