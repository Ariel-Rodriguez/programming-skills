{
  "benchmarks": [
    {
      "benchmark_id": "copilot-claude-haiku-4.5-20260207-232853",
      "timestamp": "2026-02-07T23:28:53",
      "provider": "copilot",
      "model": "claude-haiku-4.5",
      "skills": [
        {
          "skill_name": "ps-error-handling-design",
          "skill_version": "1.0.0",
          "provider": "copilot",
          "model": "claude-haiku-4.5",
          "timestamp": "2026-02-07T23:28:53",
          "baseline_rating": "regular",
          "skill_rating": "outstanding",
          "improvement": "yes",
          "reasoning": "Baseline rated: regular | With Skill rated: outstanding\n\nSolution A uses optional fields in a single type (LoginResult) rather than true discriminated union types, failing to fully enforce compiler error handling. More critically, its user import processor relies on try-catch blocks for domain/recoverable errors (ValidationError, ConstraintViolationError), violating the core principle of returning Results instead of throwing. Solution B demonstrates mastery by using proper discriminated union types (`LoginResult = success | failure`), making error handling compiler-enforced and impossible to ignore, and properly distinguishing recoverable errors (return Results) from non-recoverable ones (throw) throughout a well-layered architecture. Solution B's approach makes the type system itself prevent accidental error ignoring, while Solution A's approach still allows hidden failures in catch blocks.",
          "before_code": "// Test: auth_error_handling\n# Login Error Distinction Refactoring\n\n## Data Structures\n\n```typescript\n// Error type enumeration\nenum LoginErrorType {\n  INVALID_CREDENTIALS = \"INVALID_CREDENTIALS\",\n  ACCOUNT_LOCKED = \"ACCOUNT_LOCKED\",\n  SYSTEM_FAILURE = \"SYSTEM_FAILURE\"\n}\n\n// Result object returned by login\ninterface LoginResult {\n  success: boolean;\n  data?: { userId: string; token: string };\n  error?: {\n    type: LoginErrorType;\n    message: string;\n    retryable: boolean;\n  };\n}\n```\n\n## Login Function Logic\n\n```typescript\nasync function login(email: string, password: string): Promise<LoginResult> {\n  try {\n    // Check database connectivity\n    const user = await db.query(\"SELECT * FROM users WHERE email = ?\", [email]);\n    \n    if (!user) {\n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.INVALID_CREDENTIALS,\n          message: \"Invalid email or password\",\n          retryable: false\n        }\n      };\n    }\n    \n    // Check account lock status\n    if (user.locked_until && new Date(user.locked_until) > new Date()) {\n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.ACCOUNT_LOCKED,\n          message: `Account locked until ${user.locked_until}`,\n          retryable: true\n        }\n      };\n    }\n    \n    // Verify password\n    const passwordValid = await bcrypt.compare(password, user.password_hash);\n    if (!passwordValid) {\n      // Track failed attempts and lock if threshold exceeded\n      await incrementFailedAttempts(user.id);\n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.INVALID_CREDENTIALS,\n          message: \"Invalid email or password\",\n          retryable: false\n        }\n      };\n    }\n    \n    // Success\n    const token = generateToken(user.id);\n    return {\n      success: true,\n      data: { userId: user.id, token }\n    };\n    \n  } catch (err) {\n    // Network, database, or unexpected errors\n    console.error(\"Login error:\", err);\n    return {\n      success: false,\n      error: {\n        type: LoginErrorType.SYSTEM_FAILURE,\n        message: \"Login service temporarily unavailable\",\n        retryable: true\n      }\n    };\n  }\n}\n```\n\n## Caller Usage (Frontend)\n\n```typescript\nconst result = await login(email, password);\n\nif (result.success) {\n  // Store token and redirect\n  localStorage.setItem(\"token\", result.data.token);\n  redirectToDashboard();\n} else {\n  switch (result.error.type) {\n    case LoginErrorType.INVALID_CREDENTIALS:\n      showError(\"Incorrect email or password\");\n      focusPasswordField(); // Help user fix typo\n      break;\n    case LoginErrorType.ACCOUNT_LOCKED:\n      showError(result.error.message);\n      showAccountRecoveryLink();\n      break;\n    case LoginErrorType.SYSTEM_FAILURE:\n      showError(\"Login service down. Please try again shortly.\");\n      enableRetryButton();\n      logToMonitoring(result.error); // Alert ops team\n      break;\n  }\n}\n```\n\n## Key Advantages\n\n- **User Experience**: Users see actionable messages (fix typo, recover account, try later)\n- **Support**: Distinguishes user error from infrastructure issues\n- **Frontend**: Can implement different UX strategies (retry logic, messaging tone, buttons)\n- **Monitoring**: System failures are tagged and alertable\n- **Testing**: Each error path is explicit and testable\n\n// Test: robust_registration_design\n# User Import Processor with Error Handling\n\n```javascript\nclass UserImportProcessor {\n  async processBatch(users) {\n    const results = {\n      processed: [],\n      invalid: [],\n      constraintViolations: [],\n      errors: []\n    };\n\n    for (const user of users) {\n      try {\n        // Validate data first\n        this.validateUserData(user);\n        \n        // Attempt database insert\n        const result = await this.saveUser(user);\n        results.processed.push(result);\n        \n      } catch (error) {\n        // Distinguish error types\n        if (error instanceof ValidationError) {\n          // Invalid data - skip and report\n          results.invalid.push({\n            user: user.email,\n            reason: error.message\n          });\n          console.warn(`Skipped invalid user: ${user.email} - ${error.message}`);\n          \n        } else if (error instanceof ConstraintViolationError) {\n          // DB constraint violation - skip and report\n          results.constraintViolations.push({\n            user: user.email,\n            constraint: error.constraint,\n            reason: error.message\n          });\n          console.warn(`Skipped user (constraint): ${user.email} - ${error.constraint}`);\n          \n        } else if (error instanceof ConnectionError) {\n          // DB connection loss - stop immediately\n          console.error(`Connection lost at user: ${user.email}`);\n          throw new Error(`Database connection lost. Processing halted. Processed: ${results.processed.length}, Failed: ${results.invalid.length + results.constraintViolations.length}`);\n        } else {\n          results.errors.push({ user: user.email, error: error.message });\n        }\n      }\n    }\n\n    return results;\n  }\n\n  validateUserData(user) {\n    if (!user.email || !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(user.email)) {\n      throw new ValidationError(`Invalid email: ${user.email}`);\n    }\n    if (!user.name || user.name.trim().length === 0) {\n      throw new ValidationError(`Name is required`);\n    }\n  }\n\n  async saveUser(user) {\n    try {\n      // Simulated database call\n      const result = await database.users.insert(user);\n      return result;\n    } catch (dbError) {\n      // Distinguish constraint vs connection errors\n      if (dbError.code === 'ECONNREFUSED' || dbError.code === 'ETIMEDOUT') {\n        throw new ConnectionError('Database connection failed', dbError);\n      } else if (dbError.code === 'ER_DUP_ENTRY' || dbError.constraint) {\n        throw new ConstraintViolationError(\n          `Constraint violation: ${dbError.constraint || 'unique key'}`,\n          dbError\n        );\n      }\n      throw dbError;\n    }\n  }\n}\n\n// Custom error classes for type checking\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nclass ConstraintViolationError extends Error {\n  constructor(message, originalError) {\n    super(message);\n    this.name = 'ConstraintViolationError';\n    this.constraint = originalError?.constraint;\n  }\n}\n\nclass ConnectionError extends Error {\n  constructor(message, originalError) {\n    super(message);\n    this.name = 'ConnectionError';\n    this.originalError = originalError;\n  }\n}\n\n// Usage\nconst processor = new UserImportProcessor();\ntry {\n  const results = await processor.processBatch(importedUsers);\n  console.log('Summary:', {\n    processed: results.processed.length,\n    invalid: results.invalid.length,\n    constraintViolations: results.constraintViolations.length,\n    criticalErrors: results.errors.length\n  });\n} catch (error) {\n  // Handle connection loss - alert/log critical failure\n  console.error('CRITICAL:', error.message);\n  // Send alert, rollback, notify admin, etc.\n  await notifyAdministrator(error);\n}\n```\n\n**Key Distinctions:**\n- **Custom Error Classes**: `ValidationError`, `ConstraintViolationError`, `ConnectionError` enable `instanceof` checks\n- **Error Codes**: Check database error codes (`ECONNREFUSED`, `ER_DUP_ENTRY`) to identify root cause\n- **Handling Strategy**: Invalid/constraint errors are reported but continue processing; connection loss throws and halts immediately",
          "after_code": "// Test: auth_error_handling\n# Refactored Login Error Handling\n\n## Data Structures\n\n```typescript\n// Error types - explicit, categorized\ntype LoginError = \n  | { type: 'INVALID_CREDENTIALS'; message: 'Username or password is incorrect' }\n  | { type: 'ACCOUNT_LOCKED'; retryAfterMs: number; message: 'Account locked after too many attempts' }\n  | { type: 'SYSTEM_FAILURE'; code: string; message: 'Unable to process login. Please try again.' }\n\ntype LoginResult = \n  | { success: true; userId: string; token: string }\n  | { success: false; error: LoginError }\n\n// Optional: Structured result helper\nconst LoginSuccess = (userId: string, token: string) => ({\n  success: true as const,\n  userId,\n  token\n})\n\nconst LoginFailure = (error: LoginError) => ({\n  success: false as const,\n  error\n})\n```\n\n## Refactored Login Logic\n\n```typescript\nasync function login(username: string, password: string): Promise<LoginResult> {\n  try {\n    // Check database connectivity\n    const user = await db.users.findByUsername(username)\n    \n    // User not found OR password mismatch = same error (security)\n    if (!user || !await bcrypt.compare(password, user.passwordHash)) {\n      return LoginFailure({\n        type: 'INVALID_CREDENTIALS',\n        message: 'Username or password is incorrect'\n      })\n    }\n    \n    // Account lock check - separate concern\n    if (user.lockedUntil && user.lockedUntil > Date.now()) {\n      return LoginFailure({\n        type: 'ACCOUNT_LOCKED',\n        retryAfterMs: user.lockedUntil - Date.now(),\n        message: 'Account locked after too many attempts'\n      })\n    }\n    \n    // Lock cleared, reset failed attempts\n    if (user.failedAttempts > 0) {\n      await db.users.update(user.id, { failedAttempts: 0 })\n    }\n    \n    const token = generateToken(user.id)\n    return LoginSuccess(user.id, token)\n    \n  } catch (err) {\n    // Database errors, network errors, etc. = retryable\n    console.error('Login system failure:', err)\n    return LoginFailure({\n      type: 'SYSTEM_FAILURE',\n      code: err instanceof DatabaseError ? 'DB_ERROR' : 'NETWORK_ERROR',\n      message: 'Unable to process login. Please try again.'\n    })\n  }\n}\n```\n\n## Frontend Usage\n\n```typescript\nconst result = await login(username, password)\n\nif (result.success) {\n  // Success path\n  storeToken(result.token)\n  redirectToDashboard()\n} else {\n  // Error-specific handling\n  switch (result.error.type) {\n    case 'INVALID_CREDENTIALS':\n      showError('Username or password is incorrect')\n      break\n      \n    case 'ACCOUNT_LOCKED':\n      showError(`Account locked. Try again in ${Math.ceil(result.error.retryAfterMs / 1000)}s`)\n      disableLoginForm(result.error.retryAfterMs)\n      break\n      \n    case 'SYSTEM_FAILURE':\n      showError('Our servers are having issues. Please try again shortly.')\n      logToSentry(result.error)\n      break\n  }\n}\n```\n\n**Key improvements:**\n- Errors are explicit in return type\u2014caller must handle them\n- Each error type carries appropriate context (lock duration, error code)\n- Frontend distinguishes between user actionable (invalid credentials, locked) vs retryable (system failure)\n- Support team sees exact failure reason in logs\n- Compiler enforces that success/failure paths are handled\n\n// Test: robust_registration_design\n# Error Handling for Batch User Import Processor\n\nHere's a solution that explicitly handles the three error categories with distinct strategies:\n\n```typescript\n// 1. EXPLICIT ERROR TYPES - Make failure modes visible\n\ntype ImportResult<T> = \n  | { ok: true; value: T }\n  | { ok: false; error: ImportError };\n\ntype ImportError = \n  | { type: \"VALIDATION_ERROR\"; field: string; message: string; userId: string }\n  | { type: \"CONSTRAINT_ERROR\"; constraint: string; message: string; userId: string }\n  | { type: \"CONNECTION_ERROR\"; message: string };\n\n// 2. DOMAIN LAYER - Return Results for recoverable errors\n\nfunction validateUserData(user: unknown): ImportResult<ValidUser> {\n  if (!user || typeof user !== \"object\") {\n    return {\n      ok: false,\n      error: { type: \"VALIDATION_ERROR\", field: \"root\", message: \"Invalid object\", userId: \"\" }\n    };\n  }\n  \n  const u = user as any;\n  \n  if (!u.email || !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(u.email)) {\n    return {\n      ok: false,\n      error: { type: \"VALIDATION_ERROR\", field: \"email\", message: \"Invalid email format\", userId: u.id || \"\" }\n    };\n  }\n  \n  if (!u.name || u.name.trim().length === 0) {\n    return {\n      ok: false,\n      error: { type: \"VALIDATION_ERROR\", field: \"name\", message: \"Name required\", userId: u.id }\n    };\n  }\n  \n  return { ok: true, value: { id: u.id, email: u.email, name: u.name.trim() } };\n}\n\nasync function insertUser(user: ValidUser): ImportResult<User> {\n  try {\n    const result = await database.insert(\"users\", user);\n    return { ok: true, value: result };\n  } catch (err) {\n    // Distinguish infrastructure errors from constraint violations\n    if (err instanceof ConstraintError) {\n      return {\n        ok: false,\n        error: { \n          type: \"CONSTRAINT_ERROR\", \n          constraint: err.constraint,\n          message: `Duplicate ${err.constraint}`,\n          userId: user.id\n        }\n      };\n    }\n    \n    // Non-recoverable: connection loss\n    if (err instanceof ConnectionError) {\n      throw {\n        type: \"CONNECTION_ERROR\",\n        message: `Database connection lost: ${err.message}`\n      };\n    }\n    \n    // Unexpected: crash fast\n    throw err;\n  }\n}\n\n// 3. APPLICATION LAYER - Coordinate and distinguish handling\n\ninterface ImportStats {\n  processed: number;\n  successful: number;\n  skipped: ImportError[];\n}\n\nasync function processBatchImport(users: unknown[]): Promise<ImportStats> {\n  const stats: ImportStats = {\n    processed: users.length,\n    successful: 0,\n    skipped: []\n  };\n  \n  for (const user of users) {\n    // STEP 1: Validation (domain error - skip and report)\n    const validationResult = validateUserData(user);\n    if (!validationResult.ok) {\n      stats.skipped.push(validationResult.error);\n      continue; // RECOVERABLE: skip this record, continue processing\n    }\n    \n    // STEP 2: Database insert (could be constraint or connection error)\n    try {\n      const insertResult = await insertUser(validationResult.value);\n      \n      if (!insertResult.ok) {\n        // RECOVERABLE: constraint violation, skip and report\n        stats.skipped.push(insertResult.error);\n        continue;\n      }\n      \n      stats.successful++;\n      \n    } catch (err) {\n      // NON-RECOVERABLE: connection loss or programming error\n      // Stop immediately - partial state is unsafe\n      throw {\n        type: \"BATCH_FAILED\",\n        processedCount: stats.processed - users.length + stats.successful,\n        cause: err\n      };\n    }\n  }\n  \n  return stats;\n}\n\n// 4. PRESENTATION LAYER - Convert to user-friendly responses\n\nasync function handleUserImport(rawUsers: unknown[]): Promise<ApiResponse> {\n  try {\n    const stats = await processBatchImport(rawUsers);\n    \n    if (stats.skipped.length === 0) {\n      return {\n        status: 200,\n        body: {\n          message: `Successfully imported ${stats.successful} users`,\n          imported: stats.successful\n        }\n      };\n    }\n    \n    // Partial success - report what failed\n    const errorDetails = stats.skipped.map(err => {\n      if (err.type === \"VALIDATION_ERROR\") {\n        return `User ${err.userId}: Invalid ${err.field} - ${err.message}`;\n      }\n      if (err.type === \"CONSTRAINT_ERROR\") {\n        return `User ${err.userId}: ${err.constraint} already exists`;\n      }\n      return `User ${err.userId}: Unknown error`;\n    });\n    \n    return {\n      status: 207, // Multi-Status: partial success\n      body: {\n        message: `Imported ${stats.successful}/${stats.processed}`,\n        imported: stats.successful,\n        failed: errorDetails\n      }\n    };\n    \n  } catch (err) {\n    // NON-RECOVERABLE: connection loss or state corruption\n    logger.error(\"CRITICAL: Batch import failed\", err);\n    \n    return {\n      status: 500,\n      body: {\n        message: \"Import failed - database unavailable. Process halted.\",\n        error: \"DATABASE_CONNECTION_FAILED\"\n      }\n    };\n  }\n}\n```\n\n## Key Distinctions:\n\n| Error | Category | Handling | Result |\n|-------|----------|----------|--------|\n| **Invalid email** | Domain (validation) | Return Result | Skip record, continue |\n| **Duplicate email** | Infrastructure (constraint) | Return Result | Skip record, continue |\n| **No DB connection** | Programming/Critical | Throw + crash | Stop immediately, alert |\n\n**Why this works:**\n- \u2705 **Validation errors** visible in return type \u2192 caller must check `.ok` field\n- \u2705 **Constraint errors** caught and converted to domain errors \u2192 graceful degradation\n- \u2705 **Connection loss** thrown immediately \u2192 fail-fast prevents corrupted partial state\n- \u2705 **Error context preserved** \u2192 debugging shows which users failed and why\n- \u2705 **No empty catch blocks** \u2192 all errors are handled purposefully\n- \u2705 **Tested and auditable** \u2192 each error path is explicit",
          "judgment": {
            "principle_better": "B",
            "quality_better": "B",
            "overall_better": "B",
            "option_a_rating": "regular",
            "option_b_rating": "outstanding",
            "score": 100,
            "reasoning": "Solution A uses optional fields in a single type (LoginResult) rather than true discriminated union types, failing to fully enforce compiler error handling. More critically, its user import processor relies on try-catch blocks for domain/recoverable errors (ValidationError, ConstraintViolationError), violating the core principle of returning Results instead of throwing. Solution B demonstrates mastery by using proper discriminated union types (`LoginResult = success | failure`), making error handling compiler-enforced and impossible to ignore, and properly distinguishing recoverable errors (return Results) from non-recoverable ones (throw) throughout a well-layered architecture. Solution B's approach makes the type system itself prevent accidental error ignoring, while Solution A's approach still allows hidden failures in catch blocks."
          },
          "judge_error": false,
          "tests": [
            {
              "name": "auth_error_handling",
              "input": "The current `login` function returns `null` if anything goes wrong (user missing, wrong password, db down). This leads to a generic \"Login Failed\" error on the frontend, which frustrates users who might just have a typo, and confuses support teams when the DB is actually down.\n\nRefactor the return values/mechanism so the caller can definitively distinguish between:\n1. Invalid Credentials (user actionable)\n2. Account Locked (user actionable)\n3. System/Network Failure (retryable)\n\nProvide the code for the logic and the data structures used.",
              "expected": {
                "focus": "Does the solution return structured error info (e.g., error codes, types) instead of a generic null/false?"
              },
              "baseline_response": "# Login Error Distinction Refactoring\n\n## Data Structures\n\n```typescript\n// Error type enumeration\nenum LoginErrorType {\n  INVALID_CREDENTIALS = \"INVALID_CREDENTIALS\",\n  ACCOUNT_LOCKED = \"ACCOUNT_LOCKED\",\n  SYSTEM_FAILURE = \"SYSTEM_FAILURE\"\n}\n\n// Result object returned by login\ninterface LoginResult {\n  success: boolean;\n  data?: { userId: string; token: string };\n  error?: {\n    type: LoginErrorType;\n    message: string;\n    retryable: boolean;\n  };\n}\n```\n\n## Login Function Logic\n\n```typescript\nasync function login(email: string, password: string): Promise<LoginResult> {\n  try {\n    // Check database connectivity\n    const user = await db.query(\"SELECT * FROM users WHERE email = ?\", [email]);\n    \n    if (!user) {\n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.INVALID_CREDENTIALS,\n          message: \"Invalid email or password\",\n          retryable: false\n        }\n      };\n    }\n    \n    // Check account lock status\n    if (user.locked_until && new Date(user.locked_until) > new Date()) {\n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.ACCOUNT_LOCKED,\n          message: `Account locked until ${user.locked_until}`,\n          retryable: true\n        }\n      };\n    }\n    \n    // Verify password\n    const passwordValid = await bcrypt.compare(password, user.password_hash);\n    if (!passwordValid) {\n      // Track failed attempts and lock if threshold exceeded\n      await incrementFailedAttempts(user.id);\n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.INVALID_CREDENTIALS,\n          message: \"Invalid email or password\",\n          retryable: false\n        }\n      };\n    }\n    \n    // Success\n    const token = generateToken(user.id);\n    return {\n      success: true,\n      data: { userId: user.id, token }\n    };\n    \n  } catch (err) {\n    // Network, database, or unexpected errors\n    console.error(\"Login error:\", err);\n    return {\n      success: false,\n      error: {\n        type: LoginErrorType.SYSTEM_FAILURE,\n        message: \"Login service temporarily unavailable\",\n        retryable: true\n      }\n    };\n  }\n}\n```\n\n## Caller Usage (Frontend)\n\n```typescript\nconst result = await login(email, password);\n\nif (result.success) {\n  // Store token and redirect\n  localStorage.setItem(\"token\", result.data.token);\n  redirectToDashboard();\n} else {\n  switch (result.error.type) {\n    case LoginErrorType.INVALID_CREDENTIALS:\n      showError(\"Incorrect email or password\");\n      focusPasswordField(); // Help user fix typo\n      break;\n    case LoginErrorType.ACCOUNT_LOCKED:\n      showError(result.error.message);\n      showAccountRecoveryLink();\n      break;\n    case LoginErrorType.SYSTEM_FAILURE:\n      showError(\"Login service down. Please try again shortly.\");\n      enableRetryButton();\n      logToMonitoring(result.error); // Alert ops team\n      break;\n  }\n}\n```\n\n## Key Advantages\n\n- **User Experience**: Users see actionable messages (fix typo, recover account, try later)\n- **Support**: Distinguishes user error from infrastructure issues\n- **Frontend**: Can implement different UX strategies (retry logic, messaging tone, buttons)\n- **Monitoring**: System failures are tagged and alertable\n- **Testing**: Each error path is explicit and testable",
              "skill_response": "# Refactored Login Error Handling\n\n## Data Structures\n\n```typescript\n// Error types - explicit, categorized\ntype LoginError = \n  | { type: 'INVALID_CREDENTIALS'; message: 'Username or password is incorrect' }\n  | { type: 'ACCOUNT_LOCKED'; retryAfterMs: number; message: 'Account locked after too many attempts' }\n  | { type: 'SYSTEM_FAILURE'; code: string; message: 'Unable to process login. Please try again.' }\n\ntype LoginResult = \n  | { success: true; userId: string; token: string }\n  | { success: false; error: LoginError }\n\n// Optional: Structured result helper\nconst LoginSuccess = (userId: string, token: string) => ({\n  success: true as const,\n  userId,\n  token\n})\n\nconst LoginFailure = (error: LoginError) => ({\n  success: false as const,\n  error\n})\n```\n\n## Refactored Login Logic\n\n```typescript\nasync function login(username: string, password: string): Promise<LoginResult> {\n  try {\n    // Check database connectivity\n    const user = await db.users.findByUsername(username)\n    \n    // User not found OR password mismatch = same error (security)\n    if (!user || !await bcrypt.compare(password, user.passwordHash)) {\n      return LoginFailure({\n        type: 'INVALID_CREDENTIALS',\n        message: 'Username or password is incorrect'\n      })\n    }\n    \n    // Account lock check - separate concern\n    if (user.lockedUntil && user.lockedUntil > Date.now()) {\n      return LoginFailure({\n        type: 'ACCOUNT_LOCKED',\n        retryAfterMs: user.lockedUntil - Date.now(),\n        message: 'Account locked after too many attempts'\n      })\n    }\n    \n    // Lock cleared, reset failed attempts\n    if (user.failedAttempts > 0) {\n      await db.users.update(user.id, { failedAttempts: 0 })\n    }\n    \n    const token = generateToken(user.id)\n    return LoginSuccess(user.id, token)\n    \n  } catch (err) {\n    // Database errors, network errors, etc. = retryable\n    console.error('Login system failure:', err)\n    return LoginFailure({\n      type: 'SYSTEM_FAILURE',\n      code: err instanceof DatabaseError ? 'DB_ERROR' : 'NETWORK_ERROR',\n      message: 'Unable to process login. Please try again.'\n    })\n  }\n}\n```\n\n## Frontend Usage\n\n```typescript\nconst result = await login(username, password)\n\nif (result.success) {\n  // Success path\n  storeToken(result.token)\n  redirectToDashboard()\n} else {\n  // Error-specific handling\n  switch (result.error.type) {\n    case 'INVALID_CREDENTIALS':\n      showError('Username or password is incorrect')\n      break\n      \n    case 'ACCOUNT_LOCKED':\n      showError(`Account locked. Try again in ${Math.ceil(result.error.retryAfterMs / 1000)}s`)\n      disableLoginForm(result.error.retryAfterMs)\n      break\n      \n    case 'SYSTEM_FAILURE':\n      showError('Our servers are having issues. Please try again shortly.')\n      logToSentry(result.error)\n      break\n  }\n}\n```\n\n**Key improvements:**\n- Errors are explicit in return type\u2014caller must handle them\n- Each error type carries appropriate context (lock duration, error code)\n- Frontend distinguishes between user actionable (invalid credentials, locked) vs retryable (system failure)\n- Support team sees exact failure reason in logs\n- Compiler enforces that success/failure paths are handled"
            },
            {
              "name": "robust_registration_design",
              "input": "We need to process a batch of user imports. Some might have invalid data, others might fail due to database constraint violations.\n\nwrite a processor function that handles these failures appropriately:\n- Invalid data: Skip and report.\n- DB Constraint: Skip and report.\n- DB Connection Loss: Stop processing and throw/alert.\n\nShow how you distinguish these cases in code.",
              "expected": {
                "focus": "Does the code differentiate between recoverable item-level errors and fatal batch-level errors?"
              },
              "baseline_response": "# User Import Processor with Error Handling\n\n```javascript\nclass UserImportProcessor {\n  async processBatch(users) {\n    const results = {\n      processed: [],\n      invalid: [],\n      constraintViolations: [],\n      errors: []\n    };\n\n    for (const user of users) {\n      try {\n        // Validate data first\n        this.validateUserData(user);\n        \n        // Attempt database insert\n        const result = await this.saveUser(user);\n        results.processed.push(result);\n        \n      } catch (error) {\n        // Distinguish error types\n        if (error instanceof ValidationError) {\n          // Invalid data - skip and report\n          results.invalid.push({\n            user: user.email,\n            reason: error.message\n          });\n          console.warn(`Skipped invalid user: ${user.email} - ${error.message}`);\n          \n        } else if (error instanceof ConstraintViolationError) {\n          // DB constraint violation - skip and report\n          results.constraintViolations.push({\n            user: user.email,\n            constraint: error.constraint,\n            reason: error.message\n          });\n          console.warn(`Skipped user (constraint): ${user.email} - ${error.constraint}`);\n          \n        } else if (error instanceof ConnectionError) {\n          // DB connection loss - stop immediately\n          console.error(`Connection lost at user: ${user.email}`);\n          throw new Error(`Database connection lost. Processing halted. Processed: ${results.processed.length}, Failed: ${results.invalid.length + results.constraintViolations.length}`);\n        } else {\n          results.errors.push({ user: user.email, error: error.message });\n        }\n      }\n    }\n\n    return results;\n  }\n\n  validateUserData(user) {\n    if (!user.email || !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(user.email)) {\n      throw new ValidationError(`Invalid email: ${user.email}`);\n    }\n    if (!user.name || user.name.trim().length === 0) {\n      throw new ValidationError(`Name is required`);\n    }\n  }\n\n  async saveUser(user) {\n    try {\n      // Simulated database call\n      const result = await database.users.insert(user);\n      return result;\n    } catch (dbError) {\n      // Distinguish constraint vs connection errors\n      if (dbError.code === 'ECONNREFUSED' || dbError.code === 'ETIMEDOUT') {\n        throw new ConnectionError('Database connection failed', dbError);\n      } else if (dbError.code === 'ER_DUP_ENTRY' || dbError.constraint) {\n        throw new ConstraintViolationError(\n          `Constraint violation: ${dbError.constraint || 'unique key'}`,\n          dbError\n        );\n      }\n      throw dbError;\n    }\n  }\n}\n\n// Custom error classes for type checking\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nclass ConstraintViolationError extends Error {\n  constructor(message, originalError) {\n    super(message);\n    this.name = 'ConstraintViolationError';\n    this.constraint = originalError?.constraint;\n  }\n}\n\nclass ConnectionError extends Error {\n  constructor(message, originalError) {\n    super(message);\n    this.name = 'ConnectionError';\n    this.originalError = originalError;\n  }\n}\n\n// Usage\nconst processor = new UserImportProcessor();\ntry {\n  const results = await processor.processBatch(importedUsers);\n  console.log('Summary:', {\n    processed: results.processed.length,\n    invalid: results.invalid.length,\n    constraintViolations: results.constraintViolations.length,\n    criticalErrors: results.errors.length\n  });\n} catch (error) {\n  // Handle connection loss - alert/log critical failure\n  console.error('CRITICAL:', error.message);\n  // Send alert, rollback, notify admin, etc.\n  await notifyAdministrator(error);\n}\n```\n\n**Key Distinctions:**\n- **Custom Error Classes**: `ValidationError`, `ConstraintViolationError`, `ConnectionError` enable `instanceof` checks\n- **Error Codes**: Check database error codes (`ECONNREFUSED`, `ER_DUP_ENTRY`) to identify root cause\n- **Handling Strategy**: Invalid/constraint errors are reported but continue processing; connection loss throws and halts immediately",
              "skill_response": "# Error Handling for Batch User Import Processor\n\nHere's a solution that explicitly handles the three error categories with distinct strategies:\n\n```typescript\n// 1. EXPLICIT ERROR TYPES - Make failure modes visible\n\ntype ImportResult<T> = \n  | { ok: true; value: T }\n  | { ok: false; error: ImportError };\n\ntype ImportError = \n  | { type: \"VALIDATION_ERROR\"; field: string; message: string; userId: string }\n  | { type: \"CONSTRAINT_ERROR\"; constraint: string; message: string; userId: string }\n  | { type: \"CONNECTION_ERROR\"; message: string };\n\n// 2. DOMAIN LAYER - Return Results for recoverable errors\n\nfunction validateUserData(user: unknown): ImportResult<ValidUser> {\n  if (!user || typeof user !== \"object\") {\n    return {\n      ok: false,\n      error: { type: \"VALIDATION_ERROR\", field: \"root\", message: \"Invalid object\", userId: \"\" }\n    };\n  }\n  \n  const u = user as any;\n  \n  if (!u.email || !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(u.email)) {\n    return {\n      ok: false,\n      error: { type: \"VALIDATION_ERROR\", field: \"email\", message: \"Invalid email format\", userId: u.id || \"\" }\n    };\n  }\n  \n  if (!u.name || u.name.trim().length === 0) {\n    return {\n      ok: false,\n      error: { type: \"VALIDATION_ERROR\", field: \"name\", message: \"Name required\", userId: u.id }\n    };\n  }\n  \n  return { ok: true, value: { id: u.id, email: u.email, name: u.name.trim() } };\n}\n\nasync function insertUser(user: ValidUser): ImportResult<User> {\n  try {\n    const result = await database.insert(\"users\", user);\n    return { ok: true, value: result };\n  } catch (err) {\n    // Distinguish infrastructure errors from constraint violations\n    if (err instanceof ConstraintError) {\n      return {\n        ok: false,\n        error: { \n          type: \"CONSTRAINT_ERROR\", \n          constraint: err.constraint,\n          message: `Duplicate ${err.constraint}`,\n          userId: user.id\n        }\n      };\n    }\n    \n    // Non-recoverable: connection loss\n    if (err instanceof ConnectionError) {\n      throw {\n        type: \"CONNECTION_ERROR\",\n        message: `Database connection lost: ${err.message}`\n      };\n    }\n    \n    // Unexpected: crash fast\n    throw err;\n  }\n}\n\n// 3. APPLICATION LAYER - Coordinate and distinguish handling\n\ninterface ImportStats {\n  processed: number;\n  successful: number;\n  skipped: ImportError[];\n}\n\nasync function processBatchImport(users: unknown[]): Promise<ImportStats> {\n  const stats: ImportStats = {\n    processed: users.length,\n    successful: 0,\n    skipped: []\n  };\n  \n  for (const user of users) {\n    // STEP 1: Validation (domain error - skip and report)\n    const validationResult = validateUserData(user);\n    if (!validationResult.ok) {\n      stats.skipped.push(validationResult.error);\n      continue; // RECOVERABLE: skip this record, continue processing\n    }\n    \n    // STEP 2: Database insert (could be constraint or connection error)\n    try {\n      const insertResult = await insertUser(validationResult.value);\n      \n      if (!insertResult.ok) {\n        // RECOVERABLE: constraint violation, skip and report\n        stats.skipped.push(insertResult.error);\n        continue;\n      }\n      \n      stats.successful++;\n      \n    } catch (err) {\n      // NON-RECOVERABLE: connection loss or programming error\n      // Stop immediately - partial state is unsafe\n      throw {\n        type: \"BATCH_FAILED\",\n        processedCount: stats.processed - users.length + stats.successful,\n        cause: err\n      };\n    }\n  }\n  \n  return stats;\n}\n\n// 4. PRESENTATION LAYER - Convert to user-friendly responses\n\nasync function handleUserImport(rawUsers: unknown[]): Promise<ApiResponse> {\n  try {\n    const stats = await processBatchImport(rawUsers);\n    \n    if (stats.skipped.length === 0) {\n      return {\n        status: 200,\n        body: {\n          message: `Successfully imported ${stats.successful} users`,\n          imported: stats.successful\n        }\n      };\n    }\n    \n    // Partial success - report what failed\n    const errorDetails = stats.skipped.map(err => {\n      if (err.type === \"VALIDATION_ERROR\") {\n        return `User ${err.userId}: Invalid ${err.field} - ${err.message}`;\n      }\n      if (err.type === \"CONSTRAINT_ERROR\") {\n        return `User ${err.userId}: ${err.constraint} already exists`;\n      }\n      return `User ${err.userId}: Unknown error`;\n    });\n    \n    return {\n      status: 207, // Multi-Status: partial success\n      body: {\n        message: `Imported ${stats.successful}/${stats.processed}`,\n        imported: stats.successful,\n        failed: errorDetails\n      }\n    };\n    \n  } catch (err) {\n    // NON-RECOVERABLE: connection loss or state corruption\n    logger.error(\"CRITICAL: Batch import failed\", err);\n    \n    return {\n      status: 500,\n      body: {\n        message: \"Import failed - database unavailable. Process halted.\",\n        error: \"DATABASE_CONNECTION_FAILED\"\n      }\n    };\n  }\n}\n```\n\n## Key Distinctions:\n\n| Error | Category | Handling | Result |\n|-------|----------|----------|--------|\n| **Invalid email** | Domain (validation) | Return Result | Skip record, continue |\n| **Duplicate email** | Infrastructure (constraint) | Return Result | Skip record, continue |\n| **No DB connection** | Programming/Critical | Throw + crash | Stop immediately, alert |\n\n**Why this works:**\n- \u2705 **Validation errors** visible in return type \u2192 caller must check `.ok` field\n- \u2705 **Constraint errors** caught and converted to domain errors \u2192 graceful degradation\n- \u2705 **Connection loss** thrown immediately \u2192 fail-fast prevents corrupted partial state\n- \u2705 **Error context preserved** \u2192 debugging shows which users failed and why\n- \u2705 **No empty catch blocks** \u2192 all errors are handled purposefully\n- \u2705 **Tested and auditable** \u2192 each error path is explicit"
            }
          ]
        }
      ]
    }
  ],
  "summary": {
    "total_benchmarks": 1,
    "leaderboard": [
      {
        "model": "claude-haiku-4.5",
        "provider": "copilot",
        "total_tested": 1,
        "improvements": 1,
        "improvement_rate": 100.0
      }
    ]
  },
  "unique_skills": [
    "ps-error-handling-design"
  ],
  "provider_models": [
    [
      "copilot",
      "claude-haiku-4.5"
    ]
  ]
}