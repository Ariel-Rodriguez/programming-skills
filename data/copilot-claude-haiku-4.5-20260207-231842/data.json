{
  "benchmarks": [
    {
      "benchmark_id": "copilot-claude-haiku-4.5-20260207-231842",
      "timestamp": "2026-02-07T23:18:42",
      "provider": "copilot",
      "model": "claude-haiku-4.5",
      "skills": [
        {
          "skill_name": "ps-error-handling-design",
          "skill_version": "1.0.0",
          "provider": "copilot",
          "model": "claude-haiku-4.5",
          "timestamp": "2026-02-07T23:18:42",
          "baseline_rating": "outstanding",
          "skill_rating": "good",
          "improvement": "no",
          "reasoning": "Baseline rated: outstanding | With Skill rated: good\n\nSolution A consistently returns Result types for all expected failures (domain, system, infrastructure), forcing callers to handle errors explicitly via pattern matching. Solution B still throws exceptions for infrastructure errors (DatabaseConnectionError, NetworkError), partially reverting to implicit error handling that violates the principle. Solution A's comprehensive approach\u2014converting all errors to domain Results, providing rich context (isRetryable, attempts, lockoutDuration), and showing clear consumer handling\u2014demonstrates superior adherence to explicit error design, while also being more maintainable and testable.",
          "before_code": "// Test: auth_error_handling\nLet me search for the login function:\n\nLet me search more specifically for login-related code:\n\nLet me check the actual skill content:\n\nNow let me check the test.json to see what the actual problem case is:\n\nPerfect. Now I have the full context. The user is asking for a refactored login function that returns structured error information instead of null. Let me provide the code solution directly.\n\n## Solution: Refactored Login Function with Structured Error Handling\n\n**Data Structures:**\n\n```typescript\n// Error type enum for categorization\nenum LoginErrorType {\n  INVALID_CREDENTIALS = \"INVALID_CREDENTIALS\",\n  ACCOUNT_LOCKED = \"ACCOUNT_LOCKED\",\n  SYSTEM_FAILURE = \"SYSTEM_FAILURE\"\n}\n\n// Result type - Either Success or Failure\ntype LoginResult = \n  | { success: true; value: User }\n  | { success: false; error: LoginError }\n\n// Detailed error structure\ninterface LoginError {\n  type: LoginErrorType\n  message: string\n  isRetryable: boolean\n  context?: {\n    userId?: string\n    attempts?: number\n    lockoutDuration?: number\n    originalError?: string\n  }\n}\n\n// User type\ninterface User {\n  id: string\n  email: string\n  // ... other user fields\n}\n```\n\n**Refactored Login Logic:**\n\n```typescript\nasync function login(email: string, password: string): Promise<LoginResult> {\n  try {\n    // Attempt to fetch user from database\n    let user: User | null\n    try {\n      user = await database.findByEmail(email)\n    } catch (dbError) {\n      // Database/network failure - retryable\n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.SYSTEM_FAILURE,\n          message: \"Unable to reach authentication service\",\n          isRetryable: true,\n          context: {\n            originalError: dbError.message\n          }\n        }\n      }\n    }\n\n    // User not found or password wrong - same response (security)\n    if (!user) {\n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.INVALID_CREDENTIALS,\n          message: \"Invalid email or password\",\n          isRetryable: false,\n          context: {\n            userId: email\n          }\n        }\n      }\n    }\n\n    // Check if account is locked\n    if (user.isLocked) {\n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.ACCOUNT_LOCKED,\n          message: \"Account is locked due to too many failed login attempts\",\n          isRetryable: false,\n          context: {\n            userId: user.id,\n            lockoutDuration: user.lockoutUntil?.getTime() - Date.now()\n          }\n        }\n      }\n    }\n\n    // Verify password\n    const isPasswordValid = await bcrypt.compare(password, user.passwordHash)\n    if (!isPasswordValid) {\n      // Increment failed attempts\n      await database.incrementFailedAttempts(user.id)\n      \n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.INVALID_CREDENTIALS,\n          message: \"Invalid email or password\",\n          isRetryable: false,\n          context: {\n            userId: user.id,\n            attempts: user.failedAttempts + 1\n          }\n        }\n      }\n    }\n\n    // Reset failed attempts on successful login\n    await database.resetFailedAttempts(user.id)\n\n    return {\n      success: true,\n      value: user\n    }\n\n  } catch (unexpectedError) {\n    // Unexpected error - treat as system failure\n    return {\n      success: false,\n      error: {\n        type: LoginErrorType.SYSTEM_FAILURE,\n        message: \"An unexpected error occurred\",\n        isRetryable: true,\n        context: {\n          originalError: unexpectedError.message\n        }\n      }\n    }\n  }\n}\n```\n\n**Frontend Usage:**\n\n```typescript\n// Controller/API endpoint\nasync function handleLoginRequest(email: string, password: string) {\n  const result = await login(email, password)\n\n  if (result.success) {\n    return { status: 200, data: { token: generateToken(result.value) } }\n  }\n\n  switch (result.error.type) {\n    case LoginErrorType.INVALID_CREDENTIALS:\n      return {\n        status: 401,\n        error: {\n          code: \"INVALID_CREDENTIALS\",\n          message: \"Check your email and password\",\n          userMessage: \"The email or password you entered is incorrect\"\n        }\n      }\n\n    case LoginErrorType.ACCOUNT_LOCKED:\n      return {\n        status: 423,\n        error: {\n          code: \"ACCOUNT_LOCKED\",\n          message: \"Account temporarily locked\",\n          userMessage: `Your account has been locked. Try again in ${Math.ceil(result.error.context.lockoutDuration / 1000)} seconds`,\n          retryAfter: result.error.context.lockoutDuration\n        }\n      }\n\n    case LoginErrorType.SYSTEM_FAILURE:\n      return {\n        status: 503,\n        error: {\n          code: \"SERVICE_UNAVAILABLE\",\n          message: \"Authentication service temporarily unavailable\",\n          userMessage: \"We're experiencing technical issues. Please try again in a moment\",\n          isRetryable: true\n        }\n      }\n  }\n}\n```\n\n**Key Benefits:**\n\n1. **Callers can distinguish error categories** via the `type` field\n2. **User-actionable vs retryable** clearly marked with `isRetryable`\n3. **Rich context** allows frontend to show specific guidance\n4. **No silent failures** - structured response is always provided\n5. **Type-safe** - TypeScript prevents handling unknown error types\n\n// Test: robust_registration_design\n# User Import Processor with Error Handling\n\nHere's a processor function that distinguishes between the three failure types:\n\n```typescript\ninterface UserImport {\n  id: string;\n  email: string;\n  name: string;\n  age: number;\n}\n\ninterface ProcessResult {\n  success: number;\n  skipped: number;\n  errors: { userId: string; reason: string }[];\n}\n\nasync function processUserImports(\n  users: UserImport[],\n  dbConnection: Database\n): Promise<ProcessResult> {\n  const result: ProcessResult = {\n    success: 0,\n    skipped: 0,\n    errors: [],\n  };\n\n  for (const user of users) {\n    try {\n      // Validate data first\n      if (!validateUser(user)) {\n        result.skipped++;\n        result.errors.push({\n          userId: user.id,\n          reason: \"Invalid data: missing or malformed fields\",\n        });\n        continue; // Skip to next user\n      }\n\n      // Attempt database insert\n      await dbConnection.insertUser(user);\n      result.success++;\n    } catch (error) {\n      // Distinguish error types\n      if (isDataValidationError(error)) {\n        // Invalid data caught at DB level\n        result.skipped++;\n        result.errors.push({\n          userId: user.id,\n          reason: `Invalid data: ${error.message}`,\n        });\n      } else if (isConstraintViolationError(error)) {\n        // Constraint violation (duplicate email, etc.)\n        result.skipped++;\n        result.errors.push({\n          userId: user.id,\n          reason: `Constraint violation: ${error.message}`,\n        });\n      } else if (isConnectionError(error)) {\n        // Connection lost - stop processing and throw\n        console.error(\"Database connection lost during import\");\n        throw new Error(`Import failed: ${error.message}`);\n      } else {\n        // Unknown error - also stop processing\n        throw error;\n      }\n    }\n  }\n\n  return result;\n}\n\n// Error detection functions\nfunction validateUser(user: UserImport): boolean {\n  return (\n    user.email &&\n    /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(user.email) &&\n    user.name &&\n    user.name.trim().length > 0 &&\n    typeof user.age === \"number\" &&\n    user.age > 0 &&\n    user.age < 150\n  );\n}\n\nfunction isConstraintViolationError(error: any): boolean {\n  // Detect unique constraint, foreign key, check constraint errors\n  return (\n    error.code === \"23505\" || // PostgreSQL unique violation\n    error.code === \"23503\" || // PostgreSQL foreign key violation\n    error.code === \"23514\" || // PostgreSQL check violation\n    error.code === 1062 || // MySQL duplicate key\n    error.message.includes(\"UNIQUE constraint failed\") ||\n    error.message.includes(\"FOREIGN KEY constraint failed\") ||\n    error.message.includes(\"constraint violation\")\n  );\n}\n\nfunction isConnectionError(error: any): boolean {\n  // Detect network/connection errors\n  return (\n    error.code === \"ECONNREFUSED\" ||\n    error.code === \"ENOTFOUND\" ||\n    error.code === \"ETIMEDOUT\" ||\n    error.code === \"08006\" || // PostgreSQL connection failure\n    error.message.includes(\"connection\") ||\n    error.message.includes(\"disconnected\") ||\n    error.message.includes(\"timeout\")\n  );\n}\n\nfunction isDataValidationError(error: any): boolean {\n  // Detect type/format errors from the database\n  return (\n    error.code === \"22P02\" || // PostgreSQL invalid text representation\n    error.message.includes(\"invalid\") ||\n    error.message.includes(\"type mismatch\")\n  );\n}\n\n// Usage example\nasync function runImport() {\n  const users: UserImport[] = [\n    { id: \"1\", email: \"john@example.com\", name: \"John\", age: 30 },\n    { id: \"2\", email: \"invalid-email\", name: \"Jane\", age: 25 }, // Invalid\n    { id: \"3\", email: \"john@example.com\", name: \"John Dup\", age: 30 }, // Constraint violation\n  ];\n\n  try {\n    const result = await processUserImports(users, dbConnection);\n    console.log(\n      `Import complete: ${result.success} succeeded, ${result.skipped} skipped`\n    );\n    console.log(\"Errors:\", result.errors);\n  } catch (error) {\n    // Critical error - connection lost or unknown issue\n    console.error(\"Import process stopped:\", error.message);\n    // Alert team, retry with exponential backoff, etc.\n  }\n}\n```\n\n**Key Distinctions:**\n\n| Error Type | Detection | Action |\n|---|---|---|\n| **Invalid Data** | Validation function + DB type errors | Skip & report in errors array |\n| **Constraint Violation** | Error codes 23505/1062 or message matching | Skip & report in errors array |\n| **Connection Loss** | Error codes ECONNREFUSED/08006, timeout | **Throw error, stop processing** |\n\nThe processor validates data upfront, catches constraint errors per-user to continue batch processing, but immediately stops and throws on connection errors since retrying is futile until the connection is restored.",
          "after_code": "// Test: auth_error_handling\nI'll locate and analyze the current `login` function implementation, then provide the refactored code demonstrating explicit error handling with distinguishable failure modes.\n\nLet me search more broadly:\n\nNow I'll provide the refactored code demonstrating proper error handling with explicit error types:\n\n## Refactored Login Function with Explicit Error Handling\n\n**Data Structures (Error Types):**\n\n```typescript\n// Define specific error types as discriminated unions\ntype LoginError = \n  | { type: 'INVALID_CREDENTIALS'; reason: string }\n  | { type: 'ACCOUNT_LOCKED'; attemptCount: number; retryAfterMs: number }\n  | { type: 'SYSTEM_FAILURE'; retryable: true; originalError: Error }\n\ntype LoginResult = \n  | { success: true; value: { userId: string; token: string } }\n  | { success: false; error: LoginError }\n\n// Alternative: Using explicit Result type\ninterface Success<T> {\n  isSuccess: true\n  value: T\n}\n\ninterface Failure {\n  isSuccess: false\n  error: LoginError\n}\n\ntype Result<T> = Success<T> | Failure\n```\n\n**Refactored Login Function:**\n\n```typescript\nasync function login(email: string, password: string): Promise<LoginResult> {\n  // Input validation - fail fast on obvious issues\n  if (!email || !password) {\n    return {\n      success: false,\n      error: {\n        type: 'INVALID_CREDENTIALS',\n        reason: 'Email and password are required'\n      }\n    }\n  }\n\n  try {\n    // Attempt to fetch user from database\n    const user = await database.findUserByEmail(email)\n    \n    if (!user) {\n      return {\n        success: false,\n        error: {\n          type: 'INVALID_CREDENTIALS',\n          reason: 'User not found'\n        }\n      }\n    }\n\n    // Check account lock status\n    if (user.lockedUntil && user.lockedUntil > new Date()) {\n      return {\n        success: false,\n        error: {\n          type: 'ACCOUNT_LOCKED',\n          attemptCount: user.failedLoginAttempts,\n          retryAfterMs: user.lockedUntil.getTime() - Date.now()\n        }\n      }\n    }\n\n    // Verify password\n    const passwordValid = await bcrypt.compare(password, user.passwordHash)\n    \n    if (!passwordValid) {\n      // Increment failed attempts\n      await database.incrementFailedLogins(user.id)\n      \n      // Lock account after 5 failed attempts\n      if (user.failedLoginAttempts >= 4) {\n        await database.lockAccount(user.id, 15 * 60 * 1000) // 15 min\n      }\n\n      return {\n        success: false,\n        error: {\n          type: 'INVALID_CREDENTIALS',\n          reason: 'Invalid password'\n        }\n      }\n    }\n\n    // Successful login\n    const token = generateJWT(user.id)\n    await database.resetFailedLogins(user.id)\n\n    return {\n      success: true,\n      value: {\n        userId: user.id,\n        token: token\n      }\n    }\n\n  } catch (error) {\n    // Distinguish system failures from domain errors\n    if (error instanceof DatabaseConnectionError) {\n      return {\n        success: false,\n        error: {\n          type: 'SYSTEM_FAILURE',\n          retryable: true,\n          originalError: error\n        }\n      }\n    }\n    \n    if (error instanceof NetworkError) {\n      return {\n        success: false,\n        error: {\n          type: 'SYSTEM_FAILURE',\n          retryable: true,\n          originalError: error\n        }\n      }\n    }\n\n    // Programming errors - crash immediately\n    throw error\n  }\n}\n```\n\n**Consumer Code Using Explicit Error Handling:**\n\n```typescript\nasync function handleLoginRequest(req: Request): Promise<Response> {\n  const result = await login(req.body.email, req.body.password)\n\n  if (result.success) {\n    return res.json({\n      status: 'success',\n      token: result.value.token\n    })\n  }\n\n  // Now caller can distinguish error types and act accordingly\n  switch (result.error.type) {\n    case 'INVALID_CREDENTIALS':\n      return res.status(401).json({\n        status: 'error',\n        message: 'Invalid email or password',\n        code: 'INVALID_CREDENTIALS'\n        // User can retry immediately with correct input\n      })\n\n    case 'ACCOUNT_LOCKED':\n      return res.status(429).json({\n        status: 'error',\n        message: `Account locked. Try again in ${Math.ceil(result.error.retryAfterMs / 1000)} seconds`,\n        code: 'ACCOUNT_LOCKED',\n        retryAfterMs: result.error.retryAfterMs\n        // User knows they need to wait, can schedule retry\n      })\n\n    case 'SYSTEM_FAILURE':\n      return res.status(503).json({\n        status: 'error',\n        message: 'Service temporarily unavailable. Please try again.',\n        code: 'SYSTEM_FAILURE'\n        // Client can retry with exponential backoff\n      })\n  }\n}\n```\n\n**Key Improvements:**\n\n1. **Explicit Return Types**: Function signature documents all possible outcomes\n2. **Type-Safe Distinction**: Compiler forces handling each error type\n3. **Domain-Level Context**: Includes actionable info (retry timing, attempt count)\n4. **No Silent Failures**: `null` replaced with structured errors\n5. **Recoverable vs Non-Recoverable**: System failures marked as retryable; programming errors still crash\n6. **Clear Consumer Intent**: Frontend/API layer knows exactly how to respond to each failure mode\n\n// Test: robust_registration_design\n# User Import Processor with Categorized Error Handling\n\n```typescript\n// Define Result type for recoverable errors\ntype Result<T, E> = \n  | { ok: true; value: T }\n  | { ok: false; error: E };\n\n// Error categories - explicit types\ntype DomainError = \n  | { type: \"VALIDATION_ERROR\"; message: string; userId: string }\n  | { type: \"CONSTRAINT_ERROR\"; message: string; userId: string; constraint: string };\n\ntype InfrastructureError = \n  | { type: \"DB_CONNECTION_LOST\"; message: string };\n\n// Recoverable error (Result type)\ntype ImportResult = Result<ImportedUser, DomainError>;\n\n// Non-recoverable error (thrown)\nclass DatabaseConnectionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"DatabaseConnectionError\";\n  }\n}\n\ninterface ImportedUser {\n  id: string;\n  email: string;\n}\n\ninterface UserImportReport {\n  successful: ImportedUser[];\n  skipped: Array<{\n    data: unknown;\n    reason: DomainError;\n  }>;\n}\n\n// Validate individual user - returns Result\nfunction validateUser(data: unknown): Result<Record<string, unknown>, DomainError> {\n  const user = data as Record<string, unknown>;\n  \n  if (!user.email || typeof user.email !== \"string\") {\n    return {\n      ok: false,\n      error: {\n        type: \"VALIDATION_ERROR\",\n        message: \"Email is required and must be string\",\n        userId: user.id as string || \"unknown\"\n      }\n    };\n  }\n  \n  return { ok: true, value: user };\n}\n\n// Save to database - handles both recoverable and non-recoverable failures\nfunction saveUser(userData: Record<string, unknown>): ImportResult {\n  try {\n    // Simulated DB call\n    const result = simulateDbInsert(userData);\n    \n    return {\n      ok: true,\n      value: { id: result.id, email: userData.email as string }\n    };\n  } catch (error) {\n    // Check if connection is lost (non-recoverable)\n    if (error instanceof Error && error.message.includes(\"CONNECTION_LOST\")) {\n      // THROW - this stops processing immediately\n      throw new DatabaseConnectionError(\n        \"Database connection lost during import. Cannot continue.\"\n      );\n    }\n    \n    // Check if constraint violation (recoverable)\n    if (error instanceof Error && error.message.includes(\"UNIQUE_CONSTRAINT\")) {\n      return {\n        ok: false,\n        error: {\n          type: \"CONSTRAINT_ERROR\",\n          message: `Email already exists: ${userData.email}`,\n          userId: userData.id as string || \"unknown\",\n          constraint: \"unique_email\"\n        }\n      };\n    }\n    \n    // Unexpected error - crash on programming errors\n    throw new Error(`Unexpected database error: ${error}`);\n  }\n}\n\n// Main processor - handles Results appropriately\nfunction processBatch(imports: unknown[]): UserImportReport {\n  const report: UserImportReport = {\n    successful: [],\n    skipped: []\n  };\n  \n  for (const item of imports) {\n    // Step 1: Validate (recoverable - continue on error)\n    const validationResult = validateUser(item);\n    if (!validationResult.ok) {\n      report.skipped.push({\n        data: item,\n        reason: validationResult.error\n      });\n      continue;\n    }\n    \n    // Step 2: Save to database (non-recoverable exception OR recoverable domain error)\n    const saveResult = saveUser(validationResult.value);\n    if (!saveResult.ok) {\n      // Domain error - recoverable, skip and report\n      report.skipped.push({\n        data: item,\n        reason: saveResult.error\n      });\n      continue;\n    }\n    \n    // Step 3: Success path\n    report.successful.push(saveResult.value);\n  }\n  \n  return report;\n}\n\n// Usage with error handling at boundary\nfunction importUsers(data: unknown[]): void {\n  try {\n    const report = processBatch(data);\n    \n    console.log(`Imported: ${report.successful.length}`);\n    report.skipped.forEach(skip => {\n      console.log(`Skipped - ${skip.reason.type}: ${skip.reason.message}`);\n    });\n  } catch (error) {\n    // Only non-recoverable errors reach here\n    if (error instanceof DatabaseConnectionError) {\n      console.error(\"CRITICAL: Database connection lost. Import halted.\");\n      alert(\"Import failed: Database unavailable. Please retry later.\");\n      process.exit(1);\n    }\n    throw error;\n  }\n}\n\n// Simulate DB operation\nfunction simulateDbInsert(data: Record<string, unknown>): { id: string } {\n  // Simulated scenarios:\n  // if (Math.random() > 0.9) throw new Error(\"CONNECTION_LOST\");\n  // if (data.email === \"existing@test.com\") throw new Error(\"UNIQUE_CONSTRAINT\");\n  return { id: Math.random().toString() };\n}\n```\n\n**Key distinctions:**\n\n| Error Type | Handling | Recovery |\n|------------|----------|----------|\n| **Validation Error** | Return `Result` | Skip item, report, continue |\n| **Constraint Violation** | Return `Result` | Skip item, report, continue |\n| **Connection Loss** | **Throw Exception** | Stop immediately, fail-fast |\n\n**Why this approach:**\n- \u2705 Validation/constraint errors are **explicit in return types** - callers must handle\n- \u2705 Connection loss **crashes immediately** - prevents corrupting batch state\n- \u2705 Error categories are **distinct types** - impossible to confuse them\n- \u2705 Report includes **actionable context** (which user, which constraint, why)\n- \u2705 Error handling is **at appropriate boundaries** (infrastructure errors at entry point)",
          "judgment": {
            "principle_better": "A",
            "quality_better": "A",
            "overall_better": "A",
            "option_a_rating": "outstanding",
            "option_b_rating": "good",
            "score": 100,
            "reasoning": "Solution A consistently returns Result types for all expected failures (domain, system, infrastructure), forcing callers to handle errors explicitly via pattern matching. Solution B still throws exceptions for infrastructure errors (DatabaseConnectionError, NetworkError), partially reverting to implicit error handling that violates the principle. Solution A's comprehensive approach\u2014converting all errors to domain Results, providing rich context (isRetryable, attempts, lockoutDuration), and showing clear consumer handling\u2014demonstrates superior adherence to explicit error design, while also being more maintainable and testable."
          },
          "judge_error": false,
          "tests": [
            {
              "name": "auth_error_handling",
              "input": "The current `login` function returns `null` if anything goes wrong (user missing, wrong password, db down). This leads to a generic \"Login Failed\" error on the frontend, which frustrates users who might just have a typo, and confuses support teams when the DB is actually down.\n\nRefactor the return values/mechanism so the caller can definitively distinguish between:\n1. Invalid Credentials (user actionable)\n2. Account Locked (user actionable)\n3. System/Network Failure (retryable)\n\nProvide the code for the logic and the data structures used.",
              "expected": {
                "focus": "Does the solution return structured error info (e.g., error codes, types) instead of a generic null/false?"
              },
              "baseline_response": "Let me search for the login function:\n\nLet me search more specifically for login-related code:\n\nLet me check the actual skill content:\n\nNow let me check the test.json to see what the actual problem case is:\n\nPerfect. Now I have the full context. The user is asking for a refactored login function that returns structured error information instead of null. Let me provide the code solution directly.\n\n## Solution: Refactored Login Function with Structured Error Handling\n\n**Data Structures:**\n\n```typescript\n// Error type enum for categorization\nenum LoginErrorType {\n  INVALID_CREDENTIALS = \"INVALID_CREDENTIALS\",\n  ACCOUNT_LOCKED = \"ACCOUNT_LOCKED\",\n  SYSTEM_FAILURE = \"SYSTEM_FAILURE\"\n}\n\n// Result type - Either Success or Failure\ntype LoginResult = \n  | { success: true; value: User }\n  | { success: false; error: LoginError }\n\n// Detailed error structure\ninterface LoginError {\n  type: LoginErrorType\n  message: string\n  isRetryable: boolean\n  context?: {\n    userId?: string\n    attempts?: number\n    lockoutDuration?: number\n    originalError?: string\n  }\n}\n\n// User type\ninterface User {\n  id: string\n  email: string\n  // ... other user fields\n}\n```\n\n**Refactored Login Logic:**\n\n```typescript\nasync function login(email: string, password: string): Promise<LoginResult> {\n  try {\n    // Attempt to fetch user from database\n    let user: User | null\n    try {\n      user = await database.findByEmail(email)\n    } catch (dbError) {\n      // Database/network failure - retryable\n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.SYSTEM_FAILURE,\n          message: \"Unable to reach authentication service\",\n          isRetryable: true,\n          context: {\n            originalError: dbError.message\n          }\n        }\n      }\n    }\n\n    // User not found or password wrong - same response (security)\n    if (!user) {\n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.INVALID_CREDENTIALS,\n          message: \"Invalid email or password\",\n          isRetryable: false,\n          context: {\n            userId: email\n          }\n        }\n      }\n    }\n\n    // Check if account is locked\n    if (user.isLocked) {\n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.ACCOUNT_LOCKED,\n          message: \"Account is locked due to too many failed login attempts\",\n          isRetryable: false,\n          context: {\n            userId: user.id,\n            lockoutDuration: user.lockoutUntil?.getTime() - Date.now()\n          }\n        }\n      }\n    }\n\n    // Verify password\n    const isPasswordValid = await bcrypt.compare(password, user.passwordHash)\n    if (!isPasswordValid) {\n      // Increment failed attempts\n      await database.incrementFailedAttempts(user.id)\n      \n      return {\n        success: false,\n        error: {\n          type: LoginErrorType.INVALID_CREDENTIALS,\n          message: \"Invalid email or password\",\n          isRetryable: false,\n          context: {\n            userId: user.id,\n            attempts: user.failedAttempts + 1\n          }\n        }\n      }\n    }\n\n    // Reset failed attempts on successful login\n    await database.resetFailedAttempts(user.id)\n\n    return {\n      success: true,\n      value: user\n    }\n\n  } catch (unexpectedError) {\n    // Unexpected error - treat as system failure\n    return {\n      success: false,\n      error: {\n        type: LoginErrorType.SYSTEM_FAILURE,\n        message: \"An unexpected error occurred\",\n        isRetryable: true,\n        context: {\n          originalError: unexpectedError.message\n        }\n      }\n    }\n  }\n}\n```\n\n**Frontend Usage:**\n\n```typescript\n// Controller/API endpoint\nasync function handleLoginRequest(email: string, password: string) {\n  const result = await login(email, password)\n\n  if (result.success) {\n    return { status: 200, data: { token: generateToken(result.value) } }\n  }\n\n  switch (result.error.type) {\n    case LoginErrorType.INVALID_CREDENTIALS:\n      return {\n        status: 401,\n        error: {\n          code: \"INVALID_CREDENTIALS\",\n          message: \"Check your email and password\",\n          userMessage: \"The email or password you entered is incorrect\"\n        }\n      }\n\n    case LoginErrorType.ACCOUNT_LOCKED:\n      return {\n        status: 423,\n        error: {\n          code: \"ACCOUNT_LOCKED\",\n          message: \"Account temporarily locked\",\n          userMessage: `Your account has been locked. Try again in ${Math.ceil(result.error.context.lockoutDuration / 1000)} seconds`,\n          retryAfter: result.error.context.lockoutDuration\n        }\n      }\n\n    case LoginErrorType.SYSTEM_FAILURE:\n      return {\n        status: 503,\n        error: {\n          code: \"SERVICE_UNAVAILABLE\",\n          message: \"Authentication service temporarily unavailable\",\n          userMessage: \"We're experiencing technical issues. Please try again in a moment\",\n          isRetryable: true\n        }\n      }\n  }\n}\n```\n\n**Key Benefits:**\n\n1. **Callers can distinguish error categories** via the `type` field\n2. **User-actionable vs retryable** clearly marked with `isRetryable`\n3. **Rich context** allows frontend to show specific guidance\n4. **No silent failures** - structured response is always provided\n5. **Type-safe** - TypeScript prevents handling unknown error types",
              "skill_response": "I'll locate and analyze the current `login` function implementation, then provide the refactored code demonstrating explicit error handling with distinguishable failure modes.\n\nLet me search more broadly:\n\nNow I'll provide the refactored code demonstrating proper error handling with explicit error types:\n\n## Refactored Login Function with Explicit Error Handling\n\n**Data Structures (Error Types):**\n\n```typescript\n// Define specific error types as discriminated unions\ntype LoginError = \n  | { type: 'INVALID_CREDENTIALS'; reason: string }\n  | { type: 'ACCOUNT_LOCKED'; attemptCount: number; retryAfterMs: number }\n  | { type: 'SYSTEM_FAILURE'; retryable: true; originalError: Error }\n\ntype LoginResult = \n  | { success: true; value: { userId: string; token: string } }\n  | { success: false; error: LoginError }\n\n// Alternative: Using explicit Result type\ninterface Success<T> {\n  isSuccess: true\n  value: T\n}\n\ninterface Failure {\n  isSuccess: false\n  error: LoginError\n}\n\ntype Result<T> = Success<T> | Failure\n```\n\n**Refactored Login Function:**\n\n```typescript\nasync function login(email: string, password: string): Promise<LoginResult> {\n  // Input validation - fail fast on obvious issues\n  if (!email || !password) {\n    return {\n      success: false,\n      error: {\n        type: 'INVALID_CREDENTIALS',\n        reason: 'Email and password are required'\n      }\n    }\n  }\n\n  try {\n    // Attempt to fetch user from database\n    const user = await database.findUserByEmail(email)\n    \n    if (!user) {\n      return {\n        success: false,\n        error: {\n          type: 'INVALID_CREDENTIALS',\n          reason: 'User not found'\n        }\n      }\n    }\n\n    // Check account lock status\n    if (user.lockedUntil && user.lockedUntil > new Date()) {\n      return {\n        success: false,\n        error: {\n          type: 'ACCOUNT_LOCKED',\n          attemptCount: user.failedLoginAttempts,\n          retryAfterMs: user.lockedUntil.getTime() - Date.now()\n        }\n      }\n    }\n\n    // Verify password\n    const passwordValid = await bcrypt.compare(password, user.passwordHash)\n    \n    if (!passwordValid) {\n      // Increment failed attempts\n      await database.incrementFailedLogins(user.id)\n      \n      // Lock account after 5 failed attempts\n      if (user.failedLoginAttempts >= 4) {\n        await database.lockAccount(user.id, 15 * 60 * 1000) // 15 min\n      }\n\n      return {\n        success: false,\n        error: {\n          type: 'INVALID_CREDENTIALS',\n          reason: 'Invalid password'\n        }\n      }\n    }\n\n    // Successful login\n    const token = generateJWT(user.id)\n    await database.resetFailedLogins(user.id)\n\n    return {\n      success: true,\n      value: {\n        userId: user.id,\n        token: token\n      }\n    }\n\n  } catch (error) {\n    // Distinguish system failures from domain errors\n    if (error instanceof DatabaseConnectionError) {\n      return {\n        success: false,\n        error: {\n          type: 'SYSTEM_FAILURE',\n          retryable: true,\n          originalError: error\n        }\n      }\n    }\n    \n    if (error instanceof NetworkError) {\n      return {\n        success: false,\n        error: {\n          type: 'SYSTEM_FAILURE',\n          retryable: true,\n          originalError: error\n        }\n      }\n    }\n\n    // Programming errors - crash immediately\n    throw error\n  }\n}\n```\n\n**Consumer Code Using Explicit Error Handling:**\n\n```typescript\nasync function handleLoginRequest(req: Request): Promise<Response> {\n  const result = await login(req.body.email, req.body.password)\n\n  if (result.success) {\n    return res.json({\n      status: 'success',\n      token: result.value.token\n    })\n  }\n\n  // Now caller can distinguish error types and act accordingly\n  switch (result.error.type) {\n    case 'INVALID_CREDENTIALS':\n      return res.status(401).json({\n        status: 'error',\n        message: 'Invalid email or password',\n        code: 'INVALID_CREDENTIALS'\n        // User can retry immediately with correct input\n      })\n\n    case 'ACCOUNT_LOCKED':\n      return res.status(429).json({\n        status: 'error',\n        message: `Account locked. Try again in ${Math.ceil(result.error.retryAfterMs / 1000)} seconds`,\n        code: 'ACCOUNT_LOCKED',\n        retryAfterMs: result.error.retryAfterMs\n        // User knows they need to wait, can schedule retry\n      })\n\n    case 'SYSTEM_FAILURE':\n      return res.status(503).json({\n        status: 'error',\n        message: 'Service temporarily unavailable. Please try again.',\n        code: 'SYSTEM_FAILURE'\n        // Client can retry with exponential backoff\n      })\n  }\n}\n```\n\n**Key Improvements:**\n\n1. **Explicit Return Types**: Function signature documents all possible outcomes\n2. **Type-Safe Distinction**: Compiler forces handling each error type\n3. **Domain-Level Context**: Includes actionable info (retry timing, attempt count)\n4. **No Silent Failures**: `null` replaced with structured errors\n5. **Recoverable vs Non-Recoverable**: System failures marked as retryable; programming errors still crash\n6. **Clear Consumer Intent**: Frontend/API layer knows exactly how to respond to each failure mode"
            },
            {
              "name": "robust_registration_design",
              "input": "We need to process a batch of user imports. Some might have invalid data, others might fail due to database constraint violations.\n\nwrite a processor function that handles these failures appropriately:\n- Invalid data: Skip and report.\n- DB Constraint: Skip and report.\n- DB Connection Loss: Stop processing and throw/alert.\n\nShow how you distinguish these cases in code.",
              "expected": {
                "focus": "Does the code differentiate between recoverable item-level errors and fatal batch-level errors?"
              },
              "baseline_response": "# User Import Processor with Error Handling\n\nHere's a processor function that distinguishes between the three failure types:\n\n```typescript\ninterface UserImport {\n  id: string;\n  email: string;\n  name: string;\n  age: number;\n}\n\ninterface ProcessResult {\n  success: number;\n  skipped: number;\n  errors: { userId: string; reason: string }[];\n}\n\nasync function processUserImports(\n  users: UserImport[],\n  dbConnection: Database\n): Promise<ProcessResult> {\n  const result: ProcessResult = {\n    success: 0,\n    skipped: 0,\n    errors: [],\n  };\n\n  for (const user of users) {\n    try {\n      // Validate data first\n      if (!validateUser(user)) {\n        result.skipped++;\n        result.errors.push({\n          userId: user.id,\n          reason: \"Invalid data: missing or malformed fields\",\n        });\n        continue; // Skip to next user\n      }\n\n      // Attempt database insert\n      await dbConnection.insertUser(user);\n      result.success++;\n    } catch (error) {\n      // Distinguish error types\n      if (isDataValidationError(error)) {\n        // Invalid data caught at DB level\n        result.skipped++;\n        result.errors.push({\n          userId: user.id,\n          reason: `Invalid data: ${error.message}`,\n        });\n      } else if (isConstraintViolationError(error)) {\n        // Constraint violation (duplicate email, etc.)\n        result.skipped++;\n        result.errors.push({\n          userId: user.id,\n          reason: `Constraint violation: ${error.message}`,\n        });\n      } else if (isConnectionError(error)) {\n        // Connection lost - stop processing and throw\n        console.error(\"Database connection lost during import\");\n        throw new Error(`Import failed: ${error.message}`);\n      } else {\n        // Unknown error - also stop processing\n        throw error;\n      }\n    }\n  }\n\n  return result;\n}\n\n// Error detection functions\nfunction validateUser(user: UserImport): boolean {\n  return (\n    user.email &&\n    /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(user.email) &&\n    user.name &&\n    user.name.trim().length > 0 &&\n    typeof user.age === \"number\" &&\n    user.age > 0 &&\n    user.age < 150\n  );\n}\n\nfunction isConstraintViolationError(error: any): boolean {\n  // Detect unique constraint, foreign key, check constraint errors\n  return (\n    error.code === \"23505\" || // PostgreSQL unique violation\n    error.code === \"23503\" || // PostgreSQL foreign key violation\n    error.code === \"23514\" || // PostgreSQL check violation\n    error.code === 1062 || // MySQL duplicate key\n    error.message.includes(\"UNIQUE constraint failed\") ||\n    error.message.includes(\"FOREIGN KEY constraint failed\") ||\n    error.message.includes(\"constraint violation\")\n  );\n}\n\nfunction isConnectionError(error: any): boolean {\n  // Detect network/connection errors\n  return (\n    error.code === \"ECONNREFUSED\" ||\n    error.code === \"ENOTFOUND\" ||\n    error.code === \"ETIMEDOUT\" ||\n    error.code === \"08006\" || // PostgreSQL connection failure\n    error.message.includes(\"connection\") ||\n    error.message.includes(\"disconnected\") ||\n    error.message.includes(\"timeout\")\n  );\n}\n\nfunction isDataValidationError(error: any): boolean {\n  // Detect type/format errors from the database\n  return (\n    error.code === \"22P02\" || // PostgreSQL invalid text representation\n    error.message.includes(\"invalid\") ||\n    error.message.includes(\"type mismatch\")\n  );\n}\n\n// Usage example\nasync function runImport() {\n  const users: UserImport[] = [\n    { id: \"1\", email: \"john@example.com\", name: \"John\", age: 30 },\n    { id: \"2\", email: \"invalid-email\", name: \"Jane\", age: 25 }, // Invalid\n    { id: \"3\", email: \"john@example.com\", name: \"John Dup\", age: 30 }, // Constraint violation\n  ];\n\n  try {\n    const result = await processUserImports(users, dbConnection);\n    console.log(\n      `Import complete: ${result.success} succeeded, ${result.skipped} skipped`\n    );\n    console.log(\"Errors:\", result.errors);\n  } catch (error) {\n    // Critical error - connection lost or unknown issue\n    console.error(\"Import process stopped:\", error.message);\n    // Alert team, retry with exponential backoff, etc.\n  }\n}\n```\n\n**Key Distinctions:**\n\n| Error Type | Detection | Action |\n|---|---|---|\n| **Invalid Data** | Validation function + DB type errors | Skip & report in errors array |\n| **Constraint Violation** | Error codes 23505/1062 or message matching | Skip & report in errors array |\n| **Connection Loss** | Error codes ECONNREFUSED/08006, timeout | **Throw error, stop processing** |\n\nThe processor validates data upfront, catches constraint errors per-user to continue batch processing, but immediately stops and throws on connection errors since retrying is futile until the connection is restored.",
              "skill_response": "# User Import Processor with Categorized Error Handling\n\n```typescript\n// Define Result type for recoverable errors\ntype Result<T, E> = \n  | { ok: true; value: T }\n  | { ok: false; error: E };\n\n// Error categories - explicit types\ntype DomainError = \n  | { type: \"VALIDATION_ERROR\"; message: string; userId: string }\n  | { type: \"CONSTRAINT_ERROR\"; message: string; userId: string; constraint: string };\n\ntype InfrastructureError = \n  | { type: \"DB_CONNECTION_LOST\"; message: string };\n\n// Recoverable error (Result type)\ntype ImportResult = Result<ImportedUser, DomainError>;\n\n// Non-recoverable error (thrown)\nclass DatabaseConnectionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"DatabaseConnectionError\";\n  }\n}\n\ninterface ImportedUser {\n  id: string;\n  email: string;\n}\n\ninterface UserImportReport {\n  successful: ImportedUser[];\n  skipped: Array<{\n    data: unknown;\n    reason: DomainError;\n  }>;\n}\n\n// Validate individual user - returns Result\nfunction validateUser(data: unknown): Result<Record<string, unknown>, DomainError> {\n  const user = data as Record<string, unknown>;\n  \n  if (!user.email || typeof user.email !== \"string\") {\n    return {\n      ok: false,\n      error: {\n        type: \"VALIDATION_ERROR\",\n        message: \"Email is required and must be string\",\n        userId: user.id as string || \"unknown\"\n      }\n    };\n  }\n  \n  return { ok: true, value: user };\n}\n\n// Save to database - handles both recoverable and non-recoverable failures\nfunction saveUser(userData: Record<string, unknown>): ImportResult {\n  try {\n    // Simulated DB call\n    const result = simulateDbInsert(userData);\n    \n    return {\n      ok: true,\n      value: { id: result.id, email: userData.email as string }\n    };\n  } catch (error) {\n    // Check if connection is lost (non-recoverable)\n    if (error instanceof Error && error.message.includes(\"CONNECTION_LOST\")) {\n      // THROW - this stops processing immediately\n      throw new DatabaseConnectionError(\n        \"Database connection lost during import. Cannot continue.\"\n      );\n    }\n    \n    // Check if constraint violation (recoverable)\n    if (error instanceof Error && error.message.includes(\"UNIQUE_CONSTRAINT\")) {\n      return {\n        ok: false,\n        error: {\n          type: \"CONSTRAINT_ERROR\",\n          message: `Email already exists: ${userData.email}`,\n          userId: userData.id as string || \"unknown\",\n          constraint: \"unique_email\"\n        }\n      };\n    }\n    \n    // Unexpected error - crash on programming errors\n    throw new Error(`Unexpected database error: ${error}`);\n  }\n}\n\n// Main processor - handles Results appropriately\nfunction processBatch(imports: unknown[]): UserImportReport {\n  const report: UserImportReport = {\n    successful: [],\n    skipped: []\n  };\n  \n  for (const item of imports) {\n    // Step 1: Validate (recoverable - continue on error)\n    const validationResult = validateUser(item);\n    if (!validationResult.ok) {\n      report.skipped.push({\n        data: item,\n        reason: validationResult.error\n      });\n      continue;\n    }\n    \n    // Step 2: Save to database (non-recoverable exception OR recoverable domain error)\n    const saveResult = saveUser(validationResult.value);\n    if (!saveResult.ok) {\n      // Domain error - recoverable, skip and report\n      report.skipped.push({\n        data: item,\n        reason: saveResult.error\n      });\n      continue;\n    }\n    \n    // Step 3: Success path\n    report.successful.push(saveResult.value);\n  }\n  \n  return report;\n}\n\n// Usage with error handling at boundary\nfunction importUsers(data: unknown[]): void {\n  try {\n    const report = processBatch(data);\n    \n    console.log(`Imported: ${report.successful.length}`);\n    report.skipped.forEach(skip => {\n      console.log(`Skipped - ${skip.reason.type}: ${skip.reason.message}`);\n    });\n  } catch (error) {\n    // Only non-recoverable errors reach here\n    if (error instanceof DatabaseConnectionError) {\n      console.error(\"CRITICAL: Database connection lost. Import halted.\");\n      alert(\"Import failed: Database unavailable. Please retry later.\");\n      process.exit(1);\n    }\n    throw error;\n  }\n}\n\n// Simulate DB operation\nfunction simulateDbInsert(data: Record<string, unknown>): { id: string } {\n  // Simulated scenarios:\n  // if (Math.random() > 0.9) throw new Error(\"CONNECTION_LOST\");\n  // if (data.email === \"existing@test.com\") throw new Error(\"UNIQUE_CONSTRAINT\");\n  return { id: Math.random().toString() };\n}\n```\n\n**Key distinctions:**\n\n| Error Type | Handling | Recovery |\n|------------|----------|----------|\n| **Validation Error** | Return `Result` | Skip item, report, continue |\n| **Constraint Violation** | Return `Result` | Skip item, report, continue |\n| **Connection Loss** | **Throw Exception** | Stop immediately, fail-fast |\n\n**Why this approach:**\n- \u2705 Validation/constraint errors are **explicit in return types** - callers must handle\n- \u2705 Connection loss **crashes immediately** - prevents corrupting batch state\n- \u2705 Error categories are **distinct types** - impossible to confuse them\n- \u2705 Report includes **actionable context** (which user, which constraint, why)\n- \u2705 Error handling is **at appropriate boundaries** (infrastructure errors at entry point)"
            }
          ]
        }
      ]
    }
  ],
  "summary": {
    "total_benchmarks": 1,
    "leaderboard": [
      {
        "model": "claude-haiku-4.5",
        "provider": "copilot",
        "total_tested": 1,
        "improvements": 0,
        "improvement_rate": 0.0
      }
    ]
  },
  "unique_skills": [
    "ps-error-handling-design"
  ],
  "provider_models": [
    [
      "copilot",
      "claude-haiku-4.5"
    ]
  ]
}