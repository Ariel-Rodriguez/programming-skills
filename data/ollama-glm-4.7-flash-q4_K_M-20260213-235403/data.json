{
  "benchmarks": [
    {
      "benchmark_id": "ollama-glm-4.7-flash-q4_K_M-20260213-235403",
      "timestamp": "2026-02-13T23:54:03",
      "provider": "ollama",
      "model": "glm-4.7-flash:q4_K_M",
      "skills": [
        {
          "skill_name": "ps-architecture-core",
          "skill_version": "1.0.0",
          "provider": "ollama",
          "model": "glm-4.7-flash:q4_K_M",
          "timestamp": "2026-02-13T23:54:03",
          "baseline_rating": "good",
          "skill_rating": "outstanding",
          "improvement": "yes",
          "reasoning": "Baseline rated: good | With Skill rated: outstanding\n\nSolution B strictly adheres to a modular architecture (Ports and Adapters), utilizing a finite state machine and explicit error handling to ensure reliability and testability. Solution A, while functional, is a monolithic script that mixes concerns and relies on manual state checks, whereas Solution B encapsulates logic in pure domains and separates orchestration from effects.",
          "before_code": "// Test: mini_app_full_stack_architecture_challenge\nHere is a complete backend solution for the Team Task Tracker, designed with reliability and clear separation of concerns in mind.\n\n### 1. API Contract\n\nThis defines the HTTP interface for the system.\n\n**Base URL:** `/api/v1/tasks`\n\n| Method | Endpoint | Description | Request Body | Success Response | Error Response |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| **POST** | `/` | Create a new task | `title`, `description`, `priority`, `assigneeEmail`, `dueDate` (optional) | `201 Created` (Task ID) | `400 Bad Request` |\n| **GET** | `/` | List tasks with filters | `status`, `assignee`, `priority`, `overdue` | `200 OK` (Array of Tasks) | `400 Bad Request` |\n| **PATCH** | `/{id}/activate` | Activate (Draft -> Active) | None | `200 OK` (Task) | `400 Bad Request` (Invalid State) |\n| **PATCH** | `/{id}/block` | Block (Active -> Blocked) | `reason` (required) | `200 OK` (Task) | `400 Bad Request` (Missing Reason) |\n| **PATCH** | `/{id}/complete` | Complete (Active -> Done) | `checklist_item_id` (required) | `200 OK` (Task) | `400 Bad Request` (No items or invalid ID) |\n| **PATCH** | `/{id}/archive` | Archive (Done -> Archived) | None | `200 OK` (Task) | `400 Bad Request` (Invalid State) |\n\n---\n\n### 2. Implementation Code (Python)\n\nWe will implement this using a Service layer pattern. This allows the database and notification logic to be swapped out without changing the API controllers.\n\n```python\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nfrom typing import List, Optional, Dict, Any\nimport uuid\nimport logging\n\n# --- Configuration & Enums ---\n\nclass Priority(Enum):\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n\nclass Status(Enum):\n    DRAFT = \"draft\"\n    ACTIVE = \"active\"\n    BLOCKED = \"blocked\"\n    DONE = \"done\"\n    ARCHIVED = \"archived\"\n\n@dataclass\nclass ChecklistItem:\n    id: str\n    text: str\n    completed: bool = False\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    priority: Priority\n    assignee_email: str\n    created_at: datetime\n    due_date: Optional[datetime] = None\n    status: Status = Status.DRAFT\n    checklist: List[ChecklistItem] = field(default_factory=list)\n    version: int = 1  # For optimistic locking\n    \n    # Notification status flag\n    notified: bool = False\n\n    def is_overdue(self) -> bool:\n        \"\"\"Calculates if task is overdue based on priority.\"\"\"\n        if not self.due_date:\n            return False\n        \n        now = datetime.utcnow()\n        diff = now - self.due_date\n        \n        # High priority: > 24h\n        # Medium/Low: > 72h\n        threshold = timedelta(hours=24) if self.priority == Priority.HIGH else timedelta(hours=72)\n        return diff >= threshold\n\n# --- Domain Logic ---\n\nclass TaskStateError(Exception):\n    \"\"\"Raised when an invalid state transition is attempted.\"\"\"\n    pass\n\nclass NotificationError(Exception):\n    \"\"\"Raised when notification delivery fails.\"\"\"\n    pass\n\n# --- Infrastructure Interfaces ---\n\nclass NotificationService:\n    def send(self, task_id: str, event: str, assignee: str):\n        \"\"\"Simulates sending a notification.\"\"\"\n        # In a real app, this would call SMTP/SMS/Slack APIs\n        print(f\"[Notification Service] Sending '{event}' for Task {task_id} to {assignee}\")\n        # Random failure simulation\n        if event == \"blocked\" and task_id == \"fail_test\":\n            raise NotificationError(\"Simulated SMTP failure\")\n\nclass TaskRepository:\n    def save(self, task: Task) -> Task:\n        # In a real app, this is a DB transaction (INSERT/UPDATE)\n        return task\n\n    def find_all(self, filters: Dict[str, Any]) -> List[Task]:\n        # In a real app, this is a SQL SELECT with WHERE clauses\n        return []\n\n# --- Core Business Logic ---\n\nclass TaskService:\n    def __init__(self, repo: TaskRepository, notification_service: NotificationService):\n        self.repo = repo\n        self.notification_service = notification_service\n\n    def create_task(self, title: str, description: str, priority: str, assignee_email: str, due_date: Optional[datetime]) -> Task:\n        task = Task(\n            id=str(uuid.uuid4()),\n            title=title,\n            description=description,\n            priority=Priority[priority.upper()],\n            assignee_email=assignee_email,\n            created_at=datetime.utcnow(),\n            due_date=due_date,\n            checklist=[ChecklistItem(id=\"1\", text=\"Initial task setup\", completed=False)]\n        )\n        return self.repo.save(task)\n\n    def update_task_status(self, task_id: str, status: str, payload: Optional[Dict] = None):\n        # 1. Retrieve (Optimistic Locking)\n        task = self.repo.find_all({\"id\": task_id})[0]\n        \n        if task.version != 1:\n             # Simplified version check for demo. Real impl checks if requested version == current\n             pass \n\n        new_status = Status(status)\n        \n        # 2. Validate State Transition\n        self._validate_transition(task.status, new_status, payload)\n\n        # 3. Execute Transition\n        old_status = task.status\n        task.status = new_status\n        \n        # 4. Handle Post-Transition Logic\n        self._handle_post_transition_logic(task, new_status, payload)\n\n        # 5. Notify (Non-blocking)\n        self._try_notify(task, old_status, new_status)\n\n        # 6. Persist\n        return self.repo.save(task)\n\n    def _validate_transition(self, current_status: Status, target_status: Status, payload: Optional[Dict]):\n        # Define valid lifecycle graph\n        valid_transitions = {\n            Status.DRAFT: {Status.ACTIVE},\n            Status.ACTIVE: {Status.BLOCKED, Status.DONE},\n            Status.BLOCKED: {Status.ACTIVE},\n            Status.DONE: {Status.ARCHIVED},\n        }\n        \n        if target_status not in valid_transitions.get(current_status, set()):\n            raise TaskStateError(f\"Cannot move from {current_status} to {target_status}\")\n\n        # Specific checks per transition\n        if target_status == Status.BLOCKED and not payload.get(\"reason\"):\n            raise TaskStateError(\"Blocking requires a 'reason' field.\")\n            \n        if target_status == Status.DONE:\n            if not task.checklist:\n                raise TaskStateError(\"Cannot mark done without a checklist.\")\n            \n            # Check if the provided item exists and is completed\n            item_id = payload.get(\"checklist_item_id\")\n            item = next((i for i in task.checklist if i.id == item_id), None)\n            if not item or not item.completed:\n                raise TaskStateError(\"Task requires at least one completed checklist item.\")\n\n    def _handle_post_transition_logic(self, task: Task, new_status: Status, payload: Optional[Dict]):\n        if new_status == Status.DONE:\n            # Ensure only one item is checked off if that's a business rule\n            pass\n\n    def _try_notify(self, task: Task, old_status: Status, new_status: Status):\n        event_name = f\"task_{new_status.value}\"\n        \n        try:\n            self.notification_service.send(task.id, event_name, task.assignee_email)\n            task.notified = True\n        except NotificationError as e:\n            # Requirement: \"If notification delivery fails, core task operation result must still be explicit\"\n            logging.error(f\"Notification failed for {task.id}: {e}. Task state remains valid.\")\n\n    def get_tasks(self, filters: Dict[str, Any]) -> List[Task]:\n        all_tasks = self.repo.find_all(filters)\n        \n        # Apply In-Memory Filtering logic (SQL would do this in DB)\n        if filters.get(\"overdue\") == \"true\":\n            all_tasks = [t for t in all_tasks if t.is_overdue()]\n        \n        # Simple filter map\n        if \"status\" in filters:\n            all_tasks = [t for t in all_tasks if t.status == Status[filters[\"status\"].upper()]]\n        \n        return all_tasks\n\n# --- Mock Repositories for Demo ---\n\nclass InMemoryTaskRepository(TaskRepository):\n    def __init__(self):\n        self.tasks: Dict[str, Task] = {}\n\n    def save(self, task: Task) -> Task:\n        self.tasks[task.id] = task\n        return task\n\n    def find_all(self, filters: Dict[str, Any]) -> List[Task]:\n        results = list(self.tasks.values())\n        \n        # Apply simple filters\n        if \"status\" in filters:\n            status = filters[\"status\"].upper()\n            results = [t for t in results if t.status.value == status]\n        \n        if \"assignee\" in filters:\n            results = [t for t in results if t.assignee_email == filters[\"assignee\"]]\n            \n        return results\n\n# --- Demo / Usage ---\n\ndef run_demo():\n    repo = InMemoryTaskRepository()\n    notification_svc = NotificationService()\n    service = TaskService(repo, notification_svc)\n\n    # 1. Create Task\n    print(\"--- Creating Task ---\")\n    t1 = service.create_task(\n        title=\"Fix Login Bug\", \n        description=\"User cannot login with OAuth\", \n        priority=\"high\", \n        assignee_email=\"dev@team.com\", \n        due_date=datetime.utcnow() + timedelta(hours=-12) # Already overdue\n    )\n    print(f\"Created: {t1.id} | Status: {t1.status}\")\n\n    # 2. Activate Task\n    print(\"\\n--- Activating Task ---\")\n    t1 = service.update_task_status(t1.id, \"active\")\n    print(f\"Status: {t1.status}\")\n\n    # 3. Block Task\n    print(\"\\n--- Blocking Task ---\")\n    try:\n        # Test failure scenario\n        # service.update_task_status(\"fail_test\", \"blocked\", {\"reason\": \"API Down\"}) \n        t1 = service.update_task_status(t1.id, \"blocked\", {\"reason\": \"Database connection timeout\"})\n        print(f\"Status: {t1.status} | Notified: {t1.notified}\")\n    except TaskStateError as e:\n        print(f\"Error: {e}\")\n\n    # 4. Mark Complete\n    print(\"\\n--- Completing Task ---\")\n    # Mark the first checklist item as completed first\n    t1.checklist[0].completed = True\n    \n    # Attempt complete without item (should fail)\n    try:\n        service.update_task_status(t1.id, \"done\", {})\n    except TaskStateError as e:\n        print(f\"Failed (expected): {e}\")\n\n    # Attempt complete with valid item\n    try:\n        t1 = service.update_task_status(t1.id, \"done\", {\"checklist_item_id\": \"1\"})\n        print(f\"Status: {t1.status}\")\n    except TaskStateError as e:\n        print(f\"Error: {e}\")\n\n    # 5. List Overdue\n    print(\"\\n--- Filtering Overdue ---\")\n    print(f\"Found {len(service.get_tasks({'overdue': 'true', 'status': 'active'}))} overdue tasks.\")\n    \n    # 6. Archive\n    print(\"\\n--- Archiving ---\")\n    t1 = service.update_task_status(t1.id, \"archived\")\n    print(f\"Status: {t1.status}\")\n\nif __name__ == \"__main__\":\n    run_demo()\n```\n\n---\n\n### 3. Test Cases\n\nHere are the specific test cases designed to verify the requirements.\n\n#### Test Case 1: Overdue Logic\n**Test:** Verify that High priority tasks trigger overdue status faster than Medium/Low tasks.\n\n```python\nimport pytest\nfrom datetime import datetime, timedelta\n\ndef test_overdue_calculation():\n    service = TaskService(repo, notification_svc)\n    \n    # Scenario A: High Priority, Due in 25 hours -> Should be Overdue\n    now = datetime.utcnow()\n    high_task = Task(\n        id=\"h1\", title=\"High Urgency\", priority=Priority.HIGH,\n        assignee_email=\"a@a.com\", created_at=now, due_date=now + timedelta(hours=25)\n    )\n    assert high_task.is_overdue() == True\n\n    # Scenario B: Medium Priority, Due in 50 hours -> Should NOT be Overdue (72h rule)\n    med_task = Task(\n        id=\"m1\", title=\"Med Urgency\", priority=Priority.MEDIUM,\n        assignee_email=\"a@a.com\", created_at=now, due_date=now + timedelta(hours=50)\n    )\n    assert med_task.is_overdue() == False\n\n    # Scenario C: No Due Date -> Should NOT be Overdue\n    no_date_task = Task(\n        id=\"n1\", title=\"No Date\", priority=Priority.LOW,\n        assignee_email=\"a@a.com\", created_at=now\n    )\n    assert no_date_task.is_overdue() == False\n```\n\n#### Test Case 2: State Machine Validity\n**Test:** Ensure a task cannot move backwards or skip steps.\n\n```python\ndef test_status_transitions():\n    repo = InMemoryTaskRepository()\n    service = TaskService(repo, notification_svc)\n    \n    t1 = service.create_task(\"Test\", \"Desc\", \"medium\", \"dev@team.com\")\n    \n    # Valid: Draft -> Active\n    t1 = service.update_task_status(t1.id, \"active\")\n    assert t1.status == Status.ACTIVE\n\n    # Invalid: Active -> Draft (Cannot go back to draft once active)\n    with pytest.raises(TaskStateError):\n        service.update_task_status(t1.id, \"draft\")\n    \n    # Invalid: Draft -> Blocked (Cannot skip Active)\n    # (We would need to re-create or modify t1 to be draft for this specific test, \n    # but logic is proven by the exception)\n    \n    # Valid: Active -> Done\n    t1 = service.update_task_status(t1.id, \"done\")\n    assert t1.status == Status.DONE\n```\n\n#### Test Case 3: Completion Constraint\n**Test:** A task must have a completed checklist item to be marked Done.\n\n```python\ndef test_done_requires_checklist():\n    repo = InMemoryTaskRepository()\n    service = TaskService(repo, notification_svc)\n    \n    t1 = service.create_task(\"Test\", \"Desc\", \"medium\", \"dev@team.com\")\n    t1 = service.update_task_status(t1.id, \"active\")\n    \n    # Add items\n    t1.checklist.append(ChecklistItem(id=\"2\", text=\"Test 2\", completed=False))\n    \n    # Fail: Try to complete with no items checked\n    with pytest.raises(TaskStateError):\n        service.update_task_status(t1.id, \"done\")\n        \n    # Fail: Try to complete with an uncompleted item\n    with pytest.raises(TaskStateError):\n        service.update_task_status(t1.id, \"done\", {\"checklist_item_id\": \"2\"})\n        \n    # Success: Complete with a valid item\n    t1.checklist[0].completed = True\n    t1 = service.update_task_status(t1.id, \"done\", {\"checklist_item_id\": \"1\"})\n    assert t1.status == Status.DONE\n```\n\n#### Test Case 4: Notification Failure Resilience\n**Test:** The core task update should succeed even if the notification service crashes.\n\n```python\ndef test_notification_failure_doesnt_break_task():\n    # Setup a repo that raises an error on save for this specific task\n    class FailRepo(TaskRepository):\n        def save(self, task):\n            if task.id == \"notification_test\":\n                raise Exception(\"DB Crash\")\n            return task\n        def find_all(self, f): return []\n\n    service = TaskService(FailRepo(), NotificationService())\n    \n    t1 = service.create_task(\"Notify Test\", \"Desc\", \"medium\", \"dev@team.com\")\n    \n    # The core operation should return the task object successfully, despite the error\n    try:\n        t1 = service.update_task_status(t1.id, \"done\", {\"checklist_item_id\": \"1\"})\n    except Exception:\n        pass # Expected DB error here\n    \n    # Verify task is still marked Done\n    assert t1.status == Status.DONE \n```\n\n// Test: legacy_refactor_all_principles\n### Refactor Strategy: \"Model-First Modernization\"\n\n**Goal:** Move from an implicit, tightly coupled system to an explicit, testable, and bounded domain model.\n\n**Team Size Context:** With 10 engineers, this can be parallelized into 2 pods (5 devs each), or broken down into 3-week sprints.\n\n---\n\n### Phase 1: Stabilization & Visibility (Weeks 1\u20133)\n**Focus:** Eliminate ambiguity and naming inconsistencies to stop confusion.\n\n1.  **Define the Canonical Domain Model (DDoE):** Create a single source of truth for data structures and enums. Rename all legacy fields to match this model.\n2.  **Standardize API Responses:** Implement a strict error code framework (e.g., `TaskServiceError` enum) so callers can programmatically handle failures.\n3.  **Instrumentation:** Add structured logging to every state transition.\n\n*   **Action Item:** A \"No New Features\" sprint focused solely on code cleanup and schema alignment.\n\n### Phase 2: Logic Guardrails (Weeks 4\u20136)\n**Focus:** Fix state transition logic to prevent \"skipping steps.\"\n\n1.  **Implement Strict State Machine:** Replace imperative `if/else` logic with a finite state machine (FSM) library or class. Disallow illegal transitions via exceptions.\n2.  **Unit Test Coverage:** Ensure the state machine is 100% covered.\n3.  **Review Dependencies:** Audit third-party libraries for the Task Service to prevent external regressions.\n\n*   **Action Item:** A \"Bug Bash\" and State Machine implementation sprint.\n\n### Phase 3: Architecture & Resource Management (Weeks 7\u20139)\n**Focus:** Fix business rule rigidity and memory leaks.\n\n1.  **Strategy Pattern for Rules:** Extract business logic (e.g., \"Credit Check,\" \"Inventory Validation\") into separate strategy classes. This allows changing rules without touching the core task flow.\n2.  **Resource Pooling:** Implement connection pooling for external API calls to fix resource growth.\n3.  **Health Checks:** Add automated resource utilization monitoring (memory, CPU, thread pool depth).\n\n*   **Action Item:** Refactor core service classes and infrastructure setup.\n\n---\n\n### Rollback Strategy\nSince this is incremental, rollback is low risk.\n\n1.  **Feature Flags:** Deploy the refactor behind a feature flag. Only toggle it on once fully tested in a \"Canary\" environment.\n2.  **Branch Protection:** Keep the old `main` branch stable. If Phase 3 breaks performance, revert the flag immediately.\n3.  **Database Migration:** Ensure any schema changes are reversible (using transactions and rollback scripts) or deployed as \"append-only\" columns to preserve legacy data.\n\n### Success Criteria\n*   **State Transitions:** Zero \"Illegal State\" exceptions in logs for valid user inputs.\n*   **Error Handling:** 0% \"Unknown Error\" or generic `500` responses for known failure modes.\n*   **Resource Usage:** Memory usage is stable (flat line) over 24 hours, rather than growing linearly.\n*   **Tests:** >80% unit test coverage for the Domain Logic.\n\n---\n\n### Representative Before/After Examples\n\n#### 1. State Transition Logic\n**Problem:** Implicit state changes allow skipping validation.\n**Solution:** Explicit State Machine with guards.\n\n**BEFORE (Implicit/Spaghetti):**\n```javascript\n// The old code allows a direct jump from Pending to Completed, skipping Processing.\nfunction updateStatus(taskId, newStatus) {\n  const task = getTask(taskId);\n  if (task.status === 'PENDING') {\n    task.status = newStatus; // If newStatus is 'COMPLETED', validation is missed!\n  }\n  save(task);\n}\n```\n\n**AFTER (Explicit/State Machine):**\n```javascript\n// The new code throws an exception if the transition is invalid.\nclass TaskStateMachine {\n  static transition(task, newStatus) {\n    if (!this.isValidTransition(task.status, newStatus)) {\n      throw new InvalidStateTransitionError(\n        `Cannot move from ${task.status} to ${newStatus}`\n      );\n    }\n    task.status = newStatus;\n  }\n}\n// Validates that 'PENDING' -> 'COMPLETED' is invalid. Requires 'PROCESSING' first.\n```\n\n#### 2. Failure Handling\n**Problem:** Callers cannot tell what failed.\n**Solution:** Structured Error Codes.\n\n**BEFORE (Ambiguous):**\n```java\n// API Response\n{\n  \"status\": \"error\",\n  \"message\": \"Something went wrong with the backend.\"\n}\n// Caller: \"Was it the database? The network? The user?\"\n```\n\n**AFTER (Explicit):**\n```java\n// API Response\n{\n  \"status\": \"error\",\n  \"errorCode\": \"INSUFFICIENT_FUNDS\",\n  \"message\": \"The task requires more credit, please top up.\",\n  \"retries\": 3\n}\n// Caller: \"Okay, I will check the user's balance and retry.\"\n```\n\n#### 3. Naming Consistency\n**Problem:** Different services refer to the same thing differently.\n**Solution:** Canonical Domain Enum.\n\n**BEFORE (Inconsistent):**\n*   Service A: `task.status`\n*   Service B: `order.state`\n*   Database: `TASK_STATUS_CD`\n*   Logs: `taskState`\n\n**AFTER (Consistent):**\n```java\n// A single Enum used everywhere\npublic enum TaskStatus {\n  CREATED,\n  IN_PROGRESS,\n  COMPLETED,\n  FAILED\n}\n\n// Usage (Language agnostic)\ntask.status == TaskStatus.IN_PROGRESS;\n```\n\n### Immediate Next Step\n1.  **Identify the \"Canonical Model\":** Have the team agree on the single source of truth for data types and state definitions.\n2.  **Create the \"Test\":** Write a unit test that proves the old code allows illegal state transitions, proving the need for the refactor.",
          "after_code": "// Test: mini_app_full_stack_architecture_challenge\n### Architecture Overview\n\nFollowing the **Architecture Core** principles, this solution is structured as a layered architecture:\n\n1.  **Domain Layer (Pure Core)**: Contains the `Task` entity, business rules (invariants, transitions), and domain errors. It has no dependencies on external frameworks or infrastructure.\n2.  **Application Layer (Orchestration)**: Contains the use cases. It models the intent, validates against domain rules, and coordinates the flow between the Domain and Ports. Side effects (Notifications) are handled here but do not affect the success result of the use case.\n3.  **Ports & Adapters (Interface & External)**:\n    *   **Input Port**: API Interface (REST).\n    *   **Output Ports**: `TaskRepository` (Database), `NotificationService` (Email/Queue).\n\n**Key Architectural Decisions**:\n*   **State Machine**: Explicit `enum` for `Status` to prevent illegal transitions.\n*   **Typed Errors**: `DomainError` enum to distinguish between business logic failures (e.g., \"Task already done\") and technical failures (e.g., \"Task not found\").\n*   **Side Effects**: Notification failures are logged but do not propagate up, ensuring reliability.\n*   **Invariants**: Overdue logic is encapsulated within the domain entity to ensure calculation consistency.\n\n---\n\n### 1. Domain Layer (Pure Core)\n\n```rust\n// domain/models.rs\n\nuse std::fmt;\nuse std::time::{Duration, SystemTime};\n\n// --- Value Objects ---\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Priority {\n    Low,\n    Medium,\n    High,\n}\n\nimpl fmt::Display for Priority {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Priority::Low => write!(f, \"low\"),\n            Priority::Medium => write!(f, \"medium\"),\n            Priority::High => write!(f, \"high\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Status {\n    Draft,\n    Active,\n    Blocked,\n    Done,\n    Archived,\n}\n\nimpl Status {\n    pub fn allowed_next_states(&self) -> Vec<Status> {\n        match self {\n            Status::Draft => vec![Status::Active],\n            Status::Active => vec![Status::Blocked, Status::Done],\n            Status::Blocked => vec![Status::Active],\n            Status::Done => vec![Status::Archived],\n            Status::Archived => vec![],\n        }\n    }\n\n    pub fn is_terminal(&self) -> bool {\n        matches!(self, Status::Done | Status::Archived)\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct ChecklistItem {\n    pub id: String,\n    pub content: String,\n    pub is_completed: bool,\n}\n\nimpl ChecklistItem {\n    pub fn new(content: String) -> Self {\n        Self { id: uuid::Uuid::new_v4().to_string(), content, is_completed: false }\n    }\n    \n    pub fn complete(&mut self) {\n        self.is_completed = true;\n    }\n}\n\n// --- Domain Error ---\n#[derive(Debug, thiserror::Error)]\npub enum DomainError {\n    #[error(\"Task not found\")]\n    NotFound,\n    \n    #[error(\"Invalid status transition from {current:?} to {next:?}\")]\n    InvalidTransition { current: Status, next: Status },\n    \n    #[error(\"Cannot complete task: checklist incomplete\")]\n    ChecklistIncomplete,\n    \n    #[error(\"Task already archived\")]\n    AlreadyArchived,\n}\n\n// --- Entity ---\n#[derive(Debug, Clone)]\npub struct Task {\n    pub id: String,\n    pub title: String,\n    pub description: String,\n    pub priority: Priority,\n    pub assignee_email: String,\n    pub created_at: SystemTime,\n    pub due_date: Option<SystemTime>,\n    pub status: Status,\n    pub checklist: Vec<ChecklistItem>,\n}\n\nimpl Task {\n    pub fn new(\n        id: String,\n        title: String,\n        description: String,\n        priority: Priority,\n        assignee_email: String,\n        due_date: Option<SystemTime>,\n    ) -> Self {\n        Self {\n            id,\n            title,\n            description,\n            priority,\n            assignee_email,\n            created_at: SystemTime::now(),\n            due_date,\n            status: Status::Draft,\n            checklist: vec![],\n        }\n    }\n\n    pub fn add_checklist_item(&mut self, content: String) {\n        self.checklist.push(ChecklistItem::new(content));\n    }\n\n    pub fn complete_checklist_item(&mut self, item_id: &str) -> Result<(), DomainError> {\n        let item = self.checklist.iter_mut().find(|i| i.id == item_id)\n            .ok_or(DomainError::NotFound)?;\n        if item.is_completed {\n            return Err(DomainError::NotFound); // Or IdempotencyError\n        }\n        item.complete();\n        Ok(())\n    }\n\n    pub fn mark_as_done(&mut self) -> Result<(), DomainError> {\n        if !self.checklist.iter().any(|i| i.is_completed) {\n            return Err(DomainError::ChecklistIncomplete);\n        }\n        self.status = Status::Done;\n        Ok(())\n    }\n\n    pub fn transition_to(&mut self, new_status: Status) -> Result<(), DomainError> {\n        if !new_status.is_terminal() && !self.status.allowed_next_states().contains(&new_status) {\n            return Err(DomainError::InvalidTransition { current: self.status, next: new_status });\n        }\n        self.status = new_status;\n        Ok(())\n    }\n\n    // --- Invariant: Overdue Calculation ---\n    pub fn is_overdue(&self) -> bool {\n        // Only active tasks can be overdue\n        if self.status != Status::Active {\n            return false;\n        }\n        \n        let now = SystemTime::now();\n        let Some(due) = self.due_date else { return false };\n        \n        // Handle overflow\n        if due < now { return false; }\n\n        let diff = due.duration_since(now).unwrap_or_default();\n        \n        match self.priority {\n            Priority::High => diff > Duration::from_secs(24 * 3600),\n            Priority::Medium | Priority::Low => diff > Duration::from_secs(72 * 3600),\n        }\n    }\n}\n\nimpl Task {\n    pub fn mark_as_archived(&mut self) -> Result<(), DomainError> {\n        if !self.status.is_terminal() {\n            return Err(DomainError::InvalidTransition { current: self.status, next: Status::Archived });\n        }\n        self.status = Status::Archived;\n        Ok(())\n    }\n}\n```\n\n---\n\n### 2. Ports & Adapters\n\n```rust\n// ports/repository.rs\n\nuse crate::domain::Task;\n\n#[async_trait::async_trait]\npub trait TaskRepository: Send + Sync {\n    async fn find(&self, id: &str) -> Result<Option<Task>, RepositoryError>;\n    async fn save(&self, task: &Task) -> Result<(), RepositoryError>;\n    async fn list(&self, filters: TaskFilters) -> Result<Vec<Task>, RepositoryError>;\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum RepositoryError {\n    #[error(\"Database error\")]\n    DbError(#[from] sql::Error),\n}\n\n// ports/notification.rs\n\nuse crate::domain::Task;\n\npub trait NotificationService: Send + Sync {\n    async fn send_task_event(&self, task: &Task, event: TaskEvent) -> Result<(), NotificationError>;\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum NotificationError {\n    #[error(\"Failed to send notification\")]\n    SendFailed(String),\n}\n\n#[derive(Debug)]\npub enum TaskEvent {\n    Activated,\n    Blocked(String),\n    Completed,\n    Archived,\n}\n```\n\n---\n\n### 3. Application Layer (Use Cases)\n\n```rust\n// application/use_cases.rs\n\nuse super::ports::{TaskRepository, NotificationService};\nuse crate::domain::{Task, Priority, Status, TaskEvent, DomainError};\n\npub struct CreateTaskUseCase {\n    repo: Box<dyn TaskRepository>,\n    notifier: Box<dyn NotificationService>,\n}\n\nimpl CreateTaskUseCase {\n    pub fn new(repo: Box<dyn TaskRepository>, notifier: Box<dyn NotificationService>) -> Self {\n        Self { repo, notifier }\n    }\n\n    pub async fn execute(\n        &self,\n        title: String,\n        description: String,\n        priority: Priority,\n        assignee_email: String,\n        due_date: Option<chrono::DateTime<chrono::Utc>>,\n    ) -> Result<Task, ApplicationError> {\n        let task = Task::new(\n            uuid::Uuid::new_v4().to_string(),\n            title,\n            description,\n            priority,\n            assignee_email,\n            due_date.map(|d| d.into()),\n        );\n\n        self.repo.save(&task).await.map_err(Into::into)?;\n        \n        // Fire and forget notification\n        let _ = self.notifier.send_task_event(&task, TaskEvent::Activated).await;\n        \n        Ok(task)\n    }\n}\n\npub struct ActivateTaskUseCase {\n    repo: Box<dyn TaskRepository>,\n    notifier: Box<dyn NotificationService>,\n}\n\nimpl ActivateTaskUseCase {\n    pub async fn execute(&self, task_id: String) -> Result<Task, ApplicationError> {\n        let mut task = self.repo.find(&task_id).await?.ok_or(ApplicationError::NotFound)?;\n        \n        // Pure Logic\n        task.transition_to(Status::Active)?;\n        \n        // Persistence\n        self.repo.save(&task).await.map_err(Into::into)?;\n        \n        // Side Effect (Non-blocking)\n        let _ = self.notifier.send_task_event(&task, TaskEvent::Activated).await;\n        \n        Ok(task)\n    }\n}\n\n// ... BlockTask, CompleteTask, ArchiveTask use cases follow same pattern ...\n\n#[derive(Debug, thiserror::Error)]\npub enum ApplicationError {\n    #[error(\"Task not found\")]\n    NotFound,\n    #[error(\"Domain error: {0}\")]\n    DomainError(#[from] DomainError),\n    #[error(\"Repository error: {0}\")]\n    RepositoryError(#[from] RepositoryError),\n}\n```\n\n---\n\n### 4. API Contract (Input Adapter)\n\n```rust\n// adapter/api.rs\n\nuse rocket::Route;\nuse rocket::serde::{json::Json, Deserialize};\n\n#[derive(Deserialize)]\npub struct CreateTaskRequest {\n    pub title: String,\n    pub description: String,\n    pub priority: String, // low, medium, high\n    pub assignee_email: String,\n    pub due_date: Option<String>, // ISO 8601\n}\n\n#[derive(Deserialize)]\npub struct TaskFilterRequest {\n    pub status: Option<String>,\n    pub assignee: Option<String>,\n    pub priority: Option<String>,\n}\n\npub fn routes() -> Vec<Route> {\n    routes![create_task, activate_task, list_tasks]\n}\n\n#[post(\"/\", format = \"json\", data = \"<data>\")]\nasync fn create_task(data: Json<CreateTaskRequest>) -> Json<TaskResponse> {\n    // Wiring logic would go here (Instantiate Use Case, Transform Request, Execute)\n    Json(TaskResponse { id: \"123\".to_string() })\n}\n\n#[post(\"/<task_id>/activate\")]\nasync fn activate_task(task_id: String) -> Json<TaskResponse> {\n    // Wiring logic\n    Json(TaskResponse { id: task_id })\n}\n\n#[get(\"/\", format = \"json\", data = \"<filters>\")]\nasync fn list_tasks(filters: Option<Json<TaskFilterRequest>>) -> Json<Vec<TaskResponse>> {\n    // Wiring logic\n    Json(vec![])\n}\n\n#[derive(serde::Serialize)]\npub struct TaskResponse {\n    pub id: String,\n    pub title: String,\n    pub status: String,\n}\n```\n\n---\n\n### 5. Test Cases\n\nHere are focused tests covering the requirements.\n\n**Test 1: Status Transitions & Invariants**\n*Tests that illegal transitions fail and transitions respect the lifecycle.*\n\n```rust\n#[cfg(test)]\nmod domain_tests {\n    use super::*;\n\n    #[test]\n    fn test_valid_status_transitions() {\n        let mut task = Task::new(\"1\".into(), \"Test\".into(), \"Desc\".into(), Priority::High, \"me@example.com\".into(), None);\n        \n        // Draft -> Active\n        task.transition_to(Status::Active).unwrap();\n        assert_eq!(task.status, Status::Active);\n\n        // Active -> Blocked\n        task.transition_to(Status::Blocked).unwrap();\n        assert_eq!(task.status, Status::Blocked);\n\n        // Blocked -> Active\n        task.transition_to(Status::Active).unwrap();\n        \n        // Active -> Done (requires checklist)\n        task.add_checklist_item(\"Item 1\".into());\n        task.complete_checklist_item(\"uuid1\").unwrap();\n        task.transition_to(Status::Done).unwrap();\n        assert_eq!(task.status, Status::Done);\n\n        // Done -> Archived\n        task.transition_to(Status::Archived).unwrap();\n    }\n\n    #[test]\n    fn test_invalid_status_transitions() {\n        let mut task = Task::new(\"1\".into(), \"Test\".into(), \"Desc\".into(), Priority::High, \"me@example.com\".into(), None);\n\n        // Draft -> Blocked (Illegal)\n        let res = task.transition_to(Status::Blocked);\n        assert!(res.is_err());\n\n        // Archived -> Done (Illegal)\n        task.status = Status::Archived;\n        let res = task.transition_to(Status::Done);\n        assert!(res.is_err());\n    }\n}\n```\n\n**Test 2: Overdue Logic**\n*Tests the time-sensitive business rule based on priority.*\n\n```rust\n#[cfg(test)]\nmod overdue_tests {\n    use super::*;\n    use std::time::{SystemTime, UNIX_EPOCH};\n\n    #[test]\n    fn test_high_priority_overdue_24h() {\n        let mut task = Task::new(\"1\".into(), \"Test\".into(), \"Desc\".into(), Priority::High, \"me@example.com\".into(), None);\n        \n        // Set due date to 25 hours ago\n        let old_time = UNIX_EPOCH - Duration::from_secs(25 * 3600);\n        task.due_date = Some(old_time);\n\n        assert!(task.is_overdue());\n    }\n\n    #[test]\n    fn test_medium_priority_not_overdue_30h() {\n        let mut task = Task::new(\"1\".into(), \"Test\".into(), \"Desc\".into(), Priority::Medium, \"me@example.com\".into(), None);\n        \n        // Set due date to 30 hours ago\n        let old_time = UNIX_EPOCH - Duration::from_secs(30 * 3600);\n        task.due_date = Some(old_time);\n\n        assert!(!task.is_overdue());\n    }\n\n    #[test]\n    fn test_task_not_overdue_if_not_active() {\n        let mut task = Task::new(\"1\".into(), \"Test\".into(), \"Desc\".into(), Priority::High, \"me@example.com\".into(), None);\n        task.status = Status::Done;\n        \n        // Set due date to 25 hours ago\n        let old_time = UNIX_EPOCH - Duration::from_secs(25 * 3600);\n        task.due_date = Some(old_time);\n\n        assert!(!task.is_overdue());\n    }\n}\n```\n\n**Test 3: Reliability & Notification Failure**\n*Tests that notification failure does not block the task update.*\n\n```rust\n#[cfg(test)]\nmod reliability_tests {\n    use super::*;\n    use mockall::mock;\n\n    mock! {\n        NotificationService {}\n        #[async_trait::async_trait]\n        impl NotificationService for NotificationService {\n            async fn send_task_event(&self, task: &Task, event: TaskEvent) -> Result<(), NotificationError>;\n        }\n    }\n\n    #[tokio::test]\n    async fn test_notification_failure_does_not_fail_update() {\n        // Setup\n        let mut mock_repo = MockTaskRepository::new();\n        let mut mock_notify = MockNotificationService::new();\n        \n        // Mock Repo: Save succeeds\n        mock_repo.expect_save().times(1).returning(|_| Ok(()));\n        \n        // Mock Repo: Find returns existing task\n        let mut task = Task::new(\"1\".into(), \"Test\".into(), \"Desc\".into(), Priority::High, \"me@example.com\".into(), None);\n        task.transition_to(Status::Active).unwrap();\n        mock_repo.expect_find().returning(|_| Ok(Some(task)));\n\n        // Mock Notify: Fail on activation\n        mock_notify.expect_send_task_event()\n            .times(1)\n            .returning(|_, _| Err(NotificationError::SendFailed(\"Mailbox full\".into())));\n\n        // Execution\n        let use_case = ActivateTaskUseCase {\n            repo: Box::new(mock_repo),\n            notifier: Box::new(mock_notify),\n        };\n        \n        let result = use_case.execute(\"1\".into()).await;\n        \n        // Assert: Task should be updated successfully despite notification failure\n        assert!(result.is_ok());\n    }\n}\n```\n\n// Test: legacy_refactor_all_principles\nBased on the **Architecture Core** skill provided, the legacy task service must be refactored to eliminate state inconsistency, resource leaks, and ambiguous errors by enforcing explicit invariants and separating pure domain logic from effectful interactions.\n\nHere is the proposed incremental refactor plan.\n\n### Refactor Strategy: Clean Architecture Application\n\nWe will adopt a **Ports and Adapters** approach. The core will be purified (domain types + state machine), while the application orchestrates logic and side effects.\n\n### The Incremental Plan (4 Weeks)\n\n**Phase 1: State Model & Invariant Definition (Week 1)**\n*   **Goal:** Fix \"state skipping\" and resource growth.\n*   **Action:** Define an `enum` for the `TaskState` with strict `match` exhaustiveness. Implement a \"State Guard\" in the core that rejects illegal transitions.\n*   **Team Task:** Analyze current codebase to extract state flags (e.g., `isRunning`, `isCompleted`). Replace boolean flags with a single enum.\n*   **Rollback:** Feature flag `legacy-state-mode` (off by default) to revert to original state machine behavior if state transitions fail.\n\n**Phase 2: Pure Core Implementation (Week 2)**\n*   **Goal:** Fix \"business rules difficult to change\" and \"inconsistent naming.\"\n*   **Action:** Move all domain logic to the `Core` layer. Ensure no DB/API imports exist here. Define explicit **Ports** (interfaces) for `TaskRepository` and `Notifier`.\n*   **Team Task:** Team splits into \"Business Logic\" (validating rules) and \"Naming Consistency\" (standardizing verb/object usage).\n\n**Phase 3: Effectful Boundaries & Resource Management (Week 3)**\n*   **Goal:** Fix \"resource usage growth\" and \"ambiguous failures.\"\n*   **Action:** Implement the Application layer. Use `Result` types for explicit errors. Implement a `ResourcePool` adapter to handle long-running operation cleanup (RAII pattern).\n*   **Team Task:** Wire the adapters. Add `LogHandler` and `MetricsCollector` as transparent dependencies to monitor resource leaks.\n\n**Phase 4: Adapters & Verification (Week 4)**\n*   **Goal:** Stabilize integration.\n*   **Action:** Clean up HTTP/API adapters. Ensure they only handle protocol details (JSON, HTTP codes). Write the 3-5 focused tests defined in the Output Contract.\n\n---\n\n### Representative Before/After Examples\n\n#### 1. State Transition Logic (Fixing Skipped Steps)\n**Problem:** State changes are conditional and implicit; skipping a step is easy.\n\n**Before:**\n```java\n// Anti-Pattern: Implicit logic, mutable state, no enforcement\npublic void runTask() {\n    if (this.status == \"pending\") {\n        this.status = \"running\";\n        this.startTime = now();\n        startBackgroundWork();\n    }\n    // Logic gaps allow status to remain \"pending\" or jump to \"finished\"\n}\n```\n\n**After (Architecture Core):**\n```rust\n// Explicit state + invariants\n#[derive(Debug, PartialEq)]\nenum TaskState {\n    Draft,\n    InProgress { started_at: DateTime },\n    Completed { finished_at: DateTime },\n    Failed { error: String },\n}\n\nimpl Task {\n    // Deterministic transitions\n    fn attempt_start(&mut self) -> Result<(), TransitionError> {\n        match self.state {\n            TaskState::Draft => {\n                self.state = TaskState::InProgress { started_at: Utc::now() };\n                Ok(())\n            },\n            _ => Err(TransitionError::InvalidState(\"Must be Draft\".into()))\n        }\n    }\n}\n```\n\n#### 2. Failure Handling (Fixing Ambiguous Failures)\n**Problem:** Callers cannot tell what failed; generic exceptions are thrown.\n\n**Before:**\n```java\n// Anti-Pattern: Generic exception, lossy error info\npublic void execute() {\n    try {\n        // ... complex logic\n        db.save(result);\n    } catch (Exception e) {\n        throw new RuntimeException(\"Operation failed\"); // Caller has no clue why\n    }\n}\n```\n\n**After (Architecture Core):**\n```rust\n// Explicit typed errors + domain intent naming\n#[derive(Debug)]\nenum TaskOutcome {\n    Success,\n    InvalidInput,\n    DependencyUnavailable,\n    ResourceExhausted,\n}\n\nimpl TaskService {\n    fn execute(&self, input: Input) -> Result<TaskOutcome, TaskError> {\n        if input.is_empty() {\n            return Err(TaskError::InvalidInput);\n        }\n        // ...\n        Ok(TaskOutcome::Success)\n    }\n}\n```\n\n#### 3. Naming Consistency (Fixing \"Different names for same concept\")\n**Problem:** Logic uses `start`, `begin`, `run`; external uses `init`, `process`, `fire`.\n\n**Before:**\n*   Core: `startWork()`\n*   API: `initTask()`\n*   Database: `processRecord()`\n\n**After (Domain-Intent Naming):**\n*   Unified terminology: `Start`, `Complete`, `Cancel`, `Retrieve`.\n*   All layers use these verbs. The interface definitions (Ports) act as the translation layer if external systems strictly require old nomenclature.\n\n---\n\n### Success Criteria & Verification\n\n1.  **Type Safety:** All state changes must go through the explicit `TaskState` enum match.\n2.  **Test Coverage:** 3-5 focused tests pass:\n    *   Valid transition logic.\n    *   Transition rejection (invariant violation).\n    *   Error boundary conditions.\n3.  **Resource Lifecycle:** No memory leaks observed during long-running operation (verified via profiling).\n4.  **Error Visibility:** `TaskOutcome` is returned instead of generic exceptions; logs show `TaskError::DependencyUnavailable` specifically.\n5.  **Architecture Check:** Domain layer contains zero imports from Framework/ORM layers.",
          "judgment": {
            "principle_better": "B",
            "quality_better": "B",
            "overall_better": "B",
            "option_a_rating": "good",
            "option_b_rating": "outstanding",
            "score": 100,
            "reasoning": "Solution B strictly adheres to a modular architecture (Ports and Adapters), utilizing a finite state machine and explicit error handling to ensure reliability and testability. Solution A, while functional, is a monolithic script that mixes concerns and relies on manual state checks, whereas Solution B encapsulates logic in pure domains and separates orchestration from effects."
          },
          "judge_error": false,
          "tests": [
            {
              "name": "mini_app_full_stack_architecture_challenge",
              "input": "Build a Team Task Tracker backend for small engineering teams.\n\nProduct requirements:\n1) Task data\n- Each task has: id, title, description, priority (low/medium/high), assignee email, created timestamp, optional due date, and current status.\n- Allowed status lifecycle: draft -> active -> blocked -> done -> archived.\n- A task can move only to the next logical stage in the lifecycle.\n- A task cannot be marked done unless at least one checklist item is completed.\n\n2) Features\n- Create task\n- Activate task\n- Block task with a required reason\n- Complete task\n- Archive task\n- List tasks with filters (status, assignee, priority, overdue)\n\n3) Notifications\n- Send a notification when a task is activated, blocked, completed, or archived.\n- If notification delivery fails, core task operation result must still be explicit and unambiguous.\n\n4) Overdue behavior\n- High priority tasks are overdue after 24 hours past due date.\n- Medium/low priority tasks are overdue after 72 hours past due date.\n- Overdue calculation must be consistent and testable.\n\n5) Reliability and consistency\n- If two updates happen close together, final task status must remain valid.\n- The system must avoid contradictory task states.\n- Failures must return clear machine-readable error outcomes.\n\n6) Deliverables\n- Implementation code (or detailed pseudocode)\n- API contract for all operations\n- Test cases covering status transitions, overdue rules, and failure scenarios",
              "expected": {
                "focus": "Does the solution apply all major principles together: explicit invariants/state machine, pure core + effectful shell, ports/adapters boundaries, unidirectional ownership flow, structured error types, explicit lifecycle cleanup, policy-mechanism separation, composition over coordinator, controlled mutation, and domain-driven naming?"
              },
              "baseline_response": "Here is a complete backend solution for the Team Task Tracker, designed with reliability and clear separation of concerns in mind.\n\n### 1. API Contract\n\nThis defines the HTTP interface for the system.\n\n**Base URL:** `/api/v1/tasks`\n\n| Method | Endpoint | Description | Request Body | Success Response | Error Response |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| **POST** | `/` | Create a new task | `title`, `description`, `priority`, `assigneeEmail`, `dueDate` (optional) | `201 Created` (Task ID) | `400 Bad Request` |\n| **GET** | `/` | List tasks with filters | `status`, `assignee`, `priority`, `overdue` | `200 OK` (Array of Tasks) | `400 Bad Request` |\n| **PATCH** | `/{id}/activate` | Activate (Draft -> Active) | None | `200 OK` (Task) | `400 Bad Request` (Invalid State) |\n| **PATCH** | `/{id}/block` | Block (Active -> Blocked) | `reason` (required) | `200 OK` (Task) | `400 Bad Request` (Missing Reason) |\n| **PATCH** | `/{id}/complete` | Complete (Active -> Done) | `checklist_item_id` (required) | `200 OK` (Task) | `400 Bad Request` (No items or invalid ID) |\n| **PATCH** | `/{id}/archive` | Archive (Done -> Archived) | None | `200 OK` (Task) | `400 Bad Request` (Invalid State) |\n\n---\n\n### 2. Implementation Code (Python)\n\nWe will implement this using a Service layer pattern. This allows the database and notification logic to be swapped out without changing the API controllers.\n\n```python\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nfrom typing import List, Optional, Dict, Any\nimport uuid\nimport logging\n\n# --- Configuration & Enums ---\n\nclass Priority(Enum):\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n\nclass Status(Enum):\n    DRAFT = \"draft\"\n    ACTIVE = \"active\"\n    BLOCKED = \"blocked\"\n    DONE = \"done\"\n    ARCHIVED = \"archived\"\n\n@dataclass\nclass ChecklistItem:\n    id: str\n    text: str\n    completed: bool = False\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    priority: Priority\n    assignee_email: str\n    created_at: datetime\n    due_date: Optional[datetime] = None\n    status: Status = Status.DRAFT\n    checklist: List[ChecklistItem] = field(default_factory=list)\n    version: int = 1  # For optimistic locking\n    \n    # Notification status flag\n    notified: bool = False\n\n    def is_overdue(self) -> bool:\n        \"\"\"Calculates if task is overdue based on priority.\"\"\"\n        if not self.due_date:\n            return False\n        \n        now = datetime.utcnow()\n        diff = now - self.due_date\n        \n        # High priority: > 24h\n        # Medium/Low: > 72h\n        threshold = timedelta(hours=24) if self.priority == Priority.HIGH else timedelta(hours=72)\n        return diff >= threshold\n\n# --- Domain Logic ---\n\nclass TaskStateError(Exception):\n    \"\"\"Raised when an invalid state transition is attempted.\"\"\"\n    pass\n\nclass NotificationError(Exception):\n    \"\"\"Raised when notification delivery fails.\"\"\"\n    pass\n\n# --- Infrastructure Interfaces ---\n\nclass NotificationService:\n    def send(self, task_id: str, event: str, assignee: str):\n        \"\"\"Simulates sending a notification.\"\"\"\n        # In a real app, this would call SMTP/SMS/Slack APIs\n        print(f\"[Notification Service] Sending '{event}' for Task {task_id} to {assignee}\")\n        # Random failure simulation\n        if event == \"blocked\" and task_id == \"fail_test\":\n            raise NotificationError(\"Simulated SMTP failure\")\n\nclass TaskRepository:\n    def save(self, task: Task) -> Task:\n        # In a real app, this is a DB transaction (INSERT/UPDATE)\n        return task\n\n    def find_all(self, filters: Dict[str, Any]) -> List[Task]:\n        # In a real app, this is a SQL SELECT with WHERE clauses\n        return []\n\n# --- Core Business Logic ---\n\nclass TaskService:\n    def __init__(self, repo: TaskRepository, notification_service: NotificationService):\n        self.repo = repo\n        self.notification_service = notification_service\n\n    def create_task(self, title: str, description: str, priority: str, assignee_email: str, due_date: Optional[datetime]) -> Task:\n        task = Task(\n            id=str(uuid.uuid4()),\n            title=title,\n            description=description,\n            priority=Priority[priority.upper()],\n            assignee_email=assignee_email,\n            created_at=datetime.utcnow(),\n            due_date=due_date,\n            checklist=[ChecklistItem(id=\"1\", text=\"Initial task setup\", completed=False)]\n        )\n        return self.repo.save(task)\n\n    def update_task_status(self, task_id: str, status: str, payload: Optional[Dict] = None):\n        # 1. Retrieve (Optimistic Locking)\n        task = self.repo.find_all({\"id\": task_id})[0]\n        \n        if task.version != 1:\n             # Simplified version check for demo. Real impl checks if requested version == current\n             pass \n\n        new_status = Status(status)\n        \n        # 2. Validate State Transition\n        self._validate_transition(task.status, new_status, payload)\n\n        # 3. Execute Transition\n        old_status = task.status\n        task.status = new_status\n        \n        # 4. Handle Post-Transition Logic\n        self._handle_post_transition_logic(task, new_status, payload)\n\n        # 5. Notify (Non-blocking)\n        self._try_notify(task, old_status, new_status)\n\n        # 6. Persist\n        return self.repo.save(task)\n\n    def _validate_transition(self, current_status: Status, target_status: Status, payload: Optional[Dict]):\n        # Define valid lifecycle graph\n        valid_transitions = {\n            Status.DRAFT: {Status.ACTIVE},\n            Status.ACTIVE: {Status.BLOCKED, Status.DONE},\n            Status.BLOCKED: {Status.ACTIVE},\n            Status.DONE: {Status.ARCHIVED},\n        }\n        \n        if target_status not in valid_transitions.get(current_status, set()):\n            raise TaskStateError(f\"Cannot move from {current_status} to {target_status}\")\n\n        # Specific checks per transition\n        if target_status == Status.BLOCKED and not payload.get(\"reason\"):\n            raise TaskStateError(\"Blocking requires a 'reason' field.\")\n            \n        if target_status == Status.DONE:\n            if not task.checklist:\n                raise TaskStateError(\"Cannot mark done without a checklist.\")\n            \n            # Check if the provided item exists and is completed\n            item_id = payload.get(\"checklist_item_id\")\n            item = next((i for i in task.checklist if i.id == item_id), None)\n            if not item or not item.completed:\n                raise TaskStateError(\"Task requires at least one completed checklist item.\")\n\n    def _handle_post_transition_logic(self, task: Task, new_status: Status, payload: Optional[Dict]):\n        if new_status == Status.DONE:\n            # Ensure only one item is checked off if that's a business rule\n            pass\n\n    def _try_notify(self, task: Task, old_status: Status, new_status: Status):\n        event_name = f\"task_{new_status.value}\"\n        \n        try:\n            self.notification_service.send(task.id, event_name, task.assignee_email)\n            task.notified = True\n        except NotificationError as e:\n            # Requirement: \"If notification delivery fails, core task operation result must still be explicit\"\n            logging.error(f\"Notification failed for {task.id}: {e}. Task state remains valid.\")\n\n    def get_tasks(self, filters: Dict[str, Any]) -> List[Task]:\n        all_tasks = self.repo.find_all(filters)\n        \n        # Apply In-Memory Filtering logic (SQL would do this in DB)\n        if filters.get(\"overdue\") == \"true\":\n            all_tasks = [t for t in all_tasks if t.is_overdue()]\n        \n        # Simple filter map\n        if \"status\" in filters:\n            all_tasks = [t for t in all_tasks if t.status == Status[filters[\"status\"].upper()]]\n        \n        return all_tasks\n\n# --- Mock Repositories for Demo ---\n\nclass InMemoryTaskRepository(TaskRepository):\n    def __init__(self):\n        self.tasks: Dict[str, Task] = {}\n\n    def save(self, task: Task) -> Task:\n        self.tasks[task.id] = task\n        return task\n\n    def find_all(self, filters: Dict[str, Any]) -> List[Task]:\n        results = list(self.tasks.values())\n        \n        # Apply simple filters\n        if \"status\" in filters:\n            status = filters[\"status\"].upper()\n            results = [t for t in results if t.status.value == status]\n        \n        if \"assignee\" in filters:\n            results = [t for t in results if t.assignee_email == filters[\"assignee\"]]\n            \n        return results\n\n# --- Demo / Usage ---\n\ndef run_demo():\n    repo = InMemoryTaskRepository()\n    notification_svc = NotificationService()\n    service = TaskService(repo, notification_svc)\n\n    # 1. Create Task\n    print(\"--- Creating Task ---\")\n    t1 = service.create_task(\n        title=\"Fix Login Bug\", \n        description=\"User cannot login with OAuth\", \n        priority=\"high\", \n        assignee_email=\"dev@team.com\", \n        due_date=datetime.utcnow() + timedelta(hours=-12) # Already overdue\n    )\n    print(f\"Created: {t1.id} | Status: {t1.status}\")\n\n    # 2. Activate Task\n    print(\"\\n--- Activating Task ---\")\n    t1 = service.update_task_status(t1.id, \"active\")\n    print(f\"Status: {t1.status}\")\n\n    # 3. Block Task\n    print(\"\\n--- Blocking Task ---\")\n    try:\n        # Test failure scenario\n        # service.update_task_status(\"fail_test\", \"blocked\", {\"reason\": \"API Down\"}) \n        t1 = service.update_task_status(t1.id, \"blocked\", {\"reason\": \"Database connection timeout\"})\n        print(f\"Status: {t1.status} | Notified: {t1.notified}\")\n    except TaskStateError as e:\n        print(f\"Error: {e}\")\n\n    # 4. Mark Complete\n    print(\"\\n--- Completing Task ---\")\n    # Mark the first checklist item as completed first\n    t1.checklist[0].completed = True\n    \n    # Attempt complete without item (should fail)\n    try:\n        service.update_task_status(t1.id, \"done\", {})\n    except TaskStateError as e:\n        print(f\"Failed (expected): {e}\")\n\n    # Attempt complete with valid item\n    try:\n        t1 = service.update_task_status(t1.id, \"done\", {\"checklist_item_id\": \"1\"})\n        print(f\"Status: {t1.status}\")\n    except TaskStateError as e:\n        print(f\"Error: {e}\")\n\n    # 5. List Overdue\n    print(\"\\n--- Filtering Overdue ---\")\n    print(f\"Found {len(service.get_tasks({'overdue': 'true', 'status': 'active'}))} overdue tasks.\")\n    \n    # 6. Archive\n    print(\"\\n--- Archiving ---\")\n    t1 = service.update_task_status(t1.id, \"archived\")\n    print(f\"Status: {t1.status}\")\n\nif __name__ == \"__main__\":\n    run_demo()\n```\n\n---\n\n### 3. Test Cases\n\nHere are the specific test cases designed to verify the requirements.\n\n#### Test Case 1: Overdue Logic\n**Test:** Verify that High priority tasks trigger overdue status faster than Medium/Low tasks.\n\n```python\nimport pytest\nfrom datetime import datetime, timedelta\n\ndef test_overdue_calculation():\n    service = TaskService(repo, notification_svc)\n    \n    # Scenario A: High Priority, Due in 25 hours -> Should be Overdue\n    now = datetime.utcnow()\n    high_task = Task(\n        id=\"h1\", title=\"High Urgency\", priority=Priority.HIGH,\n        assignee_email=\"a@a.com\", created_at=now, due_date=now + timedelta(hours=25)\n    )\n    assert high_task.is_overdue() == True\n\n    # Scenario B: Medium Priority, Due in 50 hours -> Should NOT be Overdue (72h rule)\n    med_task = Task(\n        id=\"m1\", title=\"Med Urgency\", priority=Priority.MEDIUM,\n        assignee_email=\"a@a.com\", created_at=now, due_date=now + timedelta(hours=50)\n    )\n    assert med_task.is_overdue() == False\n\n    # Scenario C: No Due Date -> Should NOT be Overdue\n    no_date_task = Task(\n        id=\"n1\", title=\"No Date\", priority=Priority.LOW,\n        assignee_email=\"a@a.com\", created_at=now\n    )\n    assert no_date_task.is_overdue() == False\n```\n\n#### Test Case 2: State Machine Validity\n**Test:** Ensure a task cannot move backwards or skip steps.\n\n```python\ndef test_status_transitions():\n    repo = InMemoryTaskRepository()\n    service = TaskService(repo, notification_svc)\n    \n    t1 = service.create_task(\"Test\", \"Desc\", \"medium\", \"dev@team.com\")\n    \n    # Valid: Draft -> Active\n    t1 = service.update_task_status(t1.id, \"active\")\n    assert t1.status == Status.ACTIVE\n\n    # Invalid: Active -> Draft (Cannot go back to draft once active)\n    with pytest.raises(TaskStateError):\n        service.update_task_status(t1.id, \"draft\")\n    \n    # Invalid: Draft -> Blocked (Cannot skip Active)\n    # (We would need to re-create or modify t1 to be draft for this specific test, \n    # but logic is proven by the exception)\n    \n    # Valid: Active -> Done\n    t1 = service.update_task_status(t1.id, \"done\")\n    assert t1.status == Status.DONE\n```\n\n#### Test Case 3: Completion Constraint\n**Test:** A task must have a completed checklist item to be marked Done.\n\n```python\ndef test_done_requires_checklist():\n    repo = InMemoryTaskRepository()\n    service = TaskService(repo, notification_svc)\n    \n    t1 = service.create_task(\"Test\", \"Desc\", \"medium\", \"dev@team.com\")\n    t1 = service.update_task_status(t1.id, \"active\")\n    \n    # Add items\n    t1.checklist.append(ChecklistItem(id=\"2\", text=\"Test 2\", completed=False))\n    \n    # Fail: Try to complete with no items checked\n    with pytest.raises(TaskStateError):\n        service.update_task_status(t1.id, \"done\")\n        \n    # Fail: Try to complete with an uncompleted item\n    with pytest.raises(TaskStateError):\n        service.update_task_status(t1.id, \"done\", {\"checklist_item_id\": \"2\"})\n        \n    # Success: Complete with a valid item\n    t1.checklist[0].completed = True\n    t1 = service.update_task_status(t1.id, \"done\", {\"checklist_item_id\": \"1\"})\n    assert t1.status == Status.DONE\n```\n\n#### Test Case 4: Notification Failure Resilience\n**Test:** The core task update should succeed even if the notification service crashes.\n\n```python\ndef test_notification_failure_doesnt_break_task():\n    # Setup a repo that raises an error on save for this specific task\n    class FailRepo(TaskRepository):\n        def save(self, task):\n            if task.id == \"notification_test\":\n                raise Exception(\"DB Crash\")\n            return task\n        def find_all(self, f): return []\n\n    service = TaskService(FailRepo(), NotificationService())\n    \n    t1 = service.create_task(\"Notify Test\", \"Desc\", \"medium\", \"dev@team.com\")\n    \n    # The core operation should return the task object successfully, despite the error\n    try:\n        t1 = service.update_task_status(t1.id, \"done\", {\"checklist_item_id\": \"1\"})\n    except Exception:\n        pass # Expected DB error here\n    \n    # Verify task is still marked Done\n    assert t1.status == Status.DONE \n```",
              "skill_response": "### Architecture Overview\n\nFollowing the **Architecture Core** principles, this solution is structured as a layered architecture:\n\n1.  **Domain Layer (Pure Core)**: Contains the `Task` entity, business rules (invariants, transitions), and domain errors. It has no dependencies on external frameworks or infrastructure.\n2.  **Application Layer (Orchestration)**: Contains the use cases. It models the intent, validates against domain rules, and coordinates the flow between the Domain and Ports. Side effects (Notifications) are handled here but do not affect the success result of the use case.\n3.  **Ports & Adapters (Interface & External)**:\n    *   **Input Port**: API Interface (REST).\n    *   **Output Ports**: `TaskRepository` (Database), `NotificationService` (Email/Queue).\n\n**Key Architectural Decisions**:\n*   **State Machine**: Explicit `enum` for `Status` to prevent illegal transitions.\n*   **Typed Errors**: `DomainError` enum to distinguish between business logic failures (e.g., \"Task already done\") and technical failures (e.g., \"Task not found\").\n*   **Side Effects**: Notification failures are logged but do not propagate up, ensuring reliability.\n*   **Invariants**: Overdue logic is encapsulated within the domain entity to ensure calculation consistency.\n\n---\n\n### 1. Domain Layer (Pure Core)\n\n```rust\n// domain/models.rs\n\nuse std::fmt;\nuse std::time::{Duration, SystemTime};\n\n// --- Value Objects ---\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Priority {\n    Low,\n    Medium,\n    High,\n}\n\nimpl fmt::Display for Priority {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Priority::Low => write!(f, \"low\"),\n            Priority::Medium => write!(f, \"medium\"),\n            Priority::High => write!(f, \"high\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Status {\n    Draft,\n    Active,\n    Blocked,\n    Done,\n    Archived,\n}\n\nimpl Status {\n    pub fn allowed_next_states(&self) -> Vec<Status> {\n        match self {\n            Status::Draft => vec![Status::Active],\n            Status::Active => vec![Status::Blocked, Status::Done],\n            Status::Blocked => vec![Status::Active],\n            Status::Done => vec![Status::Archived],\n            Status::Archived => vec![],\n        }\n    }\n\n    pub fn is_terminal(&self) -> bool {\n        matches!(self, Status::Done | Status::Archived)\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct ChecklistItem {\n    pub id: String,\n    pub content: String,\n    pub is_completed: bool,\n}\n\nimpl ChecklistItem {\n    pub fn new(content: String) -> Self {\n        Self { id: uuid::Uuid::new_v4().to_string(), content, is_completed: false }\n    }\n    \n    pub fn complete(&mut self) {\n        self.is_completed = true;\n    }\n}\n\n// --- Domain Error ---\n#[derive(Debug, thiserror::Error)]\npub enum DomainError {\n    #[error(\"Task not found\")]\n    NotFound,\n    \n    #[error(\"Invalid status transition from {current:?} to {next:?}\")]\n    InvalidTransition { current: Status, next: Status },\n    \n    #[error(\"Cannot complete task: checklist incomplete\")]\n    ChecklistIncomplete,\n    \n    #[error(\"Task already archived\")]\n    AlreadyArchived,\n}\n\n// --- Entity ---\n#[derive(Debug, Clone)]\npub struct Task {\n    pub id: String,\n    pub title: String,\n    pub description: String,\n    pub priority: Priority,\n    pub assignee_email: String,\n    pub created_at: SystemTime,\n    pub due_date: Option<SystemTime>,\n    pub status: Status,\n    pub checklist: Vec<ChecklistItem>,\n}\n\nimpl Task {\n    pub fn new(\n        id: String,\n        title: String,\n        description: String,\n        priority: Priority,\n        assignee_email: String,\n        due_date: Option<SystemTime>,\n    ) -> Self {\n        Self {\n            id,\n            title,\n            description,\n            priority,\n            assignee_email,\n            created_at: SystemTime::now(),\n            due_date,\n            status: Status::Draft,\n            checklist: vec![],\n        }\n    }\n\n    pub fn add_checklist_item(&mut self, content: String) {\n        self.checklist.push(ChecklistItem::new(content));\n    }\n\n    pub fn complete_checklist_item(&mut self, item_id: &str) -> Result<(), DomainError> {\n        let item = self.checklist.iter_mut().find(|i| i.id == item_id)\n            .ok_or(DomainError::NotFound)?;\n        if item.is_completed {\n            return Err(DomainError::NotFound); // Or IdempotencyError\n        }\n        item.complete();\n        Ok(())\n    }\n\n    pub fn mark_as_done(&mut self) -> Result<(), DomainError> {\n        if !self.checklist.iter().any(|i| i.is_completed) {\n            return Err(DomainError::ChecklistIncomplete);\n        }\n        self.status = Status::Done;\n        Ok(())\n    }\n\n    pub fn transition_to(&mut self, new_status: Status) -> Result<(), DomainError> {\n        if !new_status.is_terminal() && !self.status.allowed_next_states().contains(&new_status) {\n            return Err(DomainError::InvalidTransition { current: self.status, next: new_status });\n        }\n        self.status = new_status;\n        Ok(())\n    }\n\n    // --- Invariant: Overdue Calculation ---\n    pub fn is_overdue(&self) -> bool {\n        // Only active tasks can be overdue\n        if self.status != Status::Active {\n            return false;\n        }\n        \n        let now = SystemTime::now();\n        let Some(due) = self.due_date else { return false };\n        \n        // Handle overflow\n        if due < now { return false; }\n\n        let diff = due.duration_since(now).unwrap_or_default();\n        \n        match self.priority {\n            Priority::High => diff > Duration::from_secs(24 * 3600),\n            Priority::Medium | Priority::Low => diff > Duration::from_secs(72 * 3600),\n        }\n    }\n}\n\nimpl Task {\n    pub fn mark_as_archived(&mut self) -> Result<(), DomainError> {\n        if !self.status.is_terminal() {\n            return Err(DomainError::InvalidTransition { current: self.status, next: Status::Archived });\n        }\n        self.status = Status::Archived;\n        Ok(())\n    }\n}\n```\n\n---\n\n### 2. Ports & Adapters\n\n```rust\n// ports/repository.rs\n\nuse crate::domain::Task;\n\n#[async_trait::async_trait]\npub trait TaskRepository: Send + Sync {\n    async fn find(&self, id: &str) -> Result<Option<Task>, RepositoryError>;\n    async fn save(&self, task: &Task) -> Result<(), RepositoryError>;\n    async fn list(&self, filters: TaskFilters) -> Result<Vec<Task>, RepositoryError>;\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum RepositoryError {\n    #[error(\"Database error\")]\n    DbError(#[from] sql::Error),\n}\n\n// ports/notification.rs\n\nuse crate::domain::Task;\n\npub trait NotificationService: Send + Sync {\n    async fn send_task_event(&self, task: &Task, event: TaskEvent) -> Result<(), NotificationError>;\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum NotificationError {\n    #[error(\"Failed to send notification\")]\n    SendFailed(String),\n}\n\n#[derive(Debug)]\npub enum TaskEvent {\n    Activated,\n    Blocked(String),\n    Completed,\n    Archived,\n}\n```\n\n---\n\n### 3. Application Layer (Use Cases)\n\n```rust\n// application/use_cases.rs\n\nuse super::ports::{TaskRepository, NotificationService};\nuse crate::domain::{Task, Priority, Status, TaskEvent, DomainError};\n\npub struct CreateTaskUseCase {\n    repo: Box<dyn TaskRepository>,\n    notifier: Box<dyn NotificationService>,\n}\n\nimpl CreateTaskUseCase {\n    pub fn new(repo: Box<dyn TaskRepository>, notifier: Box<dyn NotificationService>) -> Self {\n        Self { repo, notifier }\n    }\n\n    pub async fn execute(\n        &self,\n        title: String,\n        description: String,\n        priority: Priority,\n        assignee_email: String,\n        due_date: Option<chrono::DateTime<chrono::Utc>>,\n    ) -> Result<Task, ApplicationError> {\n        let task = Task::new(\n            uuid::Uuid::new_v4().to_string(),\n            title,\n            description,\n            priority,\n            assignee_email,\n            due_date.map(|d| d.into()),\n        );\n\n        self.repo.save(&task).await.map_err(Into::into)?;\n        \n        // Fire and forget notification\n        let _ = self.notifier.send_task_event(&task, TaskEvent::Activated).await;\n        \n        Ok(task)\n    }\n}\n\npub struct ActivateTaskUseCase {\n    repo: Box<dyn TaskRepository>,\n    notifier: Box<dyn NotificationService>,\n}\n\nimpl ActivateTaskUseCase {\n    pub async fn execute(&self, task_id: String) -> Result<Task, ApplicationError> {\n        let mut task = self.repo.find(&task_id).await?.ok_or(ApplicationError::NotFound)?;\n        \n        // Pure Logic\n        task.transition_to(Status::Active)?;\n        \n        // Persistence\n        self.repo.save(&task).await.map_err(Into::into)?;\n        \n        // Side Effect (Non-blocking)\n        let _ = self.notifier.send_task_event(&task, TaskEvent::Activated).await;\n        \n        Ok(task)\n    }\n}\n\n// ... BlockTask, CompleteTask, ArchiveTask use cases follow same pattern ...\n\n#[derive(Debug, thiserror::Error)]\npub enum ApplicationError {\n    #[error(\"Task not found\")]\n    NotFound,\n    #[error(\"Domain error: {0}\")]\n    DomainError(#[from] DomainError),\n    #[error(\"Repository error: {0}\")]\n    RepositoryError(#[from] RepositoryError),\n}\n```\n\n---\n\n### 4. API Contract (Input Adapter)\n\n```rust\n// adapter/api.rs\n\nuse rocket::Route;\nuse rocket::serde::{json::Json, Deserialize};\n\n#[derive(Deserialize)]\npub struct CreateTaskRequest {\n    pub title: String,\n    pub description: String,\n    pub priority: String, // low, medium, high\n    pub assignee_email: String,\n    pub due_date: Option<String>, // ISO 8601\n}\n\n#[derive(Deserialize)]\npub struct TaskFilterRequest {\n    pub status: Option<String>,\n    pub assignee: Option<String>,\n    pub priority: Option<String>,\n}\n\npub fn routes() -> Vec<Route> {\n    routes![create_task, activate_task, list_tasks]\n}\n\n#[post(\"/\", format = \"json\", data = \"<data>\")]\nasync fn create_task(data: Json<CreateTaskRequest>) -> Json<TaskResponse> {\n    // Wiring logic would go here (Instantiate Use Case, Transform Request, Execute)\n    Json(TaskResponse { id: \"123\".to_string() })\n}\n\n#[post(\"/<task_id>/activate\")]\nasync fn activate_task(task_id: String) -> Json<TaskResponse> {\n    // Wiring logic\n    Json(TaskResponse { id: task_id })\n}\n\n#[get(\"/\", format = \"json\", data = \"<filters>\")]\nasync fn list_tasks(filters: Option<Json<TaskFilterRequest>>) -> Json<Vec<TaskResponse>> {\n    // Wiring logic\n    Json(vec![])\n}\n\n#[derive(serde::Serialize)]\npub struct TaskResponse {\n    pub id: String,\n    pub title: String,\n    pub status: String,\n}\n```\n\n---\n\n### 5. Test Cases\n\nHere are focused tests covering the requirements.\n\n**Test 1: Status Transitions & Invariants**\n*Tests that illegal transitions fail and transitions respect the lifecycle.*\n\n```rust\n#[cfg(test)]\nmod domain_tests {\n    use super::*;\n\n    #[test]\n    fn test_valid_status_transitions() {\n        let mut task = Task::new(\"1\".into(), \"Test\".into(), \"Desc\".into(), Priority::High, \"me@example.com\".into(), None);\n        \n        // Draft -> Active\n        task.transition_to(Status::Active).unwrap();\n        assert_eq!(task.status, Status::Active);\n\n        // Active -> Blocked\n        task.transition_to(Status::Blocked).unwrap();\n        assert_eq!(task.status, Status::Blocked);\n\n        // Blocked -> Active\n        task.transition_to(Status::Active).unwrap();\n        \n        // Active -> Done (requires checklist)\n        task.add_checklist_item(\"Item 1\".into());\n        task.complete_checklist_item(\"uuid1\").unwrap();\n        task.transition_to(Status::Done).unwrap();\n        assert_eq!(task.status, Status::Done);\n\n        // Done -> Archived\n        task.transition_to(Status::Archived).unwrap();\n    }\n\n    #[test]\n    fn test_invalid_status_transitions() {\n        let mut task = Task::new(\"1\".into(), \"Test\".into(), \"Desc\".into(), Priority::High, \"me@example.com\".into(), None);\n\n        // Draft -> Blocked (Illegal)\n        let res = task.transition_to(Status::Blocked);\n        assert!(res.is_err());\n\n        // Archived -> Done (Illegal)\n        task.status = Status::Archived;\n        let res = task.transition_to(Status::Done);\n        assert!(res.is_err());\n    }\n}\n```\n\n**Test 2: Overdue Logic**\n*Tests the time-sensitive business rule based on priority.*\n\n```rust\n#[cfg(test)]\nmod overdue_tests {\n    use super::*;\n    use std::time::{SystemTime, UNIX_EPOCH};\n\n    #[test]\n    fn test_high_priority_overdue_24h() {\n        let mut task = Task::new(\"1\".into(), \"Test\".into(), \"Desc\".into(), Priority::High, \"me@example.com\".into(), None);\n        \n        // Set due date to 25 hours ago\n        let old_time = UNIX_EPOCH - Duration::from_secs(25 * 3600);\n        task.due_date = Some(old_time);\n\n        assert!(task.is_overdue());\n    }\n\n    #[test]\n    fn test_medium_priority_not_overdue_30h() {\n        let mut task = Task::new(\"1\".into(), \"Test\".into(), \"Desc\".into(), Priority::Medium, \"me@example.com\".into(), None);\n        \n        // Set due date to 30 hours ago\n        let old_time = UNIX_EPOCH - Duration::from_secs(30 * 3600);\n        task.due_date = Some(old_time);\n\n        assert!(!task.is_overdue());\n    }\n\n    #[test]\n    fn test_task_not_overdue_if_not_active() {\n        let mut task = Task::new(\"1\".into(), \"Test\".into(), \"Desc\".into(), Priority::High, \"me@example.com\".into(), None);\n        task.status = Status::Done;\n        \n        // Set due date to 25 hours ago\n        let old_time = UNIX_EPOCH - Duration::from_secs(25 * 3600);\n        task.due_date = Some(old_time);\n\n        assert!(!task.is_overdue());\n    }\n}\n```\n\n**Test 3: Reliability & Notification Failure**\n*Tests that notification failure does not block the task update.*\n\n```rust\n#[cfg(test)]\nmod reliability_tests {\n    use super::*;\n    use mockall::mock;\n\n    mock! {\n        NotificationService {}\n        #[async_trait::async_trait]\n        impl NotificationService for NotificationService {\n            async fn send_task_event(&self, task: &Task, event: TaskEvent) -> Result<(), NotificationError>;\n        }\n    }\n\n    #[tokio::test]\n    async fn test_notification_failure_does_not_fail_update() {\n        // Setup\n        let mut mock_repo = MockTaskRepository::new();\n        let mut mock_notify = MockNotificationService::new();\n        \n        // Mock Repo: Save succeeds\n        mock_repo.expect_save().times(1).returning(|_| Ok(()));\n        \n        // Mock Repo: Find returns existing task\n        let mut task = Task::new(\"1\".into(), \"Test\".into(), \"Desc\".into(), Priority::High, \"me@example.com\".into(), None);\n        task.transition_to(Status::Active).unwrap();\n        mock_repo.expect_find().returning(|_| Ok(Some(task)));\n\n        // Mock Notify: Fail on activation\n        mock_notify.expect_send_task_event()\n            .times(1)\n            .returning(|_, _| Err(NotificationError::SendFailed(\"Mailbox full\".into())));\n\n        // Execution\n        let use_case = ActivateTaskUseCase {\n            repo: Box::new(mock_repo),\n            notifier: Box::new(mock_notify),\n        };\n        \n        let result = use_case.execute(\"1\".into()).await;\n        \n        // Assert: Task should be updated successfully despite notification failure\n        assert!(result.is_ok());\n    }\n}\n```"
            },
            {
              "name": "legacy_refactor_all_principles",
              "input": "A legacy task service has become hard to maintain. Teams report frequent regressions, unclear failures, and inconsistent behavior between environments.\n\nCurrent behavior problems:\n- State changes occasionally skip required steps.\n- Some responses are ambiguous (callers cannot tell what failed).\n- Resource usage grows during long-running operation.\n- Business rules are difficult to change without side effects.\n- Different parts of the system produce different names for the same concept.\n\nRequest:\n- Propose a concrete refactor plan that can be delivered incrementally.\n- Include clear milestones, rollback strategy, and success criteria.\n- Show representative before/after examples for: state transition logic, failure handling, and naming consistency.\n- Keep the plan compact but actionable for a team of 10 engineers.",
              "expected": {
                "focus": "Does the plan concretely separate domain/core from adapters, remove illegal states, enforce one-way data flow and explicit dependencies, replace generic exceptions with typed errors, and improve naming to reflect responsibility?"
              },
              "baseline_response": "### Refactor Strategy: \"Model-First Modernization\"\n\n**Goal:** Move from an implicit, tightly coupled system to an explicit, testable, and bounded domain model.\n\n**Team Size Context:** With 10 engineers, this can be parallelized into 2 pods (5 devs each), or broken down into 3-week sprints.\n\n---\n\n### Phase 1: Stabilization & Visibility (Weeks 1\u20133)\n**Focus:** Eliminate ambiguity and naming inconsistencies to stop confusion.\n\n1.  **Define the Canonical Domain Model (DDoE):** Create a single source of truth for data structures and enums. Rename all legacy fields to match this model.\n2.  **Standardize API Responses:** Implement a strict error code framework (e.g., `TaskServiceError` enum) so callers can programmatically handle failures.\n3.  **Instrumentation:** Add structured logging to every state transition.\n\n*   **Action Item:** A \"No New Features\" sprint focused solely on code cleanup and schema alignment.\n\n### Phase 2: Logic Guardrails (Weeks 4\u20136)\n**Focus:** Fix state transition logic to prevent \"skipping steps.\"\n\n1.  **Implement Strict State Machine:** Replace imperative `if/else` logic with a finite state machine (FSM) library or class. Disallow illegal transitions via exceptions.\n2.  **Unit Test Coverage:** Ensure the state machine is 100% covered.\n3.  **Review Dependencies:** Audit third-party libraries for the Task Service to prevent external regressions.\n\n*   **Action Item:** A \"Bug Bash\" and State Machine implementation sprint.\n\n### Phase 3: Architecture & Resource Management (Weeks 7\u20139)\n**Focus:** Fix business rule rigidity and memory leaks.\n\n1.  **Strategy Pattern for Rules:** Extract business logic (e.g., \"Credit Check,\" \"Inventory Validation\") into separate strategy classes. This allows changing rules without touching the core task flow.\n2.  **Resource Pooling:** Implement connection pooling for external API calls to fix resource growth.\n3.  **Health Checks:** Add automated resource utilization monitoring (memory, CPU, thread pool depth).\n\n*   **Action Item:** Refactor core service classes and infrastructure setup.\n\n---\n\n### Rollback Strategy\nSince this is incremental, rollback is low risk.\n\n1.  **Feature Flags:** Deploy the refactor behind a feature flag. Only toggle it on once fully tested in a \"Canary\" environment.\n2.  **Branch Protection:** Keep the old `main` branch stable. If Phase 3 breaks performance, revert the flag immediately.\n3.  **Database Migration:** Ensure any schema changes are reversible (using transactions and rollback scripts) or deployed as \"append-only\" columns to preserve legacy data.\n\n### Success Criteria\n*   **State Transitions:** Zero \"Illegal State\" exceptions in logs for valid user inputs.\n*   **Error Handling:** 0% \"Unknown Error\" or generic `500` responses for known failure modes.\n*   **Resource Usage:** Memory usage is stable (flat line) over 24 hours, rather than growing linearly.\n*   **Tests:** >80% unit test coverage for the Domain Logic.\n\n---\n\n### Representative Before/After Examples\n\n#### 1. State Transition Logic\n**Problem:** Implicit state changes allow skipping validation.\n**Solution:** Explicit State Machine with guards.\n\n**BEFORE (Implicit/Spaghetti):**\n```javascript\n// The old code allows a direct jump from Pending to Completed, skipping Processing.\nfunction updateStatus(taskId, newStatus) {\n  const task = getTask(taskId);\n  if (task.status === 'PENDING') {\n    task.status = newStatus; // If newStatus is 'COMPLETED', validation is missed!\n  }\n  save(task);\n}\n```\n\n**AFTER (Explicit/State Machine):**\n```javascript\n// The new code throws an exception if the transition is invalid.\nclass TaskStateMachine {\n  static transition(task, newStatus) {\n    if (!this.isValidTransition(task.status, newStatus)) {\n      throw new InvalidStateTransitionError(\n        `Cannot move from ${task.status} to ${newStatus}`\n      );\n    }\n    task.status = newStatus;\n  }\n}\n// Validates that 'PENDING' -> 'COMPLETED' is invalid. Requires 'PROCESSING' first.\n```\n\n#### 2. Failure Handling\n**Problem:** Callers cannot tell what failed.\n**Solution:** Structured Error Codes.\n\n**BEFORE (Ambiguous):**\n```java\n// API Response\n{\n  \"status\": \"error\",\n  \"message\": \"Something went wrong with the backend.\"\n}\n// Caller: \"Was it the database? The network? The user?\"\n```\n\n**AFTER (Explicit):**\n```java\n// API Response\n{\n  \"status\": \"error\",\n  \"errorCode\": \"INSUFFICIENT_FUNDS\",\n  \"message\": \"The task requires more credit, please top up.\",\n  \"retries\": 3\n}\n// Caller: \"Okay, I will check the user's balance and retry.\"\n```\n\n#### 3. Naming Consistency\n**Problem:** Different services refer to the same thing differently.\n**Solution:** Canonical Domain Enum.\n\n**BEFORE (Inconsistent):**\n*   Service A: `task.status`\n*   Service B: `order.state`\n*   Database: `TASK_STATUS_CD`\n*   Logs: `taskState`\n\n**AFTER (Consistent):**\n```java\n// A single Enum used everywhere\npublic enum TaskStatus {\n  CREATED,\n  IN_PROGRESS,\n  COMPLETED,\n  FAILED\n}\n\n// Usage (Language agnostic)\ntask.status == TaskStatus.IN_PROGRESS;\n```\n\n### Immediate Next Step\n1.  **Identify the \"Canonical Model\":** Have the team agree on the single source of truth for data types and state definitions.\n2.  **Create the \"Test\":** Write a unit test that proves the old code allows illegal state transitions, proving the need for the refactor.",
              "skill_response": "Based on the **Architecture Core** skill provided, the legacy task service must be refactored to eliminate state inconsistency, resource leaks, and ambiguous errors by enforcing explicit invariants and separating pure domain logic from effectful interactions.\n\nHere is the proposed incremental refactor plan.\n\n### Refactor Strategy: Clean Architecture Application\n\nWe will adopt a **Ports and Adapters** approach. The core will be purified (domain types + state machine), while the application orchestrates logic and side effects.\n\n### The Incremental Plan (4 Weeks)\n\n**Phase 1: State Model & Invariant Definition (Week 1)**\n*   **Goal:** Fix \"state skipping\" and resource growth.\n*   **Action:** Define an `enum` for the `TaskState` with strict `match` exhaustiveness. Implement a \"State Guard\" in the core that rejects illegal transitions.\n*   **Team Task:** Analyze current codebase to extract state flags (e.g., `isRunning`, `isCompleted`). Replace boolean flags with a single enum.\n*   **Rollback:** Feature flag `legacy-state-mode` (off by default) to revert to original state machine behavior if state transitions fail.\n\n**Phase 2: Pure Core Implementation (Week 2)**\n*   **Goal:** Fix \"business rules difficult to change\" and \"inconsistent naming.\"\n*   **Action:** Move all domain logic to the `Core` layer. Ensure no DB/API imports exist here. Define explicit **Ports** (interfaces) for `TaskRepository` and `Notifier`.\n*   **Team Task:** Team splits into \"Business Logic\" (validating rules) and \"Naming Consistency\" (standardizing verb/object usage).\n\n**Phase 3: Effectful Boundaries & Resource Management (Week 3)**\n*   **Goal:** Fix \"resource usage growth\" and \"ambiguous failures.\"\n*   **Action:** Implement the Application layer. Use `Result` types for explicit errors. Implement a `ResourcePool` adapter to handle long-running operation cleanup (RAII pattern).\n*   **Team Task:** Wire the adapters. Add `LogHandler` and `MetricsCollector` as transparent dependencies to monitor resource leaks.\n\n**Phase 4: Adapters & Verification (Week 4)**\n*   **Goal:** Stabilize integration.\n*   **Action:** Clean up HTTP/API adapters. Ensure they only handle protocol details (JSON, HTTP codes). Write the 3-5 focused tests defined in the Output Contract.\n\n---\n\n### Representative Before/After Examples\n\n#### 1. State Transition Logic (Fixing Skipped Steps)\n**Problem:** State changes are conditional and implicit; skipping a step is easy.\n\n**Before:**\n```java\n// Anti-Pattern: Implicit logic, mutable state, no enforcement\npublic void runTask() {\n    if (this.status == \"pending\") {\n        this.status = \"running\";\n        this.startTime = now();\n        startBackgroundWork();\n    }\n    // Logic gaps allow status to remain \"pending\" or jump to \"finished\"\n}\n```\n\n**After (Architecture Core):**\n```rust\n// Explicit state + invariants\n#[derive(Debug, PartialEq)]\nenum TaskState {\n    Draft,\n    InProgress { started_at: DateTime },\n    Completed { finished_at: DateTime },\n    Failed { error: String },\n}\n\nimpl Task {\n    // Deterministic transitions\n    fn attempt_start(&mut self) -> Result<(), TransitionError> {\n        match self.state {\n            TaskState::Draft => {\n                self.state = TaskState::InProgress { started_at: Utc::now() };\n                Ok(())\n            },\n            _ => Err(TransitionError::InvalidState(\"Must be Draft\".into()))\n        }\n    }\n}\n```\n\n#### 2. Failure Handling (Fixing Ambiguous Failures)\n**Problem:** Callers cannot tell what failed; generic exceptions are thrown.\n\n**Before:**\n```java\n// Anti-Pattern: Generic exception, lossy error info\npublic void execute() {\n    try {\n        // ... complex logic\n        db.save(result);\n    } catch (Exception e) {\n        throw new RuntimeException(\"Operation failed\"); // Caller has no clue why\n    }\n}\n```\n\n**After (Architecture Core):**\n```rust\n// Explicit typed errors + domain intent naming\n#[derive(Debug)]\nenum TaskOutcome {\n    Success,\n    InvalidInput,\n    DependencyUnavailable,\n    ResourceExhausted,\n}\n\nimpl TaskService {\n    fn execute(&self, input: Input) -> Result<TaskOutcome, TaskError> {\n        if input.is_empty() {\n            return Err(TaskError::InvalidInput);\n        }\n        // ...\n        Ok(TaskOutcome::Success)\n    }\n}\n```\n\n#### 3. Naming Consistency (Fixing \"Different names for same concept\")\n**Problem:** Logic uses `start`, `begin`, `run`; external uses `init`, `process`, `fire`.\n\n**Before:**\n*   Core: `startWork()`\n*   API: `initTask()`\n*   Database: `processRecord()`\n\n**After (Domain-Intent Naming):**\n*   Unified terminology: `Start`, `Complete`, `Cancel`, `Retrieve`.\n*   All layers use these verbs. The interface definitions (Ports) act as the translation layer if external systems strictly require old nomenclature.\n\n---\n\n### Success Criteria & Verification\n\n1.  **Type Safety:** All state changes must go through the explicit `TaskState` enum match.\n2.  **Test Coverage:** 3-5 focused tests pass:\n    *   Valid transition logic.\n    *   Transition rejection (invariant violation).\n    *   Error boundary conditions.\n3.  **Resource Lifecycle:** No memory leaks observed during long-running operation (verified via profiling).\n4.  **Error Visibility:** `TaskOutcome` is returned instead of generic exceptions; logs show `TaskError::DependencyUnavailable` specifically.\n5.  **Architecture Check:** Domain layer contains zero imports from Framework/ORM layers."
            }
          ]
        }
      ]
    }
  ],
  "summary": {
    "total_benchmarks": 1,
    "leaderboard": [
      {
        "model": "glm-4.7-flash:q4_K_M",
        "provider": "ollama",
        "total_tested": 1,
        "improvements": 1,
        "improvement_rate": 100.0
      }
    ]
  },
  "unique_skills": [
    "ps-architecture-core"
  ],
  "provider_models": [
    [
      "ollama",
      "glm-4.7-flash:q4_K_M"
    ]
  ]
}