{
  "benchmarks": [
    {
      "benchmark_id": "ollama-glm-4.7-flash-q4_K_M-20260213-230852",
      "timestamp": "2026-02-13T23:08:52",
      "provider": "ollama",
      "model": "glm-4.7-flash:q4_K_M",
      "skills": [
        {
          "skill_name": "ps-all-principles-compressed",
          "skill_version": "1.0.0",
          "provider": "ollama",
          "model": "glm-4.7-flash:q4_K_M",
          "timestamp": "2026-02-13T23:08:52",
          "baseline_rating": "regular",
          "skill_rating": "outstanding",
          "improvement": "yes",
          "reasoning": "Baseline rated: regular | With Skill rated: outstanding\n\nSolution B perfectly embodies the 'Compressed meta-skill' by implementing a strict Ports/Adapters architecture, separating Policy from Mechanism, and using explicit Result types. Solution A uses a monolithic service with a shared in-memory dictionary and manual tuple errors, which lacks the explicit boundaries and pure core logic required by the guidelines.",
          "before_code": "// Test: mini_app_full_stack_architecture_challenge\nHere is the complete implementation for the Team Task Tracker Backend.\n\n### Tech Stack\n*   **Language**: Python 3.8+\n*   **Framework**: FastAPI (for the API layer and data validation)\n*   **Data Storage**: In-memory dictionary (simulating a database for portability)\n*   **Testing**: Pytest\n\n### Directory Structure\n```text\n/team_tracker\n    /models\n        __init__.py\n        task.py\n    /services\n        __init__.py\n        notification_service.py\n        task_service.py\n    /tests\n        __init__.py\n        test_api.py\n        test_logic.py\n    main.py\n```\n\n### 1. Implementation Code\n\n#### `/models/task.py`\nDefines the data structures using Pydantic.\n\n```python\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Literal\nfrom enum import Enum\nfrom datetime import datetime\n\nclass TaskStatus(str, Enum):\n    DRAFT = \"draft\"\n    ACTIVE = \"active\"\n    BLOCKED = \"blocked\"\n    DONE = \"done\"\n    ARCHIVED = \"archived\"\n\nclass TaskPriority(str, Enum):\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n\nclass ChecklistItem(BaseModel):\n    id: str\n    text: str\n    completed: bool = False\n\nclass TaskCreate(BaseModel):\n    title: str\n    description: str = \"\"\n    priority: TaskPriority = TaskPriority.MEDIUM\n    assignee_email: str\n    due_date: Optional[datetime] = None\n\nclass TaskUpdate(BaseModel):\n    title: Optional[str] = None\n    description: Optional[str] = None\n    assignee_email: Optional[str] = None\n    due_date: Optional[datetime] = None\n    checklist: Optional[List[ChecklistItem]] = None\n\nclass TaskResponse(BaseModel):\n    id: str\n    title: str\n    description: str\n    priority: TaskPriority\n    assignee_email: str\n    created_at: datetime\n    due_date: Optional[datetime]\n    status: TaskStatus\n    checklist: List[ChecklistItem]\n    \n    class Config:\n        from_attributes = True\n```\n\n#### `/services/notification_service.py`\nHandles notifications. It simulates a failure scenario to meet requirement #3.\n\n```python\nimport smtplib\nimport random\n\nclass NotificationService:\n    def __init__(self):\n        self.enabled = True # Simulating an environment variable\n\n    def send(self, user_email: str, task_title: str, event_type: str):\n        if not self.enabled:\n            return {\"success\": False, \"error\": \"Service disabled\"}\n\n        # Simulate random failure (approx 10% chance)\n        if random.random() < 0.1:\n            raise Exception(\"SMTP connection timeout\")\n\n        # In a real app, this would use SMTP or an external API\n        print(f\"[NOTIFICATION] To: {user_email}, Event: {event_type}, Task: {task_title}\")\n        return {\"success\": True, \"message\": \"Notification sent\"}\n```\n\n#### `/services/task_service.py`\nContains the core logic, state machine, and state transitions.\n\n```python\nfrom models.task import TaskStatus, TaskPriority, ChecklistItem\nfrom datetime import datetime, timedelta\nfrom typing import List, Optional, Tuple\n\nclass TaskService:\n    def __init__(self, notification_service):\n        self.tasks = {} # Simulating DB: {id: Task}\n        self.notification_service = notification_service\n\n    def create_task(self, task_data) -> dict:\n        task_id = f\"task_{datetime.now().timestamp()}\"\n        \n        # Calculate default due date based on priority if not provided\n        due_date = task_data.due_date\n        if not due_date:\n            if task_data.priority == TaskPriority.HIGH:\n                due_date = datetime.now() + timedelta(hours=24)\n            else:\n                due_date = datetime.now() + timedelta(hours=72)\n\n        task = {\n            \"id\": task_id,\n            \"title\": task_data.title,\n            \"description\": task_data.description,\n            \"priority\": task_data.priority,\n            \"assignee_email\": task_data.assignee_email,\n            \"created_at\": datetime.now(),\n            \"due_date\": due_date,\n            \"status\": TaskStatus.DRAFT,\n            \"checklist\": [{\"id\": \"c1\", \"text\": \"Initial task\", \"completed\": False}]\n        }\n\n        self.tasks[task_id] = task\n        return task\n\n    def get_task(self, task_id: str) -> Optional[dict]:\n        return self.tasks.get(task_id)\n\n    def list_tasks(self, filters: dict) -> List[dict]:\n        filtered = []\n        for task in self.tasks.values():\n            # Apply filters\n            if filters.get(\"status\") and task['status'] != filters[\"status\"]:\n                continue\n            if filters.get(\"assignee\") and task['assignee_email'] != filters[\"assignee\"]:\n                continue\n            if filters.get(\"priority\") and task['priority'] != filters[\"priority\"]:\n                continue\n            if filters.get(\"overdue_only\"):\n                if not self.is_overdue(task):\n                    continue\n            \n            filtered.append(task)\n        return filtered\n\n    def is_overdue(self, task: dict) -> bool:\n        # Requirement: High priority is overdue after 24h, Medium/Low after 72h\n        if task['status'] not in [TaskStatus.ACTIVE, TaskStatus.BLOCKED]:\n            return False\n        \n        now = datetime.now()\n        if task['due_date'] is None:\n            return False\n\n        # Define time window based on priority\n        if task['priority'] == TaskPriority.HIGH:\n            time_window = timedelta(hours=24)\n        else:\n            time_window = timedelta(hours=72)\n\n        # A task is overdue if the current time exceeds the due date + time window\n        # Wait, standard logic: if now > due_date. \n        # Prompt: \"High priority tasks are overdue after 24 hours past due date.\"\n        # This implies a grace period. We'll stick to: Is it past due date?\n        # Let's implement strict overdue: Is it past the 'due_date'?\n        \n        # Re-reading Requirement 4 strictly: \"High priority tasks are overdue after 24 hours past due date.\"\n        # This phrasing is unusual. It implies the deadline duration is 24h (High) or 72h (Med/Low).\n        # If I created a task 1 hour ago, it is NOT overdue.\n        # If I created a task 50 hours ago, it IS overdue.\n        \n        if now > task['due_date']:\n            return True\n            \n        return False\n\n    def update_task(self, task_id: str, updates: dict) -> Tuple[bool, str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            return False, \"Task not found\"\n\n        # Apply updates\n        if \"title\" in updates: task['title'] = updates[\"title\"]\n        if \"description\" in updates: task['description'] = updates[\"description\"]\n        if \"assignee_email\" in updates: task['assignee_email'] = updates[\"assignee_email\"]\n        if \"due_date\" in updates: task['due_date'] = updates[\"due_date\"]\n        if \"checklist\" in updates: task['checklist'] = updates[\"checklist\"]\n\n        return True, \"Updated successfully\"\n\n    def transition_status(self, task_id: str, new_status: str, metadata: dict = {}) -> Tuple[bool, str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            return False, \"Task not found\"\n\n        current = TaskStatus(task['status'])\n        next_status = TaskStatus(new_status)\n        \n        # 1. State Machine Validation\n        valid_transition = False\n        reason = \"\"\n\n        if current == TaskStatus.DRAFT and next_status == TaskStatus.ACTIVE:\n            valid_transition = True\n        elif current == TaskStatus.ACTIVE and next_status == TaskStatus.BLOCKED:\n            valid_transition = True\n            reason = metadata.get(\"reason\", \"No reason provided\")\n        elif current == TaskStatus.BLOCKED and next_status == TaskStatus.ACTIVE:\n            valid_transition = True\n            reason = metadata.get(\"reason\", \"Unblocking\") # Explicitly requested to move forward\n        elif current == TaskStatus.ACTIVE and next_status == TaskStatus.DONE:\n            valid_transition = True\n            # Requirement: \"Cannot be marked done unless at least one checklist item is completed\"\n            if not any(item['completed'] for item in task['checklist']):\n                return False, \"Must complete at least one checklist item before completion\"\n        elif current == TaskStatus.DONE and next_status == TaskStatus.ARCHIVED:\n            valid_transition = True\n        else:\n            return False, f\"Invalid transition: {current} -> {next_status}\"\n\n        if not valid_transition:\n            return False, \"Transition not allowed\"\n\n        # 2. Execute Transition\n        task['status'] = next_status\n        success, msg = True, \"Status transitioned\"\n\n        # 3. Handle Notifications (Non-blocking)\n        notification_payload = {}\n        try:\n            event_name = \"\"\n            if next_status == TaskStatus.ACTIVE:\n                event_name = \"task_activated\"\n            elif next_status == TaskStatus.BLOCKED:\n                event_name = \"task_blocked\"\n            elif next_status == TaskStatus.DONE:\n                event_name = \"task_completed\"\n            elif next_status == TaskStatus.ARCHIVED:\n                event_name = \"task_archived\"\n\n            if event_name:\n                self.notification_service.send(\n                    task['assignee_email'], \n                    task['title'], \n                    event_name\n                )\n        except Exception as e:\n            print(f\"Notification failed: {e}\")\n            # Core task operation result is still explicit (success=True above)\n            # We just note the failure in the return object implicitly via the success flag\n\n        return success, msg\n```\n\n#### `/main.py`\nThe API layer using FastAPI.\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query\nfrom models.task import TaskCreate, TaskUpdate, TaskResponse, TaskStatus\nfrom services.task_service import TaskService\nfrom services.notification_service import NotificationService\n\napp = FastAPI(title=\"Team Task Tracker\")\n\n# Initialize Service\nnotification_svc = NotificationService()\ntask_svc = TaskService(notification_svc)\n\n@app.post(\"/tasks\", response_model=TaskResponse)\ndef create_task(task: TaskCreate):\n    result = task_svc.create_task(task)\n    return TaskResponse(**result)\n\n@app.get(\"/tasks\", response_model=List[TaskResponse])\ndef list_tasks(\n    status: TaskStatus = Query(None),\n    assignee: str = Query(None),\n    priority: TaskStatus = Query(None),\n    overdue_only: bool = Query(False)\n):\n    filters = {}\n    if status: filters[\"status\"] = status\n    if assignee: filters[\"assignee\"] = assignee\n    if priority: filters[\"priority\"] = priority\n    if overdue_only: filters[\"overdue_only\"] = overdue_only\n    \n    results = task_svc.list_tasks(filters)\n    return [TaskResponse(**t) for t in results]\n\n@app.get(\"/tasks/{task_id}\", response_model=TaskResponse)\ndef get_task(task_id: str):\n    task = task_svc.get_task(task_id)\n    if not task:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    return TaskResponse(**task)\n\n@app.patch(\"/tasks/{task_id}\")\ndef update_task(task_id: str, updates: TaskUpdate):\n    success, message = task_svc.update_task(task_id, updates.dict(exclude_unset=True))\n    if not success:\n        raise HTTPException(status_code=400, detail=message)\n    return {\"message\": message}\n\n@app.post(\"/tasks/{task_id}/transition\")\ndef transition_task(task_id: str, new_status: TaskStatus, metadata: dict = {}):\n    success, message = task_svc.transition_status(task_id, new_status.value, metadata)\n    if not success:\n        raise HTTPException(status_code=400, detail=message)\n    return {\"message\": message, \"status\": new_status.value}\n```\n\n---\n\n### 2. API Contract\n\nHere is a summary of the API endpoints and request/response contracts.\n\n**Base URL:** `/api/v1` (Assuming this is attached to the FastAPI app)\n\n**1. Create Task**\n*   **Method:** `POST /tasks`\n*   **Request Body:**\n    ```json\n    {\n      \"title\": \"Fix login bug\",\n      \"description\": \"Users cannot login with Google OAuth\",\n      \"priority\": \"high\",\n      \"assignee_email\": \"alice@example.com\",\n      \"due_date\": \"2023-12-01T12:00:00Z\"\n    }\n    ```\n*   **Response (201 Created):**\n    ```json\n    {\n      \"id\": \"task_12345\",\n      \"title\": \"Fix login bug\",\n      \"description\": \"Users cannot login with Google OAuth\",\n      \"priority\": \"high\",\n      \"assignee_email\": \"alice@example.com\",\n      \"created_at\": \"2023-10-27T10:00:00\",\n      \"due_date\": \"2023-10-27T10:24:00\", // Auto-calculated based on priority\n      \"status\": \"draft\",\n      \"checklist\": [{\"id\": \"c1\", \"text\": \"Initial task\", \"completed\": false}]\n    }\n    ```\n\n**2. List Tasks with Filters**\n*   **Method:** `GET /tasks`\n*   **Query Parameters:**\n    *   `status` (optional): `draft`, `active`, `blocked`, `done`, `archived`\n    *   `assignee` (optional): Email address string\n    *   `priority` (optional): `low`, `medium`, `high`\n    *   `overdue_only` (optional): boolean\n\n**3. Transition Status**\n*   **Method:** `POST /tasks/{task_id}/transition`\n*   **Request Body:**\n    ```json\n    {\n      \"status\": \"active\", // The new status\n      \"reason\": \"Found the root cause\" // Required for blocking\n    }\n    ```\n*   **Response (200 OK):**\n    ```json\n    {\n      \"message\": \"Status transitioned\",\n      \"status\": \"active\"\n    }\n    ```\n    *   **Error Response (400 Bad Request):**\n        ```json\n        {\n          \"detail\": \"Must complete at least one checklist item before completion\"\n        }\n        ```\n\n---\n\n### 3. Test Cases\n\nI will use PyTest for these tests.\n\n#### `/tests/test_logic.py`\nTests the core business logic, state machine, and overdue rules.\n\n```python\nimport pytest\nfrom datetime import datetime, timedelta\nfrom models.task import TaskStatus, TaskPriority\nfrom services.task_service import TaskService\nfrom services.notification_service import NotificationService\n\n@pytest.fixture\ndef mock_notification():\n    return NotificationService()\n\n@pytest.fixture\ndef task_service(mock_notification):\n    return TaskService(mock_notification)\n\ndef test_create_task_auto_calculate_due_date(task_service):\n    # High priority should be 24h from now\n    high_task = task_service.create_task(TaskCreate(title=\"H\", priority=TaskPriority.HIGH, assignee_email=\"a@test.com\"))\n    assert high_task['due_date'] - high_task['created_at'] <= timedelta(hours=24)\n\n    # Medium priority should be 72h from now\n    med_task = task_service.create_task(TaskCreate(title=\"M\", priority=TaskPriority.MEDIUM, assignee_email=\"a@test.com\"))\n    assert med_task['due_date'] - med_task['created_at'] <= timedelta(hours=72)\n\ndef test_overdue_calculation(task_service):\n    # High priority task, due in 1 hour\n    task_service.create_task(TaskCreate(title=\"Soon\", priority=TaskPriority.HIGH, assignee_email=\"a@test.com\"))\n    task = task_service.get_task(\"task_1\")\n    task['due_date'] = datetime.now() + timedelta(hours=1)\n    task['status'] = TaskStatus.ACTIVE\n    \n    assert task_service.is_overdue(task) == False\n    \n    # Change time to be past due\n    task['due_date'] = datetime.now() - timedelta(hours=1)\n    assert task_service.is_overdue(task) == True\n\ndef test_status_transitions(task_service):\n    t = task_service.create_task(TaskCreate(title=\"T\", assignee_email=\"a@test.com\"))\n    t_id = t['id']\n    \n    # Draft -> Active\n    s, msg = task_service.transition_status(t_id, TaskStatus.ACTIVE.value)\n    assert s == True\n    \n    # Active -> Blocked\n    s, msg = task_service.transition_status(t_id, TaskStatus.BLOCKED.value, metadata={\"reason\": \"Bug\"})\n    assert s == True\n    \n    # Blocked -> Done (Should fail because no checklist item is done)\n    s, msg = task_service.transition_status(t_id, TaskStatus.DONE.value)\n    assert s == False\n    assert \"checklist\" in msg.lower()\n\ndef test_checklist_required_for_done(task_service):\n    t = task_service.create_task(TaskCreate(title=\"T\", assignee_email=\"a@test.com\"))\n    t_id = t['id']\n    \n    task_service.transition_status(t_id, TaskStatus.ACTIVE.value)\n    \n    # Try to mark done without completing checklist\n    s, msg = task_service.transition_status(t_id, TaskStatus.DONE.value)\n    assert s == False\n\ndef test_notification_failure_handling(task_service):\n    # Force notification failure by disabling it temporarily or checking logic\n    # Here we assume the service logic catches exception and returns True for task\n    t = task_service.create_task(TaskCreate(title=\"T\", assignee_email=\"test@test.com\"))\n    t_id = t['id']\n    \n    task_service.transition_status(t_id, TaskStatus.ACTIVE.value)\n    \n    # If notification failed, task update must still be explicit\n    # (This is implicitly tested by the try/except in the service)\n    # We check that the task status actually changed despite the mock failure\n    task = task_service.get_task(t_id)\n    assert task['status'] == TaskStatus.ACTIVE\n```\n\n#### `/tests/test_api.py`\nTests the HTTP layer.\n\n```python\nfrom fastapi.testclient import TestClient\nfrom main import app\nfrom models.task import TaskCreate\n\nclient = TestClient(app)\n\ndef test_create_task():\n    response = client.post(\"/tasks\", json={\n        \"title\": \"Test Task\",\n        \"priority\": \"high\",\n        \"assignee_email\": \"bob@example.com\"\n    })\n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"title\"] == \"Test Task\"\n    assert data[\"status\"] == \"draft\"\n\ndef test_create_task_overdue_logic():\n    response = client.post(\"/tasks\", json={\n        \"title\": \"Overdue Test\",\n        \"priority\": \"high\",\n        \"assignee_email\": \"bob@example.com\"\n    })\n    task = response.json()\n    \n    # Verify transition to active\n    status_response = client.post(f\"/tasks/{task['id']}/transition\", json={\"status\": \"active\"})\n    assert status_response.status_code == 200\n    \n    # Verify transition to blocked requires reason\n    status_response = client.post(f\"/tasks/{task['id']}/transition\", json={\"status\": \"blocked\"})\n    assert status_response.status_code == 400 # Should require reason\n```\n\n### 4. Reliability & Consistency Summary\n\n*   **State Machine:** The `transition_status` method explicitly checks `if current == A and next == B` to ensure no invalid jumps (e.g., Draft -> Done).\n*   **Non-Blocking Notifications:** The notification service is wrapped in a `try/except` block. Even if the notification raises an exception, the function returns `True` for the task update, ensuring the task status is unambiguously updated as requested.\n*   **Data Validation:** Pydantic models ensure type safety (e.g., `priority` must be an Enum value).\n*   **Consistent Overdue Logic:** The `is_overdue` function calculates the deadline duration based on priority immediately upon task creation, ensuring the rule applies consistently to all future checks for that task.\n\n// Test: legacy_refactor_all_principles\n### Executive Summary\nTo resolve the instability, we will move from an **Imperative Monolithic Handler** to a **Command-Driven Architecture with Explicit State Machines**. This shifts the system from \"doing stuff when called\" to \"receiving a valid command and transitioning through defined states,\" inherently solving state-skipping and resource-leak issues.\n\n**Team Size:** 10 Engineers (2 parallel streams recommended).\n**Timeline:** 4 Sprints (approx. 8\u201310 weeks).\n\n---\n\n### The Incremental Refactor Plan\n\n#### Phase 1: Stabilization & Discovery (Sprint 1)\n*Goal: Stop the bleeding and map the chaos.*\n*   **Milestone:** Introduce Observability & Extract Magic Strings.\n*   **Actions:**\n    *   Implement a generic `TaskContext` wrapper to track all internal state variables.\n    *   Replace all magic strings (e.g., `\"status=1\"`) with Enum/DTO constants.\n    *   Add centralized error logging for all uncaught exceptions.\n    *   **Outcome:** You now see *why* it fails, even if you can't fix it yet.\n\n#### Phase 2: Command Pattern Injection (Sprint 2)\n*Goal: Decouple business logic from execution flow.*\n*   **Milestone:** New API Layer accepts Commands.\n*   **Actions:**\n    *   Create a `TaskCommand` base class.\n    *   The legacy handler becomes a thin wrapper: `HandleCommand(command)`.\n    *   The actual logic is extracted into a separate `TaskOrchestrator` class.\n*   **Outcome:** The \"side effects\" (API calls, DB writes) are no longer mixed with business rules.\n\n#### Phase 3: State Machine & Cleanup (Sprint 3)\n*Goal: Fix state skipping and resource leaks.*\n*   **Milestone:** Explicit State Transitions.\n*   **Actions:**\n    *   Implement a State Machine (using a library like XState, Automata, or a custom implementation).\n    *   Define **Entry** and **Exit** actions for every state.\n    *   *Crucial:* Add a \"Cleanup/Dispose\" step to the `Exit` action of the final states (e.g., `TaskCompleted`) to release database locks and file handles, solving the resource growth issue.\n*   **Outcome:** State transitions are explicit; you cannot accidentally jump from 'Pending' to 'Completed' without triggering the required 'Start' logic.\n\n#### Phase 4: Standardization & Rollout (Sprint 4)\n*Goal: Naming consistency and validation.*\n*   **Milestone:** Strict Business Rules Layer.\n*   **Actions:**\n    *   Extract business rules into a `TaskValidator` service.\n    *   Enforce a \"Idempotency Key\" on all incoming commands to prevent duplicate processing.\n    *   Rename all ambiguous variables to match the domain model.\n*   **Outcome:** Consistent names; same input always produces same output.\n\n---\n\n### Representative Examples\n\n#### 1. State Transition Logic\n**Problem:** Implicit jumps and missing error handling.\n\n*   **Before (The Legacy \"Spaghetti\"):**\n    ```python\n    def process_task(task):\n        # Implicit state logic, hard to track execution\n        if task.status == \"PENDING\":\n            task.status = \"PROCESSING\"\n            try:\n                task.data = do_work()\n                task.status = \"DONE\"\n            except:\n                task.status = \"ERROR\" # Risk: Did we skip the 'Cleanup' step?\n    ```\n\n*   **After (Explicit State Machine):**\n    ```python\n    # Use a state machine library or custom switch\n    def transition_task(command, state):\n        # Explicit validation before movement\n        if not TransitionValidator.can_move(state, command.action):\n            raise InvalidTransitionError(f\"Cannot {command.action} from {state}\")\n\n        # Execute Logic\n        result = Orchestrator.execute(command)\n\n        # Explicit Action (e.g., closing connections) tied to the state change\n        if state == \"PROCESSING\" and result.success:\n            CleanupManager.release_resources(command.resource_id)\n\n        return new_state\n    ```\n\n#### 2. Failure Handling\n**Problem:** Ambiguous responses; callers don't know what failed.\n\n*   **Before (Generic):**\n    ```python\n    try:\n        # ... heavy processing ...\n        return {\"status\": \"200 OK\"}\n    except Exception as e:\n        # Callers don't know if it was a DB timeout or a timeout in the logic\n        raise Exception(\"Internal Server Error\")\n    ```\n\n*   **After (Structured):**\n    ```python\n    try:\n        # ... heavy processing ...\n    except DatabaseConnectionError as e:\n        raise TaskFailureException(\n            error_code=\"DB_TIMEOUT\",\n            message=\"Connection pool exhausted. Please retry.\",\n            retryable=True\n        )\n    except BusinessRuleViolation as e:\n        raise TaskFailureException(\n            error_code=\"RULE_VIOLATION\",\n            message=f\"Missing approval: {e.reason}\",\n            retryable=False\n        )\n    ```\n\n#### 3. Naming Consistency\n**Problem:** Different parts of the system call the same concept by different names.\n\n*   **Before (Inconsistent):**\n    ```text\n    /api/v1/tasks/1/complete\n    /api/v1/workflows/run?id=1\n    /api/ops/finish-task?id=1\n    ```\n\n*   **After (Unified):**\n    ```text\n    /api/v1/tasks/{taskId}/actions/COMPLETE\n    ```\n    *Unified API contract:* All requests to the task service now go through a single endpoint that accepts a standardized JSON payload.\n    ```json\n    {\n      \"taskId\": \"123\",\n      \"action\": \"COMPLETE\",\n      \"payload\": { \"notes\": \"Completed manually\" }\n    }\n    ```\n\n---\n\n### Rollback Strategy\nGiven the incremental approach, the risk is low, but strict safeguards are in place:\n1.  **Feature Flagging:** The old handler remains active behind a flag `legacy_handler_enabled=true`.\n2.  **Database Migrations:** Use transactions for schema changes. If migration fails, rollback script is auto-executed.\n3.  **Backward Compatibility:** Keep the old HTTP endpoints for 3 months, redirecting them to the new command handler until the UI is updated.\n\n### Success Criteria\n*   **Reliability:** Reduction in state-skipping bugs by >90%.\n*   **Observability:** Every state transition logs a structured event with correlation IDs.\n*   **Performance:** Zero memory leak detected after running 24-hour load tests.\n*   **Maintainability:** A new engineer can read a single `TaskStateMachine` definition and understand all valid behaviors.",
          "after_code": "// Test: mini_app_full_stack_architecture_challenge\n### 1. Domain Model & State Invariants\n\nWe define the state space explicitly using enums to prevent invalid combinations.\n\n```typescript\n// Core State\nenum TaskStatus {\n    DRAFT = 'draft',\n    ACTIVE = 'active',\n    BLOCKED = 'blocked',\n    DONE = 'done',\n    ARCHIVED = 'archived'\n}\n\nenum Priority {\n    LOW = 'low',\n    MEDIUM = 'medium',\n    HIGH = 'high'\n}\n\n// Explicit Invariant: Task is a single source of truth with valid transitions\ninterface Task {\n    id: string;\n    title: string;\n    description: string;\n    priority: Priority;\n    assignee: string;\n    createdAt: Date;\n    dueDate?: Date;\n    status: TaskStatus;\n    checklist: ChecklistItem[];\n}\n\ninterface ChecklistItem {\n    id: string;\n    text: string;\n    completed: boolean;\n}\n\n// Domain Errors\nclass TaskError extends Error {\n    constructor(public readonly code: string, message: string) {\n        super(message);\n    }\n}\n\nconst Errors = {\n    INVALID_TRANSITION: (from: string, to: string) => \n        new TaskError('INVALID_TRANSITION', `Cannot transition from ${from} to ${to}`),\n    INCOMPLETE_CHECKLIST: () => \n        new TaskError('INCOMPLETE_CHECKLIST', 'Task cannot be marked done with incomplete checklist'),\n    DUPLICATE_ID: (id: string) => \n        new TaskError('DUPLICATE_ID', `Task with id ${id} already exists`),\n    RESOURCE_NOT_FOUND: (id: string) => \n        new TaskError('RESOURCE_NOT_FOUND', `Task with id ${id} not found`)\n};\n```\n\n### 2. Core Logic (Policy & Mechanism Separation)\n\nPure functions handling business logic. No side effects, no framework access.\n\n```typescript\n// Policy: Overdue thresholds (milliseconds)\nconst OverduePolicy = {\n    HIGH: 24 * 60 * 60 * 1000, // 24h\n    MEDIUM_LOW: 72 * 60 * 60 * 1000 // 72h\n};\n\n// Mechanism: Transition logic\nconst TransitionMechanism = {\n    validNextStates: {\n        [TaskStatus.DRAFT]: [TaskStatus.ACTIVE],\n        [TaskStatus.ACTIVE]: [TaskStatus.BLOCKED, TaskStatus.DONE],\n        [TaskStatus.BLOCKED]: [TaskStatus.ACTIVE, TaskStatus.DONE],\n        [TaskStatus.DONE]: [TaskStatus.ARCHIVED],\n        [TaskStatus.ARCHIVED]: []\n    },\n    canTransition(current: TaskStatus, next: TaskStatus): boolean {\n        return (this.validNextStates[current] || []).includes(next);\n    },\n    requiresChecklist(task: TaskStatus): boolean {\n        return task === TaskStatus.ACTIVE || task === TaskStatus.BLOCKED;\n    }\n};\n\n// Core Logic\nfunction validateTransition(task: Task, targetStatus: TaskStatus): Task {\n    if (!TransitionMechanism.canTransition(task.status, targetStatus)) {\n        throw Errors.INVALID_TRANSITION(task.status, targetStatus);\n    }\n    \n    if (TransitionMechanism.requiresChecklist(targetStatus)) {\n        const allCompleted = task.checklist.every(item => item.completed);\n        if (!allCompleted) {\n            throw Errors.INCOMPLETE_CHECKLIST();\n        }\n    }\n    \n    return task; // Returns the mutated task object (local reasoning)\n}\n\nfunction calculateOverdueStatus(task: Task, now: Date): { isOverdue: boolean; reason: string | null } {\n    if (!task.dueDate) return { isOverdue: false, reason: null };\n    \n    const diff = now.getTime() - task.dueDate.getTime();\n    const threshold = task.priority === Priority.HIGH \n        ? OverduePolicy.HIGH \n        : OverduePolicy.MEDIUM_LOW;\n\n    if (diff > threshold) {\n        return { isOverdue: true, reason: `Past due date threshold (${threshold / (1000*60*60)}h)` };\n    }\n    \n    return { isOverdue: false, reason: null };\n}\n```\n\n### 3. Ports & Adapters (Boundaries)\n\nInterfaces defining contracts, separated from implementation.\n\n```typescript\n// Ports (Domain Interfaces)\ninterface TaskRepository {\n    save(task: Task): Result<void, TaskError>;\n    find(id: string): Result<Task, TaskError>;\n    list(filters?: TaskFilter): Result<Task[], TaskError>;\n}\n\ninterface NotificationSender {\n    send(event: TaskEvent): Result<void, Error>;\n}\n\n// Adapters (Infrastructure Implementations)\nclass InMemoryTaskRepository implements TaskRepository {\n    private tasks: Map<string, Task> = new Map();\n\n    save(task: Task): Result<void, TaskError> {\n        if (this.tasks.has(task.id)) {\n            return { success: false, error: Errors.DUPLICATE_ID(task.id) };\n        }\n        this.tasks.set(task.id, task);\n        return { success: true, value: undefined };\n    }\n\n    find(id: string): Result<Task, TaskError> {\n        const task = this.tasks.get(id);\n        return task ? { success: true, value: task } : { success: false, error: Errors.RESOURCE_NOT_FOUND(id) };\n    }\n\n    list(filters?: TaskFilter): Result<Task[], TaskError> {\n        // Simplified list logic\n        return { success: true, value: Array.from(this.tasks.values()) };\n    }\n}\n\nclass ConsoleNotificationSender implements NotificationSender {\n    send(event: TaskEvent): Result<void, Error> {\n        console.log(`[Notification] ${event.type}: ${event.taskId}`);\n        return { success: true, value: undefined };\n    }\n}\n\ninterface TaskFilter {\n    status?: TaskStatus;\n    assignee?: string;\n    priority?: Priority;\n}\n```\n\n### 4. Service Composition (Imperative Shell)\n\nThe application logic that wires the core to the ports.\n\n```typescript\nclass TaskService {\n    constructor(\n        private repo: TaskRepository,\n        private notifier: NotificationSender,\n        private clock: Clock // Interface for time injection\n    ) {}\n\n    async createTask(input: CreateTaskInput): Promise<Result<Task, TaskError>> {\n        const newTask: Task = {\n            id: input.id, // Assuming ID generated elsewhere or provided\n            title: input.title,\n            description: input.description,\n            priority: input.priority,\n            assignee: input.assignee,\n            createdAt: this.clock.now(),\n            dueDate: input.dueDate,\n            status: TaskStatus.DRAFT,\n            checklist: [] // Initial empty checklist\n        };\n\n        const saveResult = this.repo.save(newTask);\n        if (!saveResult.success) return saveResult;\n\n        // Fire and forget notification (or propagate failure if strict)\n        this.notifier.send({ type: 'TASK_CREATED', taskId: newTask.id }).catch(console.error);\n\n        return { success: true, value: newTask };\n    }\n\n    async activateTask(id: string, reason: string): Promise<Result<Task, TaskError>> {\n        const taskResult = this.repo.find(id);\n        if (!taskResult.success) return taskResult;\n\n        const task = taskResult.value;\n        \n        // Core logic\n        const updatedTask = validateTransition(task, TaskStatus.ACTIVE);\n\n        // Update state in repository\n        const saveResult = this.repo.save(updatedTask);\n        if (!saveResult.success) return saveResult;\n\n        // Notify\n        this.notifier.send({ type: 'TASK_ACTIVATED', taskId: id }).catch(console.error);\n\n        return { success: true, value: updatedTask };\n    }\n\n    async blockTask(id: string, reason: string): Promise<Result<Task, TaskError>> {\n        const taskResult = this.repo.find(id);\n        if (!taskResult.success) return taskResult;\n\n        const task = taskResult.value;\n        const updatedTask = validateTransition(task, TaskStatus.BLOCKED);\n        \n        const saveResult = this.repo.save(updatedTask);\n        if (!saveResult.success) return saveResult;\n\n        this.notifier.send({ type: 'TASK_BLOCKED', taskId: id, meta: { reason } }).catch(console.error);\n\n        return { success: true, value: updatedTask };\n    }\n\n    async completeTask(id: string): Promise<Result<Task, TaskError>> {\n        const taskResult = this.repo.find(id);\n        if (!taskResult.success) return taskResult;\n\n        const task = taskResult.value;\n        const updatedTask = validateTransition(task, TaskStatus.DONE);\n\n        const saveResult = this.repo.save(updatedTask);\n        if (!saveResult.success) return saveResult;\n\n        this.notifier.send({ type: 'TASK_COMPLETED', taskId: id }).catch(console.error);\n\n        return { success: true, value: updatedTask };\n    }\n\n    async archiveTask(id: string): Promise<Result<Task, TaskError>> {\n        const taskResult = this.repo.find(id);\n        if (!taskResult.success) return taskResult;\n\n        const task = taskResult.value;\n        const updatedTask = validateTransition(task, TaskStatus.ARCHIVED);\n\n        const saveResult = this.repo.save(updatedTask);\n        if (!saveResult.success) return saveResult;\n\n        this.notifier.send({ type: 'TASK_ARCHIVED', taskId: id }).catch(console.error);\n\n        return { success: true, value: updatedTask };\n    }\n\n    async getOverdueStatus(id: string): Promise<Result<{ isOverdue: boolean, reason: string | null }, TaskError>> {\n        const taskResult = this.repo.find(id);\n        if (!taskResult.success) return taskResult;\n\n        const status = calculateOverdueStatus(taskResult.value, this.clock.now());\n        return { success: true, value: status };\n    }\n}\n\n// Context interfaces\ninterface TaskEvent { type: string; taskId: string; meta?: any; }\ninterface CreateTaskInput { id: string; title: string; description: string; priority: Priority; assignee: string; dueDate?: Date; }\ninterface Clock { now(): Date; }\n```\n\n### 5. API Contract\n\n```typescript\n// Public interface exposed to the rest of the system\ninterface TaskTrackerAPI {\n    create(input: CreateTaskInput): Promise<Result<Task, TaskError>>;\n    activate(id: string, reason: string): Promise<Result<Task, TaskError>>;\n    block(id: string, reason: string): Promise<Result<Task, TaskError>>;\n    complete(id: string): Promise<Result<Task, TaskError>>;\n    archive(id: string): Promise<Result<Task, TaskError>>;\n    getOverdue(id: string): Promise<Result<{ isOverdue: boolean, reason: string | null }, TaskError>>;\n    listTasks(filters?: TaskFilter): Promise<Result<Task[], TaskError>>;\n}\n```\n\n### 6. Test Cases\n\n**Scenario 1: Valid Status Transition**\n*Input:* Task in `ACTIVE` status, checklist empty.\n*Action:* Attempt `completeTask`.\n*Expected:* `TaskError { code: INCOMPLETE_CHECKLIST }`.\n\n**Scenario 2: Overdue Calculation**\n*Input:* High priority task, due 25 hours ago.\n*Action:* `getOverdueStatus`.\n*Expected:* `Result { success: true, value: { isOverdue: true, reason: \"Past due date threshold (24h)\" } }`.\n\n**Scenario 3: Notification Failure Tolerance**\n*Input:* Task transition `DRAFT` -> `ACTIVE`.\n*Action:* `activateTask`.\n*Context:* `NotificationSender` always throws error.\n*Expected:* `Task` successfully updated to `ACTIVE` in repo. No propagation of notification error to the API result.\n\n**Scenario 4: Illegal Transition**\n*Input:* Task in `DRAFT` status.\n*Action:* `blockTask`.\n*Expected:* `TaskError { code: INVALID_TRANSITION }`. State remains `DRAFT`.\n\n// Test: legacy_refactor_all_principles\n# Refactor Plan: Legacy Task Service\n\nApplying **All Principles Compressed** to stabilize the Task Service. The goal is to move from implicit, brittle state to explicit invariants, and from implicit dependencies to pure, testable domains.\n\n## Architecture Overview\n\n1.  **Domain State**: Explicit enums (no boolean flags).\n2.  **Core Logic**: Pure functions for state transitions and business rules (independent of DB/IO).\n3.  **Ports**: Interface definitions (Repository, Clock, EventPublisher).\n4.  **Adapters**: Implementation of Ports (DB ORM, System Time, HTTP).\n5.  **Composition**: Wiring Core and Adapters with explicit error handling and resource ownership.\n\n---\n\n## Incremental Delivery Plan (Team of 10)\n\n### Milestone 1: Model State & Invariants (Week 1)\n**Objective:** Eliminate the \"boolean flag explosion\" and invalid state transitions.\n**Action:** Redefine the domain model using strict types.\n**Rollback:** Low risk. New types do not break existing compiled code; they only affect new interactions.\n\n### Milestone 2: Extract Pure Core (Week 2)\n**Objective:** Separate business decisions from infrastructure.\n**Action:** Move logic from Controllers to a pure `TaskProcessor` struct. Remove DB/HTTP imports from domain logic.\n**Rollback:** Low risk. Old controller can be left in place pointing to the *new* core if needed.\n\n### Milestone 3: Port/Adapter Boundary & Wiring (Week 3)\n**Objective:** Define explicit dependencies and handle errors correctly.\n**Action:** Define `TaskRepository`, `Clock`, and `NotificationService` interfaces. Implement DB adapters.\n**Rollback:** Medium risk. Requires database migration or careful transaction handling, but does not require redeployment of business rules.\n\n### Milestone 4: Policy/Mechanism Decoupling & Cleanup (Week 4)\n**Objective:** Allow configuration changes without code modification and guarantee resource cleanup.\n**Action:** Externalize timeout logic to a config object. Ensure adapters handle resource acquisition/release deterministically.\n**Rollback:** Low/Medium risk. Requires monitoring of resource usage.\n\n---\n\n## Representative Examples\n\n### 1. State Transition Logic\n**Problem:** Previous code used `int status` or boolean flags (`isCompleted`), allowing invalid states like \"Completed but not Paid\" without checks.\n\n**Before:**\n```typescript\n// State is implicit, invalid states possible\nfunction startTask(task: Task) {\n    if (task.status === 'COMPLETED') throw new Error(\"Cannot start completed task\");\n    // Logic relies on magic strings and flags\n    if (!task.dependenciesMet) throw new Error(\"Missing deps\");\n    task.status = 'IN_PROGRESS';\n}\n```\n\n**After (Applying Skill):**\n```typescript\n// State is explicit and invalid states unrepresentable\ntype TaskStatus = 'TODO' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';\n\ninterface Task {\n    id: TaskId;\n    status: TaskStatus;\n    // Other fields...\n}\n\n// Core: Pure function, no side effects\nfunction transition(task: Task, event: StartEvent, dependenciesMet: boolean): Result<Task, TransitionError> {\n    // Illegal states are checked at type level, but logic enforced here\n    if (!dependenciesMet) return Err(TransitionError.DependenciesNotMet);\n    \n    const nextStatus: TaskStatus = 'IN_PROGRESS';\n    return Ok({ ...task, status: nextStatus });\n}\n```\n\n### 2. Failure Handling\n**Problem:** Generic exceptions and null returns made it impossible to distinguish \"Task not found\" from \"Database timeout\".\n\n**Before:**\n```java\npublic TaskDTO executeTask(Long id) {\n    Task task = repository.findById(id); // null if not found\n    if (task == null) return null; // Caller thinks it's \"success\" with no data\n    \n    try {\n        // Side effects in domain logic\n        task = doWork(task); \n        repository.save(task);\n        return mapper.toDTO(task);\n    } catch (Exception e) {\n        // Swallows context\n        throw new RuntimeException(\"Processing failed\");\n    }\n}\n```\n\n**After (Applying Skill):**\n```rust\n// Core: Returns explicit Result types\npub async fn execute_task(id: TaskId, repo: &dyn TaskRepo) -> Result<Task, TaskError> {\n    let mut task = repo.load(id)\n        .map_err(|_| TaskError::NotFound)?; // Infrastructure error separated from Domain error\n\n    // Pure Logic\n    let result = task.execute_policy(repo.get_config()); // Policy separated\n    \n    match result {\n        Ok(executed_task) => repo.save(executed_task),\n        Err(e) => repo.mark_failed(id, e),\n    }\n}\n\n// Enum: Explicit error types\nenum TaskError {\n    NotFound,\n    Timeout(String), // Domain error with context\n    StorageFailure,  // Infrastructure error\n}\n```\n\n### 3. Naming & Policy\n**Problem:** \"doStuff\", \"update\", \"handler\". No clear business intent. Policies hardcoded in loops.\n\n**Before:**\n```java\n// Cryptic name and hardcoded policy\npublic void handleTask(Task t) {\n    if (t.getAge() > 30) { // Policy mixed in logic\n        t.setCancelled();\n        t.save();\n    }\n    // ...\n}\n```\n\n**After (Applying Skill):**\n```typescript\n// Names express domain intent; Policy is data\ninterface TaskProcessingConfig {\n    maxExecutionDays: number;\n    autoExpire: boolean;\n}\n\nfunction processTask(task: Task, config: TaskProcessingConfig): Result<Task, Error> {\n    const isExpired = is_expired(task.created_at, config.maxExecutionDays); // Mechanism separates from Policy (config)\n    \n    if (isExpired) {\n        return task.expire(); // Domain intentful name\n    }\n    \n    return task.mark_awaiting_review();\n}\n```\n\n---\n\n## Success Criteria (AI Review Checklist)\n\nBefore declaring the sprint done, verify:\n\n-   [ ] **Invariants**: The `Task` type has a strict `status` enum. No invalid combinations (e.g., status cannot be 'COMPLETED' if not actually finished).\n-   [ ] **Pure Core**: `TaskProcessor` functions accept only inputs and return `Result<T, Error>`. No DB calls or `console.log` inside the core module.\n-   [ ] **Ports/Adapters**: `TaskRepository` interface is defined. The DB driver implementation is isolated in the adapter layer.\n-   [ ] **One-Way Flow**: Updates flow: `Input -> Core -> Validation -> State Update -> Adapter Persistence`.\n-   [ ] **Error Handling**: All public interfaces return `Result` or `TaskError`. No `null` returns. Infrastructure errors are caught and wrapped in domain errors or surfaced clearly.\n-   [ ] **Resources**: DB connections are acquired and released within the adapter scope (deterministic lifecycle).\n-   [ ] **Naming**: Functions are named `mark_completed`, `calculate_priority`, not `update`, `do_calc`.\n\n## Rollback Strategy\n\n1.  **Feature Flag**: Wrap the new `TaskService` invocation behind a flag (e.g., `use_new_task_logic`).\n2.  **Database**: Keep the schema changes in a separate migration file that can be reverted.\n3.  **Backwards Compatibility**: If the new response types differ from the old DTOs, keep the Adapter layer map the new `Task` entity back to the old DTO format during the transition period.",
          "judgment": {
            "principle_better": "B",
            "quality_better": "B",
            "overall_better": "B",
            "option_a_rating": "regular",
            "option_b_rating": "outstanding",
            "score": 100,
            "reasoning": "Solution B perfectly embodies the 'Compressed meta-skill' by implementing a strict Ports/Adapters architecture, separating Policy from Mechanism, and using explicit Result types. Solution A uses a monolithic service with a shared in-memory dictionary and manual tuple errors, which lacks the explicit boundaries and pure core logic required by the guidelines."
          },
          "judge_error": false,
          "tests": [
            {
              "name": "mini_app_full_stack_architecture_challenge",
              "input": "Build a Team Task Tracker backend for small engineering teams.\n\nProduct requirements:\n1) Task data\n- Each task has: id, title, description, priority (low/medium/high), assignee email, created timestamp, optional due date, and current status.\n- Allowed status lifecycle: draft -> active -> blocked -> done -> archived.\n- A task can move only to the next logical stage in the lifecycle.\n- A task cannot be marked done unless at least one checklist item is completed.\n\n2) Features\n- Create task\n- Activate task\n- Block task with a required reason\n- Complete task\n- Archive task\n- List tasks with filters (status, assignee, priority, overdue)\n\n3) Notifications\n- Send a notification when a task is activated, blocked, completed, or archived.\n- If notification delivery fails, core task operation result must still be explicit and unambiguous.\n\n4) Overdue behavior\n- High priority tasks are overdue after 24 hours past due date.\n- Medium/low priority tasks are overdue after 72 hours past due date.\n- Overdue calculation must be consistent and testable.\n\n5) Reliability and consistency\n- If two updates happen close together, final task status must remain valid.\n- The system must avoid contradictory task states.\n- Failures must return clear machine-readable error outcomes.\n\n6) Deliverables\n- Implementation code (or detailed pseudocode)\n- API contract for all operations\n- Test cases covering status transitions, overdue rules, and failure scenarios",
              "expected": {
                "focus": "Does the solution apply all major principles together: explicit invariants/state machine, pure core + effectful shell, ports/adapters boundaries, unidirectional ownership flow, structured error types, explicit lifecycle cleanup, policy-mechanism separation, composition over coordinator, controlled mutation, and domain-driven naming?"
              },
              "baseline_response": "Here is the complete implementation for the Team Task Tracker Backend.\n\n### Tech Stack\n*   **Language**: Python 3.8+\n*   **Framework**: FastAPI (for the API layer and data validation)\n*   **Data Storage**: In-memory dictionary (simulating a database for portability)\n*   **Testing**: Pytest\n\n### Directory Structure\n```text\n/team_tracker\n    /models\n        __init__.py\n        task.py\n    /services\n        __init__.py\n        notification_service.py\n        task_service.py\n    /tests\n        __init__.py\n        test_api.py\n        test_logic.py\n    main.py\n```\n\n### 1. Implementation Code\n\n#### `/models/task.py`\nDefines the data structures using Pydantic.\n\n```python\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Literal\nfrom enum import Enum\nfrom datetime import datetime\n\nclass TaskStatus(str, Enum):\n    DRAFT = \"draft\"\n    ACTIVE = \"active\"\n    BLOCKED = \"blocked\"\n    DONE = \"done\"\n    ARCHIVED = \"archived\"\n\nclass TaskPriority(str, Enum):\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n\nclass ChecklistItem(BaseModel):\n    id: str\n    text: str\n    completed: bool = False\n\nclass TaskCreate(BaseModel):\n    title: str\n    description: str = \"\"\n    priority: TaskPriority = TaskPriority.MEDIUM\n    assignee_email: str\n    due_date: Optional[datetime] = None\n\nclass TaskUpdate(BaseModel):\n    title: Optional[str] = None\n    description: Optional[str] = None\n    assignee_email: Optional[str] = None\n    due_date: Optional[datetime] = None\n    checklist: Optional[List[ChecklistItem]] = None\n\nclass TaskResponse(BaseModel):\n    id: str\n    title: str\n    description: str\n    priority: TaskPriority\n    assignee_email: str\n    created_at: datetime\n    due_date: Optional[datetime]\n    status: TaskStatus\n    checklist: List[ChecklistItem]\n    \n    class Config:\n        from_attributes = True\n```\n\n#### `/services/notification_service.py`\nHandles notifications. It simulates a failure scenario to meet requirement #3.\n\n```python\nimport smtplib\nimport random\n\nclass NotificationService:\n    def __init__(self):\n        self.enabled = True # Simulating an environment variable\n\n    def send(self, user_email: str, task_title: str, event_type: str):\n        if not self.enabled:\n            return {\"success\": False, \"error\": \"Service disabled\"}\n\n        # Simulate random failure (approx 10% chance)\n        if random.random() < 0.1:\n            raise Exception(\"SMTP connection timeout\")\n\n        # In a real app, this would use SMTP or an external API\n        print(f\"[NOTIFICATION] To: {user_email}, Event: {event_type}, Task: {task_title}\")\n        return {\"success\": True, \"message\": \"Notification sent\"}\n```\n\n#### `/services/task_service.py`\nContains the core logic, state machine, and state transitions.\n\n```python\nfrom models.task import TaskStatus, TaskPriority, ChecklistItem\nfrom datetime import datetime, timedelta\nfrom typing import List, Optional, Tuple\n\nclass TaskService:\n    def __init__(self, notification_service):\n        self.tasks = {} # Simulating DB: {id: Task}\n        self.notification_service = notification_service\n\n    def create_task(self, task_data) -> dict:\n        task_id = f\"task_{datetime.now().timestamp()}\"\n        \n        # Calculate default due date based on priority if not provided\n        due_date = task_data.due_date\n        if not due_date:\n            if task_data.priority == TaskPriority.HIGH:\n                due_date = datetime.now() + timedelta(hours=24)\n            else:\n                due_date = datetime.now() + timedelta(hours=72)\n\n        task = {\n            \"id\": task_id,\n            \"title\": task_data.title,\n            \"description\": task_data.description,\n            \"priority\": task_data.priority,\n            \"assignee_email\": task_data.assignee_email,\n            \"created_at\": datetime.now(),\n            \"due_date\": due_date,\n            \"status\": TaskStatus.DRAFT,\n            \"checklist\": [{\"id\": \"c1\", \"text\": \"Initial task\", \"completed\": False}]\n        }\n\n        self.tasks[task_id] = task\n        return task\n\n    def get_task(self, task_id: str) -> Optional[dict]:\n        return self.tasks.get(task_id)\n\n    def list_tasks(self, filters: dict) -> List[dict]:\n        filtered = []\n        for task in self.tasks.values():\n            # Apply filters\n            if filters.get(\"status\") and task['status'] != filters[\"status\"]:\n                continue\n            if filters.get(\"assignee\") and task['assignee_email'] != filters[\"assignee\"]:\n                continue\n            if filters.get(\"priority\") and task['priority'] != filters[\"priority\"]:\n                continue\n            if filters.get(\"overdue_only\"):\n                if not self.is_overdue(task):\n                    continue\n            \n            filtered.append(task)\n        return filtered\n\n    def is_overdue(self, task: dict) -> bool:\n        # Requirement: High priority is overdue after 24h, Medium/Low after 72h\n        if task['status'] not in [TaskStatus.ACTIVE, TaskStatus.BLOCKED]:\n            return False\n        \n        now = datetime.now()\n        if task['due_date'] is None:\n            return False\n\n        # Define time window based on priority\n        if task['priority'] == TaskPriority.HIGH:\n            time_window = timedelta(hours=24)\n        else:\n            time_window = timedelta(hours=72)\n\n        # A task is overdue if the current time exceeds the due date + time window\n        # Wait, standard logic: if now > due_date. \n        # Prompt: \"High priority tasks are overdue after 24 hours past due date.\"\n        # This implies a grace period. We'll stick to: Is it past due date?\n        # Let's implement strict overdue: Is it past the 'due_date'?\n        \n        # Re-reading Requirement 4 strictly: \"High priority tasks are overdue after 24 hours past due date.\"\n        # This phrasing is unusual. It implies the deadline duration is 24h (High) or 72h (Med/Low).\n        # If I created a task 1 hour ago, it is NOT overdue.\n        # If I created a task 50 hours ago, it IS overdue.\n        \n        if now > task['due_date']:\n            return True\n            \n        return False\n\n    def update_task(self, task_id: str, updates: dict) -> Tuple[bool, str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            return False, \"Task not found\"\n\n        # Apply updates\n        if \"title\" in updates: task['title'] = updates[\"title\"]\n        if \"description\" in updates: task['description'] = updates[\"description\"]\n        if \"assignee_email\" in updates: task['assignee_email'] = updates[\"assignee_email\"]\n        if \"due_date\" in updates: task['due_date'] = updates[\"due_date\"]\n        if \"checklist\" in updates: task['checklist'] = updates[\"checklist\"]\n\n        return True, \"Updated successfully\"\n\n    def transition_status(self, task_id: str, new_status: str, metadata: dict = {}) -> Tuple[bool, str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            return False, \"Task not found\"\n\n        current = TaskStatus(task['status'])\n        next_status = TaskStatus(new_status)\n        \n        # 1. State Machine Validation\n        valid_transition = False\n        reason = \"\"\n\n        if current == TaskStatus.DRAFT and next_status == TaskStatus.ACTIVE:\n            valid_transition = True\n        elif current == TaskStatus.ACTIVE and next_status == TaskStatus.BLOCKED:\n            valid_transition = True\n            reason = metadata.get(\"reason\", \"No reason provided\")\n        elif current == TaskStatus.BLOCKED and next_status == TaskStatus.ACTIVE:\n            valid_transition = True\n            reason = metadata.get(\"reason\", \"Unblocking\") # Explicitly requested to move forward\n        elif current == TaskStatus.ACTIVE and next_status == TaskStatus.DONE:\n            valid_transition = True\n            # Requirement: \"Cannot be marked done unless at least one checklist item is completed\"\n            if not any(item['completed'] for item in task['checklist']):\n                return False, \"Must complete at least one checklist item before completion\"\n        elif current == TaskStatus.DONE and next_status == TaskStatus.ARCHIVED:\n            valid_transition = True\n        else:\n            return False, f\"Invalid transition: {current} -> {next_status}\"\n\n        if not valid_transition:\n            return False, \"Transition not allowed\"\n\n        # 2. Execute Transition\n        task['status'] = next_status\n        success, msg = True, \"Status transitioned\"\n\n        # 3. Handle Notifications (Non-blocking)\n        notification_payload = {}\n        try:\n            event_name = \"\"\n            if next_status == TaskStatus.ACTIVE:\n                event_name = \"task_activated\"\n            elif next_status == TaskStatus.BLOCKED:\n                event_name = \"task_blocked\"\n            elif next_status == TaskStatus.DONE:\n                event_name = \"task_completed\"\n            elif next_status == TaskStatus.ARCHIVED:\n                event_name = \"task_archived\"\n\n            if event_name:\n                self.notification_service.send(\n                    task['assignee_email'], \n                    task['title'], \n                    event_name\n                )\n        except Exception as e:\n            print(f\"Notification failed: {e}\")\n            # Core task operation result is still explicit (success=True above)\n            # We just note the failure in the return object implicitly via the success flag\n\n        return success, msg\n```\n\n#### `/main.py`\nThe API layer using FastAPI.\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query\nfrom models.task import TaskCreate, TaskUpdate, TaskResponse, TaskStatus\nfrom services.task_service import TaskService\nfrom services.notification_service import NotificationService\n\napp = FastAPI(title=\"Team Task Tracker\")\n\n# Initialize Service\nnotification_svc = NotificationService()\ntask_svc = TaskService(notification_svc)\n\n@app.post(\"/tasks\", response_model=TaskResponse)\ndef create_task(task: TaskCreate):\n    result = task_svc.create_task(task)\n    return TaskResponse(**result)\n\n@app.get(\"/tasks\", response_model=List[TaskResponse])\ndef list_tasks(\n    status: TaskStatus = Query(None),\n    assignee: str = Query(None),\n    priority: TaskStatus = Query(None),\n    overdue_only: bool = Query(False)\n):\n    filters = {}\n    if status: filters[\"status\"] = status\n    if assignee: filters[\"assignee\"] = assignee\n    if priority: filters[\"priority\"] = priority\n    if overdue_only: filters[\"overdue_only\"] = overdue_only\n    \n    results = task_svc.list_tasks(filters)\n    return [TaskResponse(**t) for t in results]\n\n@app.get(\"/tasks/{task_id}\", response_model=TaskResponse)\ndef get_task(task_id: str):\n    task = task_svc.get_task(task_id)\n    if not task:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    return TaskResponse(**task)\n\n@app.patch(\"/tasks/{task_id}\")\ndef update_task(task_id: str, updates: TaskUpdate):\n    success, message = task_svc.update_task(task_id, updates.dict(exclude_unset=True))\n    if not success:\n        raise HTTPException(status_code=400, detail=message)\n    return {\"message\": message}\n\n@app.post(\"/tasks/{task_id}/transition\")\ndef transition_task(task_id: str, new_status: TaskStatus, metadata: dict = {}):\n    success, message = task_svc.transition_status(task_id, new_status.value, metadata)\n    if not success:\n        raise HTTPException(status_code=400, detail=message)\n    return {\"message\": message, \"status\": new_status.value}\n```\n\n---\n\n### 2. API Contract\n\nHere is a summary of the API endpoints and request/response contracts.\n\n**Base URL:** `/api/v1` (Assuming this is attached to the FastAPI app)\n\n**1. Create Task**\n*   **Method:** `POST /tasks`\n*   **Request Body:**\n    ```json\n    {\n      \"title\": \"Fix login bug\",\n      \"description\": \"Users cannot login with Google OAuth\",\n      \"priority\": \"high\",\n      \"assignee_email\": \"alice@example.com\",\n      \"due_date\": \"2023-12-01T12:00:00Z\"\n    }\n    ```\n*   **Response (201 Created):**\n    ```json\n    {\n      \"id\": \"task_12345\",\n      \"title\": \"Fix login bug\",\n      \"description\": \"Users cannot login with Google OAuth\",\n      \"priority\": \"high\",\n      \"assignee_email\": \"alice@example.com\",\n      \"created_at\": \"2023-10-27T10:00:00\",\n      \"due_date\": \"2023-10-27T10:24:00\", // Auto-calculated based on priority\n      \"status\": \"draft\",\n      \"checklist\": [{\"id\": \"c1\", \"text\": \"Initial task\", \"completed\": false}]\n    }\n    ```\n\n**2. List Tasks with Filters**\n*   **Method:** `GET /tasks`\n*   **Query Parameters:**\n    *   `status` (optional): `draft`, `active`, `blocked`, `done`, `archived`\n    *   `assignee` (optional): Email address string\n    *   `priority` (optional): `low`, `medium`, `high`\n    *   `overdue_only` (optional): boolean\n\n**3. Transition Status**\n*   **Method:** `POST /tasks/{task_id}/transition`\n*   **Request Body:**\n    ```json\n    {\n      \"status\": \"active\", // The new status\n      \"reason\": \"Found the root cause\" // Required for blocking\n    }\n    ```\n*   **Response (200 OK):**\n    ```json\n    {\n      \"message\": \"Status transitioned\",\n      \"status\": \"active\"\n    }\n    ```\n    *   **Error Response (400 Bad Request):**\n        ```json\n        {\n          \"detail\": \"Must complete at least one checklist item before completion\"\n        }\n        ```\n\n---\n\n### 3. Test Cases\n\nI will use PyTest for these tests.\n\n#### `/tests/test_logic.py`\nTests the core business logic, state machine, and overdue rules.\n\n```python\nimport pytest\nfrom datetime import datetime, timedelta\nfrom models.task import TaskStatus, TaskPriority\nfrom services.task_service import TaskService\nfrom services.notification_service import NotificationService\n\n@pytest.fixture\ndef mock_notification():\n    return NotificationService()\n\n@pytest.fixture\ndef task_service(mock_notification):\n    return TaskService(mock_notification)\n\ndef test_create_task_auto_calculate_due_date(task_service):\n    # High priority should be 24h from now\n    high_task = task_service.create_task(TaskCreate(title=\"H\", priority=TaskPriority.HIGH, assignee_email=\"a@test.com\"))\n    assert high_task['due_date'] - high_task['created_at'] <= timedelta(hours=24)\n\n    # Medium priority should be 72h from now\n    med_task = task_service.create_task(TaskCreate(title=\"M\", priority=TaskPriority.MEDIUM, assignee_email=\"a@test.com\"))\n    assert med_task['due_date'] - med_task['created_at'] <= timedelta(hours=72)\n\ndef test_overdue_calculation(task_service):\n    # High priority task, due in 1 hour\n    task_service.create_task(TaskCreate(title=\"Soon\", priority=TaskPriority.HIGH, assignee_email=\"a@test.com\"))\n    task = task_service.get_task(\"task_1\")\n    task['due_date'] = datetime.now() + timedelta(hours=1)\n    task['status'] = TaskStatus.ACTIVE\n    \n    assert task_service.is_overdue(task) == False\n    \n    # Change time to be past due\n    task['due_date'] = datetime.now() - timedelta(hours=1)\n    assert task_service.is_overdue(task) == True\n\ndef test_status_transitions(task_service):\n    t = task_service.create_task(TaskCreate(title=\"T\", assignee_email=\"a@test.com\"))\n    t_id = t['id']\n    \n    # Draft -> Active\n    s, msg = task_service.transition_status(t_id, TaskStatus.ACTIVE.value)\n    assert s == True\n    \n    # Active -> Blocked\n    s, msg = task_service.transition_status(t_id, TaskStatus.BLOCKED.value, metadata={\"reason\": \"Bug\"})\n    assert s == True\n    \n    # Blocked -> Done (Should fail because no checklist item is done)\n    s, msg = task_service.transition_status(t_id, TaskStatus.DONE.value)\n    assert s == False\n    assert \"checklist\" in msg.lower()\n\ndef test_checklist_required_for_done(task_service):\n    t = task_service.create_task(TaskCreate(title=\"T\", assignee_email=\"a@test.com\"))\n    t_id = t['id']\n    \n    task_service.transition_status(t_id, TaskStatus.ACTIVE.value)\n    \n    # Try to mark done without completing checklist\n    s, msg = task_service.transition_status(t_id, TaskStatus.DONE.value)\n    assert s == False\n\ndef test_notification_failure_handling(task_service):\n    # Force notification failure by disabling it temporarily or checking logic\n    # Here we assume the service logic catches exception and returns True for task\n    t = task_service.create_task(TaskCreate(title=\"T\", assignee_email=\"test@test.com\"))\n    t_id = t['id']\n    \n    task_service.transition_status(t_id, TaskStatus.ACTIVE.value)\n    \n    # If notification failed, task update must still be explicit\n    # (This is implicitly tested by the try/except in the service)\n    # We check that the task status actually changed despite the mock failure\n    task = task_service.get_task(t_id)\n    assert task['status'] == TaskStatus.ACTIVE\n```\n\n#### `/tests/test_api.py`\nTests the HTTP layer.\n\n```python\nfrom fastapi.testclient import TestClient\nfrom main import app\nfrom models.task import TaskCreate\n\nclient = TestClient(app)\n\ndef test_create_task():\n    response = client.post(\"/tasks\", json={\n        \"title\": \"Test Task\",\n        \"priority\": \"high\",\n        \"assignee_email\": \"bob@example.com\"\n    })\n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"title\"] == \"Test Task\"\n    assert data[\"status\"] == \"draft\"\n\ndef test_create_task_overdue_logic():\n    response = client.post(\"/tasks\", json={\n        \"title\": \"Overdue Test\",\n        \"priority\": \"high\",\n        \"assignee_email\": \"bob@example.com\"\n    })\n    task = response.json()\n    \n    # Verify transition to active\n    status_response = client.post(f\"/tasks/{task['id']}/transition\", json={\"status\": \"active\"})\n    assert status_response.status_code == 200\n    \n    # Verify transition to blocked requires reason\n    status_response = client.post(f\"/tasks/{task['id']}/transition\", json={\"status\": \"blocked\"})\n    assert status_response.status_code == 400 # Should require reason\n```\n\n### 4. Reliability & Consistency Summary\n\n*   **State Machine:** The `transition_status` method explicitly checks `if current == A and next == B` to ensure no invalid jumps (e.g., Draft -> Done).\n*   **Non-Blocking Notifications:** The notification service is wrapped in a `try/except` block. Even if the notification raises an exception, the function returns `True` for the task update, ensuring the task status is unambiguously updated as requested.\n*   **Data Validation:** Pydantic models ensure type safety (e.g., `priority` must be an Enum value).\n*   **Consistent Overdue Logic:** The `is_overdue` function calculates the deadline duration based on priority immediately upon task creation, ensuring the rule applies consistently to all future checks for that task.",
              "skill_response": "### 1. Domain Model & State Invariants\n\nWe define the state space explicitly using enums to prevent invalid combinations.\n\n```typescript\n// Core State\nenum TaskStatus {\n    DRAFT = 'draft',\n    ACTIVE = 'active',\n    BLOCKED = 'blocked',\n    DONE = 'done',\n    ARCHIVED = 'archived'\n}\n\nenum Priority {\n    LOW = 'low',\n    MEDIUM = 'medium',\n    HIGH = 'high'\n}\n\n// Explicit Invariant: Task is a single source of truth with valid transitions\ninterface Task {\n    id: string;\n    title: string;\n    description: string;\n    priority: Priority;\n    assignee: string;\n    createdAt: Date;\n    dueDate?: Date;\n    status: TaskStatus;\n    checklist: ChecklistItem[];\n}\n\ninterface ChecklistItem {\n    id: string;\n    text: string;\n    completed: boolean;\n}\n\n// Domain Errors\nclass TaskError extends Error {\n    constructor(public readonly code: string, message: string) {\n        super(message);\n    }\n}\n\nconst Errors = {\n    INVALID_TRANSITION: (from: string, to: string) => \n        new TaskError('INVALID_TRANSITION', `Cannot transition from ${from} to ${to}`),\n    INCOMPLETE_CHECKLIST: () => \n        new TaskError('INCOMPLETE_CHECKLIST', 'Task cannot be marked done with incomplete checklist'),\n    DUPLICATE_ID: (id: string) => \n        new TaskError('DUPLICATE_ID', `Task with id ${id} already exists`),\n    RESOURCE_NOT_FOUND: (id: string) => \n        new TaskError('RESOURCE_NOT_FOUND', `Task with id ${id} not found`)\n};\n```\n\n### 2. Core Logic (Policy & Mechanism Separation)\n\nPure functions handling business logic. No side effects, no framework access.\n\n```typescript\n// Policy: Overdue thresholds (milliseconds)\nconst OverduePolicy = {\n    HIGH: 24 * 60 * 60 * 1000, // 24h\n    MEDIUM_LOW: 72 * 60 * 60 * 1000 // 72h\n};\n\n// Mechanism: Transition logic\nconst TransitionMechanism = {\n    validNextStates: {\n        [TaskStatus.DRAFT]: [TaskStatus.ACTIVE],\n        [TaskStatus.ACTIVE]: [TaskStatus.BLOCKED, TaskStatus.DONE],\n        [TaskStatus.BLOCKED]: [TaskStatus.ACTIVE, TaskStatus.DONE],\n        [TaskStatus.DONE]: [TaskStatus.ARCHIVED],\n        [TaskStatus.ARCHIVED]: []\n    },\n    canTransition(current: TaskStatus, next: TaskStatus): boolean {\n        return (this.validNextStates[current] || []).includes(next);\n    },\n    requiresChecklist(task: TaskStatus): boolean {\n        return task === TaskStatus.ACTIVE || task === TaskStatus.BLOCKED;\n    }\n};\n\n// Core Logic\nfunction validateTransition(task: Task, targetStatus: TaskStatus): Task {\n    if (!TransitionMechanism.canTransition(task.status, targetStatus)) {\n        throw Errors.INVALID_TRANSITION(task.status, targetStatus);\n    }\n    \n    if (TransitionMechanism.requiresChecklist(targetStatus)) {\n        const allCompleted = task.checklist.every(item => item.completed);\n        if (!allCompleted) {\n            throw Errors.INCOMPLETE_CHECKLIST();\n        }\n    }\n    \n    return task; // Returns the mutated task object (local reasoning)\n}\n\nfunction calculateOverdueStatus(task: Task, now: Date): { isOverdue: boolean; reason: string | null } {\n    if (!task.dueDate) return { isOverdue: false, reason: null };\n    \n    const diff = now.getTime() - task.dueDate.getTime();\n    const threshold = task.priority === Priority.HIGH \n        ? OverduePolicy.HIGH \n        : OverduePolicy.MEDIUM_LOW;\n\n    if (diff > threshold) {\n        return { isOverdue: true, reason: `Past due date threshold (${threshold / (1000*60*60)}h)` };\n    }\n    \n    return { isOverdue: false, reason: null };\n}\n```\n\n### 3. Ports & Adapters (Boundaries)\n\nInterfaces defining contracts, separated from implementation.\n\n```typescript\n// Ports (Domain Interfaces)\ninterface TaskRepository {\n    save(task: Task): Result<void, TaskError>;\n    find(id: string): Result<Task, TaskError>;\n    list(filters?: TaskFilter): Result<Task[], TaskError>;\n}\n\ninterface NotificationSender {\n    send(event: TaskEvent): Result<void, Error>;\n}\n\n// Adapters (Infrastructure Implementations)\nclass InMemoryTaskRepository implements TaskRepository {\n    private tasks: Map<string, Task> = new Map();\n\n    save(task: Task): Result<void, TaskError> {\n        if (this.tasks.has(task.id)) {\n            return { success: false, error: Errors.DUPLICATE_ID(task.id) };\n        }\n        this.tasks.set(task.id, task);\n        return { success: true, value: undefined };\n    }\n\n    find(id: string): Result<Task, TaskError> {\n        const task = this.tasks.get(id);\n        return task ? { success: true, value: task } : { success: false, error: Errors.RESOURCE_NOT_FOUND(id) };\n    }\n\n    list(filters?: TaskFilter): Result<Task[], TaskError> {\n        // Simplified list logic\n        return { success: true, value: Array.from(this.tasks.values()) };\n    }\n}\n\nclass ConsoleNotificationSender implements NotificationSender {\n    send(event: TaskEvent): Result<void, Error> {\n        console.log(`[Notification] ${event.type}: ${event.taskId}`);\n        return { success: true, value: undefined };\n    }\n}\n\ninterface TaskFilter {\n    status?: TaskStatus;\n    assignee?: string;\n    priority?: Priority;\n}\n```\n\n### 4. Service Composition (Imperative Shell)\n\nThe application logic that wires the core to the ports.\n\n```typescript\nclass TaskService {\n    constructor(\n        private repo: TaskRepository,\n        private notifier: NotificationSender,\n        private clock: Clock // Interface for time injection\n    ) {}\n\n    async createTask(input: CreateTaskInput): Promise<Result<Task, TaskError>> {\n        const newTask: Task = {\n            id: input.id, // Assuming ID generated elsewhere or provided\n            title: input.title,\n            description: input.description,\n            priority: input.priority,\n            assignee: input.assignee,\n            createdAt: this.clock.now(),\n            dueDate: input.dueDate,\n            status: TaskStatus.DRAFT,\n            checklist: [] // Initial empty checklist\n        };\n\n        const saveResult = this.repo.save(newTask);\n        if (!saveResult.success) return saveResult;\n\n        // Fire and forget notification (or propagate failure if strict)\n        this.notifier.send({ type: 'TASK_CREATED', taskId: newTask.id }).catch(console.error);\n\n        return { success: true, value: newTask };\n    }\n\n    async activateTask(id: string, reason: string): Promise<Result<Task, TaskError>> {\n        const taskResult = this.repo.find(id);\n        if (!taskResult.success) return taskResult;\n\n        const task = taskResult.value;\n        \n        // Core logic\n        const updatedTask = validateTransition(task, TaskStatus.ACTIVE);\n\n        // Update state in repository\n        const saveResult = this.repo.save(updatedTask);\n        if (!saveResult.success) return saveResult;\n\n        // Notify\n        this.notifier.send({ type: 'TASK_ACTIVATED', taskId: id }).catch(console.error);\n\n        return { success: true, value: updatedTask };\n    }\n\n    async blockTask(id: string, reason: string): Promise<Result<Task, TaskError>> {\n        const taskResult = this.repo.find(id);\n        if (!taskResult.success) return taskResult;\n\n        const task = taskResult.value;\n        const updatedTask = validateTransition(task, TaskStatus.BLOCKED);\n        \n        const saveResult = this.repo.save(updatedTask);\n        if (!saveResult.success) return saveResult;\n\n        this.notifier.send({ type: 'TASK_BLOCKED', taskId: id, meta: { reason } }).catch(console.error);\n\n        return { success: true, value: updatedTask };\n    }\n\n    async completeTask(id: string): Promise<Result<Task, TaskError>> {\n        const taskResult = this.repo.find(id);\n        if (!taskResult.success) return taskResult;\n\n        const task = taskResult.value;\n        const updatedTask = validateTransition(task, TaskStatus.DONE);\n\n        const saveResult = this.repo.save(updatedTask);\n        if (!saveResult.success) return saveResult;\n\n        this.notifier.send({ type: 'TASK_COMPLETED', taskId: id }).catch(console.error);\n\n        return { success: true, value: updatedTask };\n    }\n\n    async archiveTask(id: string): Promise<Result<Task, TaskError>> {\n        const taskResult = this.repo.find(id);\n        if (!taskResult.success) return taskResult;\n\n        const task = taskResult.value;\n        const updatedTask = validateTransition(task, TaskStatus.ARCHIVED);\n\n        const saveResult = this.repo.save(updatedTask);\n        if (!saveResult.success) return saveResult;\n\n        this.notifier.send({ type: 'TASK_ARCHIVED', taskId: id }).catch(console.error);\n\n        return { success: true, value: updatedTask };\n    }\n\n    async getOverdueStatus(id: string): Promise<Result<{ isOverdue: boolean, reason: string | null }, TaskError>> {\n        const taskResult = this.repo.find(id);\n        if (!taskResult.success) return taskResult;\n\n        const status = calculateOverdueStatus(taskResult.value, this.clock.now());\n        return { success: true, value: status };\n    }\n}\n\n// Context interfaces\ninterface TaskEvent { type: string; taskId: string; meta?: any; }\ninterface CreateTaskInput { id: string; title: string; description: string; priority: Priority; assignee: string; dueDate?: Date; }\ninterface Clock { now(): Date; }\n```\n\n### 5. API Contract\n\n```typescript\n// Public interface exposed to the rest of the system\ninterface TaskTrackerAPI {\n    create(input: CreateTaskInput): Promise<Result<Task, TaskError>>;\n    activate(id: string, reason: string): Promise<Result<Task, TaskError>>;\n    block(id: string, reason: string): Promise<Result<Task, TaskError>>;\n    complete(id: string): Promise<Result<Task, TaskError>>;\n    archive(id: string): Promise<Result<Task, TaskError>>;\n    getOverdue(id: string): Promise<Result<{ isOverdue: boolean, reason: string | null }, TaskError>>;\n    listTasks(filters?: TaskFilter): Promise<Result<Task[], TaskError>>;\n}\n```\n\n### 6. Test Cases\n\n**Scenario 1: Valid Status Transition**\n*Input:* Task in `ACTIVE` status, checklist empty.\n*Action:* Attempt `completeTask`.\n*Expected:* `TaskError { code: INCOMPLETE_CHECKLIST }`.\n\n**Scenario 2: Overdue Calculation**\n*Input:* High priority task, due 25 hours ago.\n*Action:* `getOverdueStatus`.\n*Expected:* `Result { success: true, value: { isOverdue: true, reason: \"Past due date threshold (24h)\" } }`.\n\n**Scenario 3: Notification Failure Tolerance**\n*Input:* Task transition `DRAFT` -> `ACTIVE`.\n*Action:* `activateTask`.\n*Context:* `NotificationSender` always throws error.\n*Expected:* `Task` successfully updated to `ACTIVE` in repo. No propagation of notification error to the API result.\n\n**Scenario 4: Illegal Transition**\n*Input:* Task in `DRAFT` status.\n*Action:* `blockTask`.\n*Expected:* `TaskError { code: INVALID_TRANSITION }`. State remains `DRAFT`."
            },
            {
              "name": "legacy_refactor_all_principles",
              "input": "A legacy task service has become hard to maintain. Teams report frequent regressions, unclear failures, and inconsistent behavior between environments.\n\nCurrent behavior problems:\n- State changes occasionally skip required steps.\n- Some responses are ambiguous (callers cannot tell what failed).\n- Resource usage grows during long-running operation.\n- Business rules are difficult to change without side effects.\n- Different parts of the system produce different names for the same concept.\n\nRequest:\n- Propose a concrete refactor plan that can be delivered incrementally.\n- Include clear milestones, rollback strategy, and success criteria.\n- Show representative before/after examples for: state transition logic, failure handling, and naming consistency.\n- Keep the plan compact but actionable for a team of 10 engineers.",
              "expected": {
                "focus": "Does the plan concretely separate domain/core from adapters, remove illegal states, enforce one-way data flow and explicit dependencies, replace generic exceptions with typed errors, and improve naming to reflect responsibility?"
              },
              "baseline_response": "### Executive Summary\nTo resolve the instability, we will move from an **Imperative Monolithic Handler** to a **Command-Driven Architecture with Explicit State Machines**. This shifts the system from \"doing stuff when called\" to \"receiving a valid command and transitioning through defined states,\" inherently solving state-skipping and resource-leak issues.\n\n**Team Size:** 10 Engineers (2 parallel streams recommended).\n**Timeline:** 4 Sprints (approx. 8\u201310 weeks).\n\n---\n\n### The Incremental Refactor Plan\n\n#### Phase 1: Stabilization & Discovery (Sprint 1)\n*Goal: Stop the bleeding and map the chaos.*\n*   **Milestone:** Introduce Observability & Extract Magic Strings.\n*   **Actions:**\n    *   Implement a generic `TaskContext` wrapper to track all internal state variables.\n    *   Replace all magic strings (e.g., `\"status=1\"`) with Enum/DTO constants.\n    *   Add centralized error logging for all uncaught exceptions.\n    *   **Outcome:** You now see *why* it fails, even if you can't fix it yet.\n\n#### Phase 2: Command Pattern Injection (Sprint 2)\n*Goal: Decouple business logic from execution flow.*\n*   **Milestone:** New API Layer accepts Commands.\n*   **Actions:**\n    *   Create a `TaskCommand` base class.\n    *   The legacy handler becomes a thin wrapper: `HandleCommand(command)`.\n    *   The actual logic is extracted into a separate `TaskOrchestrator` class.\n*   **Outcome:** The \"side effects\" (API calls, DB writes) are no longer mixed with business rules.\n\n#### Phase 3: State Machine & Cleanup (Sprint 3)\n*Goal: Fix state skipping and resource leaks.*\n*   **Milestone:** Explicit State Transitions.\n*   **Actions:**\n    *   Implement a State Machine (using a library like XState, Automata, or a custom implementation).\n    *   Define **Entry** and **Exit** actions for every state.\n    *   *Crucial:* Add a \"Cleanup/Dispose\" step to the `Exit` action of the final states (e.g., `TaskCompleted`) to release database locks and file handles, solving the resource growth issue.\n*   **Outcome:** State transitions are explicit; you cannot accidentally jump from 'Pending' to 'Completed' without triggering the required 'Start' logic.\n\n#### Phase 4: Standardization & Rollout (Sprint 4)\n*Goal: Naming consistency and validation.*\n*   **Milestone:** Strict Business Rules Layer.\n*   **Actions:**\n    *   Extract business rules into a `TaskValidator` service.\n    *   Enforce a \"Idempotency Key\" on all incoming commands to prevent duplicate processing.\n    *   Rename all ambiguous variables to match the domain model.\n*   **Outcome:** Consistent names; same input always produces same output.\n\n---\n\n### Representative Examples\n\n#### 1. State Transition Logic\n**Problem:** Implicit jumps and missing error handling.\n\n*   **Before (The Legacy \"Spaghetti\"):**\n    ```python\n    def process_task(task):\n        # Implicit state logic, hard to track execution\n        if task.status == \"PENDING\":\n            task.status = \"PROCESSING\"\n            try:\n                task.data = do_work()\n                task.status = \"DONE\"\n            except:\n                task.status = \"ERROR\" # Risk: Did we skip the 'Cleanup' step?\n    ```\n\n*   **After (Explicit State Machine):**\n    ```python\n    # Use a state machine library or custom switch\n    def transition_task(command, state):\n        # Explicit validation before movement\n        if not TransitionValidator.can_move(state, command.action):\n            raise InvalidTransitionError(f\"Cannot {command.action} from {state}\")\n\n        # Execute Logic\n        result = Orchestrator.execute(command)\n\n        # Explicit Action (e.g., closing connections) tied to the state change\n        if state == \"PROCESSING\" and result.success:\n            CleanupManager.release_resources(command.resource_id)\n\n        return new_state\n    ```\n\n#### 2. Failure Handling\n**Problem:** Ambiguous responses; callers don't know what failed.\n\n*   **Before (Generic):**\n    ```python\n    try:\n        # ... heavy processing ...\n        return {\"status\": \"200 OK\"}\n    except Exception as e:\n        # Callers don't know if it was a DB timeout or a timeout in the logic\n        raise Exception(\"Internal Server Error\")\n    ```\n\n*   **After (Structured):**\n    ```python\n    try:\n        # ... heavy processing ...\n    except DatabaseConnectionError as e:\n        raise TaskFailureException(\n            error_code=\"DB_TIMEOUT\",\n            message=\"Connection pool exhausted. Please retry.\",\n            retryable=True\n        )\n    except BusinessRuleViolation as e:\n        raise TaskFailureException(\n            error_code=\"RULE_VIOLATION\",\n            message=f\"Missing approval: {e.reason}\",\n            retryable=False\n        )\n    ```\n\n#### 3. Naming Consistency\n**Problem:** Different parts of the system call the same concept by different names.\n\n*   **Before (Inconsistent):**\n    ```text\n    /api/v1/tasks/1/complete\n    /api/v1/workflows/run?id=1\n    /api/ops/finish-task?id=1\n    ```\n\n*   **After (Unified):**\n    ```text\n    /api/v1/tasks/{taskId}/actions/COMPLETE\n    ```\n    *Unified API contract:* All requests to the task service now go through a single endpoint that accepts a standardized JSON payload.\n    ```json\n    {\n      \"taskId\": \"123\",\n      \"action\": \"COMPLETE\",\n      \"payload\": { \"notes\": \"Completed manually\" }\n    }\n    ```\n\n---\n\n### Rollback Strategy\nGiven the incremental approach, the risk is low, but strict safeguards are in place:\n1.  **Feature Flagging:** The old handler remains active behind a flag `legacy_handler_enabled=true`.\n2.  **Database Migrations:** Use transactions for schema changes. If migration fails, rollback script is auto-executed.\n3.  **Backward Compatibility:** Keep the old HTTP endpoints for 3 months, redirecting them to the new command handler until the UI is updated.\n\n### Success Criteria\n*   **Reliability:** Reduction in state-skipping bugs by >90%.\n*   **Observability:** Every state transition logs a structured event with correlation IDs.\n*   **Performance:** Zero memory leak detected after running 24-hour load tests.\n*   **Maintainability:** A new engineer can read a single `TaskStateMachine` definition and understand all valid behaviors.",
              "skill_response": "# Refactor Plan: Legacy Task Service\n\nApplying **All Principles Compressed** to stabilize the Task Service. The goal is to move from implicit, brittle state to explicit invariants, and from implicit dependencies to pure, testable domains.\n\n## Architecture Overview\n\n1.  **Domain State**: Explicit enums (no boolean flags).\n2.  **Core Logic**: Pure functions for state transitions and business rules (independent of DB/IO).\n3.  **Ports**: Interface definitions (Repository, Clock, EventPublisher).\n4.  **Adapters**: Implementation of Ports (DB ORM, System Time, HTTP).\n5.  **Composition**: Wiring Core and Adapters with explicit error handling and resource ownership.\n\n---\n\n## Incremental Delivery Plan (Team of 10)\n\n### Milestone 1: Model State & Invariants (Week 1)\n**Objective:** Eliminate the \"boolean flag explosion\" and invalid state transitions.\n**Action:** Redefine the domain model using strict types.\n**Rollback:** Low risk. New types do not break existing compiled code; they only affect new interactions.\n\n### Milestone 2: Extract Pure Core (Week 2)\n**Objective:** Separate business decisions from infrastructure.\n**Action:** Move logic from Controllers to a pure `TaskProcessor` struct. Remove DB/HTTP imports from domain logic.\n**Rollback:** Low risk. Old controller can be left in place pointing to the *new* core if needed.\n\n### Milestone 3: Port/Adapter Boundary & Wiring (Week 3)\n**Objective:** Define explicit dependencies and handle errors correctly.\n**Action:** Define `TaskRepository`, `Clock`, and `NotificationService` interfaces. Implement DB adapters.\n**Rollback:** Medium risk. Requires database migration or careful transaction handling, but does not require redeployment of business rules.\n\n### Milestone 4: Policy/Mechanism Decoupling & Cleanup (Week 4)\n**Objective:** Allow configuration changes without code modification and guarantee resource cleanup.\n**Action:** Externalize timeout logic to a config object. Ensure adapters handle resource acquisition/release deterministically.\n**Rollback:** Low/Medium risk. Requires monitoring of resource usage.\n\n---\n\n## Representative Examples\n\n### 1. State Transition Logic\n**Problem:** Previous code used `int status` or boolean flags (`isCompleted`), allowing invalid states like \"Completed but not Paid\" without checks.\n\n**Before:**\n```typescript\n// State is implicit, invalid states possible\nfunction startTask(task: Task) {\n    if (task.status === 'COMPLETED') throw new Error(\"Cannot start completed task\");\n    // Logic relies on magic strings and flags\n    if (!task.dependenciesMet) throw new Error(\"Missing deps\");\n    task.status = 'IN_PROGRESS';\n}\n```\n\n**After (Applying Skill):**\n```typescript\n// State is explicit and invalid states unrepresentable\ntype TaskStatus = 'TODO' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';\n\ninterface Task {\n    id: TaskId;\n    status: TaskStatus;\n    // Other fields...\n}\n\n// Core: Pure function, no side effects\nfunction transition(task: Task, event: StartEvent, dependenciesMet: boolean): Result<Task, TransitionError> {\n    // Illegal states are checked at type level, but logic enforced here\n    if (!dependenciesMet) return Err(TransitionError.DependenciesNotMet);\n    \n    const nextStatus: TaskStatus = 'IN_PROGRESS';\n    return Ok({ ...task, status: nextStatus });\n}\n```\n\n### 2. Failure Handling\n**Problem:** Generic exceptions and null returns made it impossible to distinguish \"Task not found\" from \"Database timeout\".\n\n**Before:**\n```java\npublic TaskDTO executeTask(Long id) {\n    Task task = repository.findById(id); // null if not found\n    if (task == null) return null; // Caller thinks it's \"success\" with no data\n    \n    try {\n        // Side effects in domain logic\n        task = doWork(task); \n        repository.save(task);\n        return mapper.toDTO(task);\n    } catch (Exception e) {\n        // Swallows context\n        throw new RuntimeException(\"Processing failed\");\n    }\n}\n```\n\n**After (Applying Skill):**\n```rust\n// Core: Returns explicit Result types\npub async fn execute_task(id: TaskId, repo: &dyn TaskRepo) -> Result<Task, TaskError> {\n    let mut task = repo.load(id)\n        .map_err(|_| TaskError::NotFound)?; // Infrastructure error separated from Domain error\n\n    // Pure Logic\n    let result = task.execute_policy(repo.get_config()); // Policy separated\n    \n    match result {\n        Ok(executed_task) => repo.save(executed_task),\n        Err(e) => repo.mark_failed(id, e),\n    }\n}\n\n// Enum: Explicit error types\nenum TaskError {\n    NotFound,\n    Timeout(String), // Domain error with context\n    StorageFailure,  // Infrastructure error\n}\n```\n\n### 3. Naming & Policy\n**Problem:** \"doStuff\", \"update\", \"handler\". No clear business intent. Policies hardcoded in loops.\n\n**Before:**\n```java\n// Cryptic name and hardcoded policy\npublic void handleTask(Task t) {\n    if (t.getAge() > 30) { // Policy mixed in logic\n        t.setCancelled();\n        t.save();\n    }\n    // ...\n}\n```\n\n**After (Applying Skill):**\n```typescript\n// Names express domain intent; Policy is data\ninterface TaskProcessingConfig {\n    maxExecutionDays: number;\n    autoExpire: boolean;\n}\n\nfunction processTask(task: Task, config: TaskProcessingConfig): Result<Task, Error> {\n    const isExpired = is_expired(task.created_at, config.maxExecutionDays); // Mechanism separates from Policy (config)\n    \n    if (isExpired) {\n        return task.expire(); // Domain intentful name\n    }\n    \n    return task.mark_awaiting_review();\n}\n```\n\n---\n\n## Success Criteria (AI Review Checklist)\n\nBefore declaring the sprint done, verify:\n\n-   [ ] **Invariants**: The `Task` type has a strict `status` enum. No invalid combinations (e.g., status cannot be 'COMPLETED' if not actually finished).\n-   [ ] **Pure Core**: `TaskProcessor` functions accept only inputs and return `Result<T, Error>`. No DB calls or `console.log` inside the core module.\n-   [ ] **Ports/Adapters**: `TaskRepository` interface is defined. The DB driver implementation is isolated in the adapter layer.\n-   [ ] **One-Way Flow**: Updates flow: `Input -> Core -> Validation -> State Update -> Adapter Persistence`.\n-   [ ] **Error Handling**: All public interfaces return `Result` or `TaskError`. No `null` returns. Infrastructure errors are caught and wrapped in domain errors or surfaced clearly.\n-   [ ] **Resources**: DB connections are acquired and released within the adapter scope (deterministic lifecycle).\n-   [ ] **Naming**: Functions are named `mark_completed`, `calculate_priority`, not `update`, `do_calc`.\n\n## Rollback Strategy\n\n1.  **Feature Flag**: Wrap the new `TaskService` invocation behind a flag (e.g., `use_new_task_logic`).\n2.  **Database**: Keep the schema changes in a separate migration file that can be reverted.\n3.  **Backwards Compatibility**: If the new response types differ from the old DTOs, keep the Adapter layer map the new `Task` entity back to the old DTO format during the transition period."
            }
          ]
        }
      ]
    }
  ],
  "summary": {
    "total_benchmarks": 1,
    "leaderboard": [
      {
        "model": "glm-4.7-flash:q4_K_M",
        "provider": "ollama",
        "total_tested": 1,
        "improvements": 1,
        "improvement_rate": 100.0
      }
    ]
  },
  "unique_skills": [
    "ps-all-principles-compressed"
  ],
  "provider_models": [
    [
      "ollama",
      "glm-4.7-flash:q4_K_M"
    ]
  ]
}