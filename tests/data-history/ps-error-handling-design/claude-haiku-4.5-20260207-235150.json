{
  "skill": "ps-error-handling-design",
  "severity": "WARN",
  "model": "claude-haiku-4.5",
  "skill_version": "1.0.0",
  "baseline_rate": 100,
  "skill_rate": 100,
  "baseline_rating": "good",
  "skill_rating": "outstanding",
  "baseline_pass_count": "2/2",
  "skill_pass_count": "2/2",
  "improvement": 0,
  "judge_error": false,
  "results": [
    {
      "name": "auth_error_handling",
      "input": "The current `login` function returns `null` if anything goes wrong (user missing, wrong password, db down). This leads to a generic \"Login Failed\" error on the frontend, which frustrates users who might just have a typo, and confuses support teams when the DB is actually down.\n\nRefactor the return values/mechanism so the caller can definitively distinguish between:\n1. Invalid Credentials (user actionable)\n2. Account Locked (user actionable)\n3. System/Network Failure (retryable)\n\nProvide the code for the logic and the data structures used.",
      "expected": {
        "focus": "Does the solution return structured error info (e.g., error codes, types) instead of a generic null/false?"
      },
      "baseline": {
        "pass": true,
        "response_preview": "I'll provide the refactored code structure for distinguishing login failures:\n\n## Data Structures\n\n`...",
        "response_full": "I'll provide the refactored code structure for distinguishing login failures:\n\n## Data Structures\n\n```typescript\n// Define error types as an enum\nenum LoginErrorType {\n  INVALID_CREDENTIALS = \"INVALID_CREDENTIALS\",\n  ACCOUNT_LOCKED = \"ACCOUNT_LOCKED\",\n  SYSTEM_FAILURE = \"SYSTEM_FAILURE\"\n}\n\n// Result type for login function\ntype LoginResult = \n  | { success: true; user: User; token: string }\n  | { success: false; error: LoginErrorType; message: string; retryable: boolean };\n```\n\n## Refactored Login Function\n\n```typescript\nasync function login(email: string, password: string): Promise<LoginResult> {\n  try {\n    // Attempt database connection\n    const user = await db.users.findByEmail(email);\n    \n    // User not found\n    if (!user) {\n      return {\n        success: false,\n        error: LoginErrorType.INVALID_CREDENTIALS,\n        message: \"Invalid email or password\",\n        retryable: false\n      };\n    }\n    \n    // Check if account is locked\n    if (user.lockedUntil && user.lockedUntil > new Date()) {\n      return {\n        success: false,\n        error: LoginErrorType.ACCOUNT_LOCKED,\n        message: `Account locked until ${user.lockedUntil.toISOString()}`,\n        retryable: false\n      };\n    }\n    \n    // Verify password\n    const isValid = await bcrypt.compare(password, user.passwordHash);\n    if (!isValid) {\n      // Increment failed attempts\n      await db.users.incrementFailedAttempts(user.id);\n      \n      return {\n        success: false,\n        error: LoginErrorType.INVALID_CREDENTIALS,\n        message: \"Invalid email or password\",\n        retryable: false\n      };\n    }\n    \n    // Reset failed attempts on success\n    await db.users.resetFailedAttempts(user.id);\n    \n    // Generate token\n    const token = generateJWT(user);\n    \n    return {\n      success: true,\n      user,\n      token\n    };\n    \n  } catch (error) {\n    // Network/database/system failures\n    if (error instanceof DatabaseConnectionError || \n        error instanceof NetworkTimeoutError) {\n      return {\n        success: false,\n        error: LoginErrorType.SYSTEM_FAILURE,\n        message: \"Service temporarily unavailable. Please try again later.\",\n        retryable: true\n      };\n    }\n    \n    // Log unexpected errors\n    logger.error(\"Login error:\", error);\n    \n    return {\n      success: false,\n      error: LoginErrorType.SYSTEM_FAILURE,\n      message: \"An unexpected error occurred. Please try again.\",\n      retryable: true\n    };\n  }\n}\n```\n\n## Frontend Usage\n\n```typescript\nconst result = await login(email, password);\n\nif (result.success) {\n  // Login successful\n  localStorage.setItem('token', result.token);\n  navigateTo('/dashboard');\n} else {\n  switch (result.error) {\n    case LoginErrorType.INVALID_CREDENTIALS:\n      showError(\"Invalid email or password. Check for typos.\");\n      break;\n    case LoginErrorType.ACCOUNT_LOCKED:\n      showError(result.message);\n      disableRetryButton(); // Don't allow immediate retry\n      break;\n    case LoginErrorType.SYSTEM_FAILURE:\n      showError(result.message);\n      enableRetryButton(); // Allow retry for transient failures\n      break;\n  }\n}\n```\n\n## Key Benefits\n\n- **Type-safe**: TypeScript compiler enforces handling all error cases\n- **Actionable frontend**: Different error types trigger different UI responses\n- **Support clarity**: System teams can diagnose by error type, not generic \"Login Failed\"\n- **User-friendly**: Invalid credentials message doesn't reveal account enumeration info\n- **Retryable flag**: Frontend can intelligently show/hide retry options"
      },
      "skill": {
        "pass": true,
        "response_preview": "# Explicit Error Handling for Login\n\nHere's the refactored implementation using a Result type patter...",
        "response_full": "# Explicit Error Handling for Login\n\nHere's the refactored implementation using a Result type pattern:\n\n## Data Structures\n\n```typescript\n// Error type definitions\ntype LoginError = \n  | { type: \"INVALID_CREDENTIALS\"; attemptedUsername: string }\n  | { type: \"ACCOUNT_LOCKED\"; lockedUntil: Date; reason: string }\n  | { type: \"SYSTEM_FAILURE\"; cause: \"DATABASE\" | \"NETWORK\"; retryable: true }\n\n// Result wrapper type\ntype Result<T, E> = \n  | { success: true; value: T }\n  | { success: false; error: E }\n\n// Success type\ninterface LoginSuccess {\n  userId: string\n  token: string\n  sessionId: string\n}\n```\n\n## Refactored Login Function\n\n```typescript\nfunction login(username: string, password: string): Result<LoginSuccess, LoginError> {\n  // Validate input first (prevents null pointer errors)\n  if (!username?.trim() || !password) {\n    return {\n      success: false,\n      error: { type: \"INVALID_CREDENTIALS\", attemptedUsername: username }\n    }\n  }\n\n  try {\n    // Try to fetch user from database\n    const user = database.findByUsername(username)\n    \n    // User not found = invalid credentials (expected business failure)\n    if (!user) {\n      return {\n        success: false,\n        error: { type: \"INVALID_CREDENTIALS\", attemptedUsername: username }\n      }\n    }\n\n    // Check if account is locked (expected domain rule)\n    if (user.isLocked) {\n      return {\n        success: false,\n        error: {\n          type: \"ACCOUNT_LOCKED\",\n          lockedUntil: user.lockedUntil,\n          reason: \"Too many failed attempts\"\n        }\n      }\n    }\n\n    // Verify password (expected business check)\n    const passwordMatch = crypto.compare(password, user.passwordHash)\n    if (!passwordMatch) {\n      // Increment failed attempts\n      user.failedAttempts += 1\n      if (user.failedAttempts >= 5) {\n        user.isLocked = true\n        user.lockedUntil = new Date(Date.now() + 30 * 60 * 1000) // 30 min\n      }\n      database.updateUser(user)\n\n      return {\n        success: false,\n        error: { type: \"INVALID_CREDENTIALS\", attemptedUsername: username }\n      }\n    }\n\n    // Success path\n    const token = generateJWT(user.id)\n    user.failedAttempts = 0 // Reset on success\n    database.updateUser(user)\n\n    return {\n      success: true,\n      value: {\n        userId: user.id,\n        token,\n        sessionId: generateSessionId()\n      }\n    }\n\n  } catch (error) {\n    // Infrastructure failure (non-recoverable at this layer)\n    // Distinguish by error type\n    if (error instanceof DatabaseError) {\n      return {\n        success: false,\n        error: { type: \"SYSTEM_FAILURE\", cause: \"DATABASE\", retryable: true }\n      }\n    }\n    \n    if (error instanceof NetworkError) {\n      return {\n        success: false,\n        error: { type: \"SYSTEM_FAILURE\", cause: \"NETWORK\", retryable: true }\n      }\n    }\n\n    // Unexpected error = programming error, crash\n    throw error\n  }\n}\n```\n\n## Caller Usage Pattern\n\n```typescript\nfunction handleLoginRequest(username: string, password: string): HttpResponse {\n  const result = login(username, password)\n\n  if (result.success) {\n    // Happy path: user authenticated\n    return {\n      status: 200,\n      body: { token: result.value.token, sessionId: result.value.sessionId }\n    }\n  }\n\n  // Error handling by type\n  switch (result.error.type) {\n    case \"INVALID_CREDENTIALS\":\n      // User actionable - they made a mistake\n      return {\n        status: 401,\n        body: { error: \"Invalid username or password\" }\n      }\n\n    case \"ACCOUNT_LOCKED\":\n      // User actionable - tell them when they can try again\n      return {\n        status: 403,\n        body: {\n          error: \"Account locked due to too many failed attempts\",\n          lockedUntil: result.error.lockedUntil,\n          retryAfter: Math.ceil((result.error.lockedUntil.getTime() - Date.now()) / 1000)\n        }\n      }\n\n    case \"SYSTEM_FAILURE\":\n      // Retryable infrastructure failure\n      logger.error(\"Login system failure\", {\n        cause: result.error.cause,\n        timestamp: new Date(),\n        username\n      })\n\n      if (result.error.cause === \"DATABASE\") {\n        // Maybe retry with exponential backoff internally\n        return {\n          status: 503,\n          body: { error: \"Database temporarily unavailable. Please try again.\" }\n        }\n      } else {\n        // Network error\n        return {\n          status: 503,\n          body: { error: \"Service temporarily unavailable. Please try again.\" }\n        }\n      }\n  }\n}\n```\n\n## Key Improvements\n\n1. **Explicit return type**: `Result<LoginSuccess, LoginError>` makes failure modes visible\n2. **Categorized errors**: Domain errors (invalid creds, locked) vs infrastructure errors\n3. **Type-safe handling**: Caller's compiler forces handling all error cases\n4. **User actionable**: Each error provides specific guidance (retry when, why locked, etc.)\n5. **Support friendly**: Logs distinguish between user error and system failure\n6. **No null returns**: Errors are explicit values, not absence of a value\n\nThe caller can now implement retry logic only for `SYSTEM_FAILURE`, provide specific UI messages for `INVALID_CREDENTIALS`, and handle `ACCOUNT_LOCKED` with countdown timers\u2014all because the error type makes these distinctions explicit."
      }
    },
    {
      "name": "robust_registration_design",
      "input": "We need to process a batch of user imports. Some might have invalid data, others might fail due to database constraint violations.\n\nwrite a processor function that handles these failures appropriately:\n- Invalid data: Skip and report.\n- DB Constraint: Skip and report.\n- DB Connection Loss: Stop processing and throw/alert.\n\nShow how you distinguish these cases in code.",
      "expected": {
        "focus": "Does the code differentiate between recoverable item-level errors and fatal batch-level errors?"
      },
      "baseline": {
        "pass": true,
        "response_preview": "```javascript\nclass UserImportProcessor {\n  async processBatch(users) {\n    const results = { proces...",
        "response_full": "```javascript\nclass UserImportProcessor {\n  async processBatch(users) {\n    const results = { processed: 0, skipped: 0, errors: [] };\n    \n    for (const user of users) {\n      try {\n        await this.validateAndInsert(user);\n        results.processed++;\n      } catch (error) {\n        // Distinguish error types\n        if (this.isValidationError(error)) {\n          results.errors.push({\n            type: 'INVALID_DATA',\n            user: user.id,\n            reason: error.message\n          });\n          results.skipped++;\n        } \n        else if (this.isConstraintError(error)) {\n          results.errors.push({\n            type: 'DB_CONSTRAINT',\n            user: user.id,\n            reason: error.message\n          });\n          results.skipped++;\n        } \n        else if (this.isConnectionError(error)) {\n          // Stop immediately on connection loss\n          results.errors.push({\n            type: 'DB_CONNECTION_LOST',\n            user: user.id,\n            reason: error.message\n          });\n          throw new Error(`Processing halted at user ${user.id}: Connection lost`);\n        } \n        else {\n          // Unknown error - also stop\n          throw error;\n        }\n      }\n    }\n    \n    return results;\n  }\n  \n  isValidationError(error) {\n    return error.name === 'ValidationError' || \n           error.code === 'INVALID_DATA' ||\n           error instanceof ValidationError;\n  }\n  \n  isConstraintError(error) {\n    // Check for database-specific constraint violation codes\n    return error.code === 'ER_DUP_ENTRY' ||           // MySQL duplicate key\n           error.code === '23505' ||                   // PostgreSQL unique violation\n           error.code === 'SQLITE_CONSTRAINT' ||       // SQLite\n           error.constraint !== undefined ||           // Generic constraint property\n           error.message?.includes('UNIQUE constraint failed') ||\n           error.message?.includes('duplicate key');\n  }\n  \n  isConnectionError(error) {\n    return error.code === 'ECONNREFUSED' ||\n           error.code === 'ENOTFOUND' ||\n           error.code === 'PROTOCOL_CONNECTION_LOST' ||\n           error.code === 'PROTOCOL_SEQUENCE_TIMEOUT' ||\n           error.message?.includes('connection') && \n           (error.message?.includes('lost') || \n            error.message?.includes('refused') ||\n            error.message?.includes('timeout'));\n  }\n  \n  async validateAndInsert(user) {\n    // Validation happens first\n    if (!user.email || !user.name) {\n      const error = new Error('Missing required fields');\n      error.code = 'INVALID_DATA';\n      throw error;\n    }\n    \n    // Database insert\n    return await db.users.insert(user);\n  }\n}\n\n// Usage\nconst processor = new UserImportProcessor();\ntry {\n  const results = await processor.processBatch(users);\n  console.log(`Processed: ${results.processed}, Skipped: ${results.skipped}`);\n  console.log('Skipped errors:', results.errors);\n} catch (error) {\n  console.error('CRITICAL - Processing stopped:', error.message);\n  // Alert/notify system of connection loss\n  await notificationService.alert(error.message);\n}\n```\n\n**Key distinctions:**\n- **Validation errors**: Caught immediately, skipped with error logged\n- **Constraint errors**: DB-specific codes (ER_DUP_ENTRY, 23505) caught, skipped with error logged  \n- **Connection errors**: ECONNREFUSED, ENOTFOUND, PROTOCOL_* codes trigger immediate halt with throw/alert"
      },
      "skill": {
        "pass": true,
        "response_preview": "# User Import Processor with Explicit Error Handling\n\nHere's a solution applying the principle\u2014disti...",
        "response_full": "# User Import Processor with Explicit Error Handling\n\nHere's a solution applying the principle\u2014distinguishing **recoverable domain errors** (skip & report) from **non-recoverable infrastructure errors** (fail-fast):\n\n```typescript\n// ============ Error Types ============\n\n// Domain errors: Recoverable, return as Result\ntype ValidationError = {\n  type: \"VALIDATION_ERROR\";\n  field: string;\n  message: string;\n  userId: string;\n};\n\ntype ConstraintError = {\n  type: \"CONSTRAINT_VIOLATION\";\n  constraint: string;\n  message: string;\n  userId: string;\n};\n\ntype DomainError = ValidationError | ConstraintError;\n\n// Result type: Forces callers to handle both paths\ntype Result<T, E> = { ok: true; value: T } | { ok: false; error: E };\n\n// Infrastructure errors: Non-recoverable, thrown directly\nclass DatabaseConnectionError extends Error {\n  constructor(message: string, readonly originalError: Error) {\n    super(`Database connection lost: ${message}`);\n    this.name = \"DatabaseConnectionError\";\n  }\n}\n\n// ============ Domain Logic Layer ============\n\nfunction validateUser(data: any): Result<User, ValidationError> {\n  if (!data.email || !data.email.includes(\"@\")) {\n    return {\n      ok: false,\n      error: {\n        type: \"VALIDATION_ERROR\",\n        field: \"email\",\n        message: \"Invalid email format\",\n        userId: data.id,\n      },\n    };\n  }\n  if (!data.name || data.name.trim().length === 0) {\n    return {\n      ok: false,\n      error: {\n        type: \"VALIDATION_ERROR\",\n        field: \"name\",\n        message: \"Name cannot be empty\",\n        userId: data.id,\n      },\n    };\n  }\n  return { ok: true, value: { id: data.id, email: data.email, name: data.name } };\n}\n\n// ============ Infrastructure Layer ============\n\nasync function insertUserToDatabase(\n  user: User,\n  db: Database\n): Promise<Result<User, ConstraintError>> {\n  try {\n    // Non-recoverable: connection lost mid-operation\n    const saved = await db.users.insert(user);\n    return { ok: true, value: saved };\n  } catch (error) {\n    // Distinguish error type\n    if (error instanceof DatabaseConnectionError) {\n      // Non-recoverable: PROPAGATE immediately (rethrow)\n      throw error;\n    }\n\n    if (error.code === \"UNIQUE_VIOLATION\" && error.constraint === \"email\") {\n      // Recoverable: Return as Result\n      return {\n        ok: false,\n        error: {\n          type: \"CONSTRAINT_VIOLATION\",\n          constraint: \"email_unique\",\n          message: `Email already exists: ${user.email}`,\n          userId: user.id,\n        },\n      };\n    }\n\n    // Unknown DB error: Treat as non-recoverable (safer)\n    throw new DatabaseConnectionError(\n      `Unexpected database error: ${error.message}`,\n      error\n    );\n  }\n}\n\n// ============ Application Layer (Processor) ============\n\ntype ImportReport = {\n  processed: number;\n  succeeded: number;\n  skipped: { id: string; reason: string; error: DomainError }[];\n};\n\nasync function processBatchUserImport(\n  users: any[],\n  db: Database\n): Promise<ImportReport> {\n  const report: ImportReport = {\n    processed: 0,\n    succeeded: 0,\n    skipped: [],\n  };\n\n  for (const userData of users) {\n    try {\n      report.processed++;\n\n      // Step 1: Validate (domain layer)\n      const validationResult = validateUser(userData);\n      if (!validationResult.ok) {\n        // Recoverable: Skip and report\n        report.skipped.push({\n          id: userData.id,\n          reason: \"validation_failed\",\n          error: validationResult.error,\n        });\n        continue; // Move to next user\n      }\n\n      // Step 2: Persist (infrastructure layer)\n      const insertResult = await insertUserToDatabase(validationResult.value, db);\n      if (!insertResult.ok) {\n        // Recoverable: Skip and report\n        report.skipped.push({\n          id: userData.id,\n          reason: \"constraint_violation\",\n          error: insertResult.error,\n        });\n        continue; // Move to next user\n      }\n\n      // Success path\n      report.succeeded++;\n    } catch (error) {\n      // Non-recoverable errors reach here\n      if (error instanceof DatabaseConnectionError) {\n        // FAIL FAST: Stop entire batch, alert caller\n        throw new Error(\n          `Batch import aborted at user ${userData.id}: ${error.message}`\n        );\n      }\n\n      // Unexpected error: Safer to fail fast than corrupt data\n      throw error;\n    }\n  }\n\n  return report;\n}\n\n// ============ Presentation Layer (Usage) ============\n\nasync function handleUserImportRequest(req: Request, db: Database) {\n  try {\n    const report = await processBatchUserImport(req.body.users, db);\n\n    if (report.skipped.length > 0) {\n      // Recoverable errors: Send detailed report\n      return {\n        status: 207, // Partial success\n        body: {\n          message: `Imported ${report.succeeded}/${report.processed} users`,\n          skipped: report.skipped.map((item) => ({\n            userId: item.id,\n            reason: item.error.type,\n            detail: item.error.message,\n          })),\n        },\n      };\n    }\n\n    return {\n      status: 200,\n      body: { message: `Successfully imported ${report.succeeded} users` },\n    };\n  } catch (error) {\n    if (error instanceof DatabaseConnectionError) {\n      // Non-recoverable: Alert ops, return 503\n      alertOps(`Critical: Database connection lost during import: ${error.message}`);\n      return {\n        status: 503,\n        body: { error: \"Database unavailable. Please retry later.\" },\n      };\n    }\n\n    // Other non-recoverable errors\n    alertOps(`Import processor crash: ${error.message}`);\n    return {\n      status: 500,\n      body: { error: \"Import failed due to unexpected error\" },\n    };\n  }\n}\n```\n\n## Key Distinctions:\n\n| Error Type | Handling | Mechanism | Example |\n|---|---|---|---|\n| **Validation** | Skip & report | Return `Result<T, ValidationError>` | Bad email format |\n| **Constraint** | Skip & report | Return `Result<T, ConstraintError>` | Duplicate email |\n| **Connection Loss** | Fail-fast | `throw DatabaseConnectionError` | Network down |\n\n**Why this works:**\n- \u2705 Compiler forces handling of domain errors (`Result` type)\n- \u2705 Connection errors bypass safe handling (exception), triggering alerts immediately\n- \u2705 Caller can't ignore validation/constraint failures (they're in the type)\n- \u2705 Batch continues for recoverable errors but stops on infrastructure errors\n- \u2705 Report provides actionable feedback for retry/investigation"
      }
    }
  ],
  "judgment": {
    "principle_better": "B",
    "quality_better": "B",
    "overall_better": "B",
    "option_a_rating": "good",
    "option_b_rating": "outstanding",
    "score": 100,
    "reasoning": "Solution A demonstrates solid understanding of Result types in the login example but undermines the principle in the UserImportProcessor by using try-catch blocks to handle domain errors (validation, constraints), violating the core tenet of avoiding exceptions for domain errors. Solution B consistently applies Result types for all domain errors across both examples, properly distinguishes recoverable errors (returned) from non-recoverable ones (thrown), and provides clear separation across layers with explicit error handling throughout\u2014achieving true mastery of the pattern rather than partial application."
  },
  "timestamp": "2026-02-07T23:51:50",
  "provider": "copilot"
}