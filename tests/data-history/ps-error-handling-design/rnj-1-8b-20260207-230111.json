{
  "skill": "ps-error-handling-design",
  "severity": "WARN",
  "model": "rnj-1:8b",
  "skill_version": "1.0.0",
  "baseline_rate": 100,
  "skill_rate": 100,
  "baseline_rating": "outstanding",
  "skill_rating": "outstanding",
  "baseline_pass_count": "2/2",
  "skill_pass_count": "2/2",
  "improvement": 0,
  "judge_error": true,
  "results": [
    {
      "name": "auth_error_handling",
      "input": "The current `login` function returns `null` if anything goes wrong (user missing, wrong password, db down). This leads to a generic \"Login Failed\" error on the frontend, which frustrates users who might just have a typo, and confuses support teams when the DB is actually down.\n\nRefactor the return values/mechanism so the caller can definitively distinguish between:\n1. Invalid Credentials (user actionable)\n2. Account Locked (user actionable)\n3. System/Network Failure (retryable)\n\nProvide the code for the logic and the data structures used.",
      "expected": {
        "focus": "Does the solution return structured error info (e.g., error codes, types) instead of a generic null/false?"
      },
      "baseline": {
        "pass": true,
        "response_preview": "To refactor the `login` function, we need to define a structure that can return different types of e...",
        "response_full": "To refactor the `login` function, we need to define a structure that can return different types of errors with specific messages. We'll use a dictionary to represent the error types and their corresponding messages. Here's how you can refactor the `login` function:\n\n```python\n# Define error types\nERROR_TYPES = {\n    \"INVALID_CREDENTIALS\": \"Invalid username or password.\",\n    \"ACCOUNT_LOCKED\": \"Account is locked. Please contact support.\",\n    \"SYSTEM_FAILURE\": \"System failure. Please try again later.\",\n}\n\ndef login(username, password):\n    \"\"\"\n    Simulate a login function that checks credentials and returns appropriate error types.\n    \"\"\"\n    # Simulate database lookup\n    user_data = {\n        \"username\": \"testuser\",\n        \"password\": \"testpass\",\n        \"locked\": False,\n    }\n\n    # Simulate database failure\n    db_failure = False  # Set to True to simulate a database failure\n\n    if db_failure:\n        return {\"error_type\": \"SYSTEM_FAILURE\", \"message\": ERROR_TYPES[\"SYSTEM_FAILURE\"]}\n\n    if username != user_data[\"username\"] or password != user_data[\"password\"]:\n        return {\"error_type\": \"INVALID_CREDENTIALS\", \"message\": ERROR_TYPES[\"INVALID_CREDENTIALS\"]}\n\n    if user_data[\"locked\"]:\n        return {\"error_type\": \"ACCOUNT_LOCKED\", \"message\": ERROR_TYPES[\"ACCOUNT_LOCKED\"]}\n\n    # If everything is fine, return a success message\n    return {\"status\": \"SUCCESS\", \"message\": \"Login successful!\"}\n\n# Example usage\nresult = login(\"testuser\", \"wrongpass\")\nprint(result)\n\nresult = login(\"testuser\", \"testpass\")\nprint(result)\n\nresult = login(\"testuser\", \"testpass\")\nprint(result)\n```\n\nIn this refactored code:\n- We define a dictionary `ERROR_TYPES` to hold error messages for different error types.\n- The `login` function now returns a dictionary with `error_type` and `message` keys for different error scenarios.\n- The function checks for database failure, invalid credentials, and locked accounts, returning appropriate error types.\n- If everything is fine, it returns a success message.\n\nThis approach allows the caller to definitively distinguish between different types of errors, providing a better user experience and easier debugging for support teams."
      },
      "skill": {
        "pass": true,
        "response_preview": "```python\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Optional, Union...",
        "response_full": "```python\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Optional, Union\n\nclass LoginError(Enum):\n    INVALID_CREDENTIALS = \"Invalid credentials\"\n    ACCOUNT_LOCKED = \"Account locked\"\n    SYSTEM_ERROR = \"System error\"\n\n@dataclass\nclass LoginResult:\n    success: bool\n    error: Optional[LoginError] = None\n\ndef login(username: str, password: str) -> LoginResult:\n    \"\"\"\n    Authenticates a user with the given credentials.\n    \n    Args:\n        username: The username to authenticate\n        password: The password to authenticate\n        \n    Returns:\n        LoginResult: A result object indicating success or failure\n    \"\"\"\n    # Simulate database lookup and authentication logic\n    # In a real implementation, this would query the database\n    # and verify the credentials\n    \n    # For demonstration purposes, we'll simulate different scenarios\n    # In a real implementation, this would be replaced with actual database access\n    \n    # Simulate different scenarios\n    if username == \"locked_user\":\n        # Simulate locked account\n        return LoginResult(success=False, error=LoginError.ACCOUNT_LOCKED)\n    elif username == \"system_error\":\n        # Simulate system error\n        return LoginResult(success=False, error=LoginError.SYSTEM_ERROR)\n    elif username == \"invalid_user\" or password != \"correct_password\":\n        # Invalid credentials\n        return LoginResult(success=False, error=LoginError.INVALID_CREDENTIALS)\n    else:\n        # Successful login\n        return LoginResult(success=True, error=None)\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test cases\n    test_cases = [\n        (\"valid_user\", \"correct_password\", True, None),\n        (\"invalid_user\", \"wrong_password\", False, LoginError.INVALID_CREDENTIALS),\n        (\"locked_user\", \"any_password\", False, LoginError.ACCOUNT_LOCKED),\n        (\"system_error\", \"any_password\", False, LoginError.SYSTEM_ERROR),\n    ]\n    \n    for username, password, expected_success, expected_error in test_cases:\n        result = login(username, password)\n        assert result.success == expected_success\n        assert result.error == expected_error\n        print(f\"Test passed for {username}: {result}\")\n```"
      }
    },
    {
      "name": "robust_registration_design",
      "input": "We need to process a batch of user imports. Some might have invalid data, others might fail due to database constraint violations.\n\nwrite a processor function that handles these failures appropriately:\n- Invalid data: Skip and report.\n- DB Constraint: Skip and report.\n- DB Connection Loss: Stop processing and throw/alert.\n\nShow how you distinguish these cases in code.",
      "expected": {
        "focus": "Does the code differentiate between recoverable item-level errors and fatal batch-level errors?"
      },
      "baseline": {
        "pass": true,
        "response_preview": "Below is a Python code snippet that demonstrates how to handle different types of failures during a ...",
        "response_full": "Below is a Python code snippet that demonstrates how to handle different types of failures during a batch import process. The code includes error handling for invalid data, database constraint violations, and database connection loss.\n\n```python\nclass DatabaseConnectionError(Exception):\n    \"\"\"Custom exception for database connection errors.\"\"\"\n    pass\n\ndef process_user_import(user_data):\n    \"\"\"\n    Process a single user import.\n    \n    :param user_data: Dictionary containing user data.\n    :return: True if successful, False otherwise.\n    \"\"\"\n    # Simulate processing logic\n    if 'invalid' in user_data:\n        raise ValueError(\"Invalid data\")\n    if 'constraint' in user_data:\n        raise Exception(\"Database constraint violation\")\n    return True\n\ndef process_batch_import(user_data_list):\n    \"\"\"\n    Process a batch of user imports.\n    \n    :param user_data_list: List of dictionaries containing user data.\n    \"\"\"\n    for user_data in user_data_list:\n        try:\n            if not process_user_import(user_data):\n                print(f\"Failed to process user data: {user_data}\")\n        except ValueError as e:\n            print(f\"Invalid data: {e}\")\n        except Exception as e:\n            print(f\"Database constraint violation: {e}\")\n        except DatabaseConnectionError:\n            print(\"Database connection lost. Stopping processing.\")\n            break\n\n# Example usage\nuser_data_list = [\n    {'name': 'Alice'},\n    {'name': 'Bob', 'invalid': True},\n    {'name': 'Charlie', 'constraint': True},\n    {'name': 'David'}\n]\n\nprocess_batch_import(user_data_list)\n```\n\nIn this code:\n- `process_user_import` simulates the processing of a single user import and raises exceptions for invalid data or database constraint violations.\n- `process_batch_import` iterates over a list of user data, handling each import and catching exceptions to distinguish between different types of failures.\n- `DatabaseConnectionError` is a custom exception that can be raised to indicate a database connection loss, which stops the processing."
      },
      "skill": {
        "pass": true,
        "response_preview": "```python\nclass UserImportProcessor:\n    def __init__(self, db_connection):\n        self.db = db_con...",
        "response_full": "```python\nclass UserImportProcessor:\n    def __init__(self, db_connection):\n        self.db = db_connection\n\n    def process_batch(self, users):\n        \"\"\"\n        Process a batch of user imports, handling different types of failures appropriately.\n        \n        Args:\n            users: List of user data dictionaries\n            \n        Returns:\n            dict: Summary of processing results\n        \"\"\"\n        results = {\n            'processed': 0,\n            'invalid_data': 0,\n            'db_constraint': 0,\n            'db_connection_lost': False,\n            'successful': 0\n        }\n        \n        for user in users:\n            try:\n                if not self._validate_user(user):\n                    results['invalid_data'] += 1\n                    continue\n                \n                try:\n                    self._save_user(user)\n                    results['successful'] += 1\n                except DBConstraintError:\n                    results['db_constraint'] += 1\n                    continue\n                    \n            except DBConnectionError:\n                results['db_connection_lost'] = True\n                break\n                \n            results['processed'] += 1\n            \n        return results\n    \n    def _validate_user(self, user):\n        \"\"\"Validate user data format and required fields.\"\"\"\n        # Implementation of validation logic\n        pass\n    \n    def _save_user(self, user):\n        \"\"\"Save user to database.\"\"\"\n        # Implementation of database save logic\n        pass\n\n# Custom exceptions for different error types\nclass DBConstraintError(Exception):\n    pass\n\nclass DBConnectionError(Exception):\n    pass\n```"
      }
    }
  ],
  "timestamp": "2026-02-07T23:01:11",
  "provider": "ollama"
}