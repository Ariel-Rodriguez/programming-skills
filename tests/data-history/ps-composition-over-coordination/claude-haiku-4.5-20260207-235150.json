{
  "skill": "ps-composition-over-coordination",
  "severity": "SUGGEST",
  "model": "claude-haiku-4.5",
  "skill_version": "1.0.0",
  "baseline_rate": 100,
  "skill_rate": 100,
  "baseline_rating": "regular",
  "skill_rating": "outstanding",
  "baseline_pass_count": "2/2",
  "skill_pass_count": "2/2",
  "improvement": 0,
  "judge_error": false,
  "results": [
    {
      "name": "payment_system_design",
      "input": "We are building a new payment processing backend. The current requirement is linear: \n1. Authenticate Request\n2. Validate Input\n3. Fraud Check\n4. Charge Card\n5. Save Receipt\n6. Send Email\n\nHowever, we expect the flow to become much more complex soon (e.g., conditional steps, A/B testing different flows). \n\nWrite code to implement this flow. Focus on making it easy to change the order of steps or add new steps without rewriting the whole flow.",
      "expected": {
        "focus": "Does the solution use small, independent functions/classes? Does it avoid a single giant function that does everything?"
      },
      "baseline": {
        "pass": true,
        "response_preview": "# Payment Processing Flow Engine\n\nHere's a flexible, extensible implementation using a **pipeline pa...",
        "response_full": "# Payment Processing Flow Engine\n\nHere's a flexible, extensible implementation using a **pipeline pattern** that makes it trivial to reorder steps or add new ones:\n\n```typescript\n// Core Flow Engine\ntype StepResult<T> = { success: boolean; data: T; error?: string };\ntype StepHandler<T> = (context: T) => Promise<StepResult<T>>;\n\ninterface PaymentContext {\n  request?: any;\n  validated?: boolean;\n  riskScore?: number;\n  chargeResult?: any;\n  receipt?: any;\n  email?: string;\n  [key: string]: any;\n}\n\nclass PaymentFlow {\n  private steps: Map<string, StepHandler<PaymentContext>> = new Map();\n  private order: string[] = [];\n\n  registerStep(name: string, handler: StepHandler<PaymentContext>): this {\n    this.steps.set(name, handler);\n    return this;\n  }\n\n  setOrder(stepNames: string[]): this {\n    this.order = stepNames;\n    return this;\n  }\n\n  async execute(context: PaymentContext): Promise<PaymentContext> {\n    for (const stepName of this.order) {\n      const handler = this.steps.get(stepName);\n      if (!handler) throw new Error(`Step not found: ${stepName}`);\n\n      console.log(`Executing: ${stepName}`);\n      const result = await handler(context);\n\n      if (!result.success) {\n        throw new Error(`${stepName} failed: ${result.error}`);\n      }\n      context = result.data;\n    }\n    return context;\n  }\n}\n\n// Step Implementations\nconst authenticateRequest: StepHandler<PaymentContext> = async (context) => {\n  // Validate API key, JWT, etc.\n  console.log(\"  \u2713 Request authenticated\");\n  return { success: true, data: { ...context, authenticated: true } };\n};\n\nconst validateInput: StepHandler<PaymentContext> = async (context) => {\n  const { amount, cardNumber, email } = context.request;\n  const valid = amount > 0 && cardNumber && email;\n  if (!valid) {\n    return { success: false, data: context, error: \"Invalid input\" };\n  }\n  console.log(\"  \u2713 Input validated\");\n  return { success: true, data: { ...context, validated: true, email } };\n};\n\nconst fraudCheck: StepHandler<PaymentContext> = async (context) => {\n  // Call fraud detection service\n  const riskScore = Math.random() * 100;\n  if (riskScore > 80) {\n    return { success: false, data: context, error: \"High fraud risk\" };\n  }\n  console.log(`  \u2713 Fraud check passed (risk: ${riskScore.toFixed(1)}%)`);\n  return { success: true, data: { ...context, riskScore } };\n};\n\nconst chargeCard: StepHandler<PaymentContext> = async (context) => {\n  // Call payment processor\n  const chargeResult = {\n    transactionId: `txn_${Date.now()}`,\n    amount: context.request.amount,\n    status: \"success\"\n  };\n  console.log(`  \u2713 Card charged (${chargeResult.transactionId})`);\n  return { success: true, data: { ...context, chargeResult } };\n};\n\nconst saveReceipt: StepHandler<PaymentContext> = async (context) => {\n  // Save to database\n  const receipt = {\n    id: `rcpt_${Date.now()}`,\n    transactionId: context.chargeResult.transactionId,\n    amount: context.chargeResult.amount,\n    timestamp: new Date().toISOString()\n  };\n  console.log(`  \u2713 Receipt saved (${receipt.id})`);\n  return { success: true, data: { ...context, receipt } };\n};\n\nconst sendEmail: StepHandler<PaymentContext> = async (context) => {\n  // Queue email job\n  console.log(`  \u2713 Confirmation email queued to ${context.email}`);\n  return { success: true, data: context };\n};\n\n// Usage: Standard flow\nasync function processPayment() {\n  const flow = new PaymentFlow();\n\n  flow\n    .registerStep(\"authenticate\", authenticateRequest)\n    .registerStep(\"validate\", validateInput)\n    .registerStep(\"fraud_check\", fraudCheck)\n    .registerStep(\"charge\", chargeCard)\n    .registerStep(\"receipt\", saveReceipt)\n    .registerStep(\"email\", sendEmail)\n    .setOrder([\"authenticate\", \"validate\", \"fraud_check\", \"charge\", \"receipt\", \"email\"]);\n\n  const result = await flow.execute({\n    request: {\n      amount: 99.99,\n      cardNumber: \"4111111111111111\",\n      email: \"customer@example.com\"\n    }\n  });\n\n  console.log(\"Payment successful:\", result.chargeResult);\n}\n\n// CHANGING THE ORDER: Just reorder the steps\n// flow.setOrder([\"authenticate\", \"validate\", \"receipt\", \"charge\", \"fraud_check\", \"email\"]);\n\n// ADDING NEW STEPS:\n// flow.registerStep(\"log_analytics\", async (ctx) => { /* track metrics */ });\n// flow.setOrder([..., \"log_analytics\"]);\n\n// CONDITIONAL LOGIC (Advanced):\nclass ConditionalPaymentFlow extends PaymentFlow {\n  async executeConditional(context: PaymentContext, conditions: Map<string, boolean>) {\n    const steps = this[\"order\"].filter(step => \n      conditions.get(step) !== false\n    );\n    // Execute filtered steps...\n  }\n}\n\n// A/B TESTING (Advanced):\nclass ABTestFlow extends PaymentFlow {\n  async executeABTest(context: PaymentContext, variant: \"A\" | \"B\") {\n    const orderA = [\"authenticate\", \"validate\", \"fraud_check\", \"charge\", \"receipt\", \"email\"];\n    const orderB = [\"authenticate\", \"charge\", \"fraud_check\", \"validate\", \"receipt\", \"email\"]; // Reordered\n    this.setOrder(variant === \"A\" ? orderA : orderB);\n    return await this.execute(context);\n  }\n}\n\nprocessPayment().catch(console.error);\n```\n\n**Key Design Benefits:**\n\n1. **Easy Reordering**: Change `.setOrder([...])` without touching step logic\n2. **Easy Addition**: New steps are `.registerStep()` + add to order\n3. **Extensible**: Inherit `PaymentFlow` for conditional/A/B testing logic\n4. **Composable**: Each step is isolated and can be unit tested\n5. **Centralized Control**: See entire flow in one place via `setOrder()`\n\n**For Complex Future Needs:**\n- Wrap steps in conditionals: `if (context.country === 'US') execute('additional_check')`\n- Create parallel flows for A/B testing\n- Add retry logic or rollback handlers\n- Implement step dependencies and branching"
      },
      "skill": {
        "pass": true,
        "response_preview": "# Payment Processing Pipeline - Composition Design\n\nHere's a payment processing backend built on com...",
        "response_full": "# Payment Processing Pipeline - Composition Design\n\nHere's a payment processing backend built on composition, designed for easy modification and extension:\n\n```typescript\n// Step interfaces - each step is a focused unit\ninterface PaymentContext {\n  request: PaymentRequest;\n  userId: string;\n  isAuthenticated: boolean;\n  isValid: boolean;\n  fraudScore: number;\n  chargeId?: string;\n  receiptId?: string;\n  emailSent?: boolean;\n}\n\ninterface PaymentRequest {\n  amount: number;\n  currency: string;\n  cardToken: string;\n}\n\ntype PaymentStep = (context: PaymentContext) => Promise<PaymentContext>;\n\n// Individual focused units - each does ONE thing\nconst authenticateRequest: PaymentStep = async (context) => {\n  // Authenticate and extract userId\n  context.userId = await verifyToken(context.request);\n  context.isAuthenticated = true;\n  return context;\n};\n\nconst validateInput: PaymentStep = async (context) => {\n  if (context.request.amount <= 0) throw new Error(\"Invalid amount\");\n  if (!context.request.cardToken) throw new Error(\"Missing card token\");\n  context.isValid = true;\n  return context;\n};\n\nconst fraudCheck: PaymentStep = async (context) => {\n  context.fraudScore = await calculateFraudScore(context.userId, context.request);\n  if (context.fraudScore > 0.8) throw new Error(\"Fraud detected\");\n  return context;\n};\n\nconst chargeCard: PaymentStep = async (context) => {\n  context.chargeId = await processCardCharge(context.request, context.userId);\n  return context;\n};\n\nconst saveReceipt: PaymentStep = async (context) => {\n  context.receiptId = await storeReceipt({\n    userId: context.userId,\n    amount: context.request.amount,\n    chargeId: context.chargeId,\n  });\n  return context;\n};\n\nconst sendEmail: PaymentStep = async (context) => {\n  await emailService.sendReceipt(context.userId, context.receiptId);\n  context.emailSent = true;\n  return context;\n};\n\n// Pipeline composer - chains steps together\nconst createPaymentPipeline = (...steps: PaymentStep[]) => {\n  return async (request: PaymentRequest): Promise<PaymentContext> => {\n    let context: PaymentContext = {\n      request,\n      userId: \"\",\n      isAuthenticated: false,\n      isValid: false,\n      fraudScore: 0,\n    };\n\n    for (const step of steps) {\n      context = await step(context);\n    }\n\n    return context;\n  };\n};\n\n// Usage - compose the pipeline easily\nconst processPayment = createPaymentPipeline(\n  authenticateRequest,\n  validateInput,\n  fraudCheck,\n  chargeCard,\n  saveReceipt,\n  sendEmail\n);\n\n// Example: Easy to reorder\nconst fastTrackPayment = createPaymentPipeline(\n  authenticateRequest,\n  chargeCard,\n  validateInput, // Validate after charge for speed\n  fraudCheck,\n  saveReceipt,\n  sendEmail\n);\n\n// Example: Easy to extend - add new steps without touching existing ones\nconst riskBasedPayment = createPaymentPipeline(\n  authenticateRequest,\n  validateInput,\n  fraudCheck,\n  async (context) => {\n    // New conditional step\n    if (context.fraudScore > 0.5) {\n      await notifySecurityTeam(context.userId);\n    }\n    return context;\n  },\n  chargeCard,\n  saveReceipt,\n  sendEmail\n);\n\n// Implementation details (dependencies)\nasync function verifyToken(request: PaymentRequest): Promise<string> {\n  // Authenticate token, return userId\n  return \"user-123\";\n}\n\nasync function calculateFraudScore(userId: string, request: PaymentRequest): Promise<number> {\n  // Calculate fraud risk\n  return 0.2;\n}\n\nasync function processCardCharge(request: PaymentRequest, userId: string): Promise<string> {\n  // Charge the card\n  return \"charge-456\";\n}\n\nasync function storeReceipt(data: { userId: string; amount: number; chargeId: string }): Promise<string> {\n  // Save receipt to database\n  return \"receipt-789\";\n}\n\nconst emailService = {\n  sendReceipt: async (userId: string, receiptId: string) => {\n    // Send email\n  },\n};\n\nasync function notifySecurityTeam(userId: string) {\n  // Alert security\n}\n```\n\n## Key Benefits of This Design\n\n\u2705 **Easy to reorder steps**: Just pass them in different order to `createPaymentPipeline`  \n\u2705 **Easy to add new steps**: Create a new step function, add to pipeline  \n\u2705 **Easy to conditionally skip steps**: Wrap in a step that checks a condition  \n\u2705 **Easy to A/B test flows**: Create multiple pipelines with different step orders  \n\u2705 **Each step is testable**: Mock the context, test step in isolation  \n\u2705 **No central coordinator**: No \"PaymentManager\" orchestrating everything  \n\n## To extend further:\n\n```typescript\n// Add retry logic without changing steps\nconst retryableStep = (step: PaymentStep, maxRetries = 3): PaymentStep => {\n  return async (context) => {\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        return await step(context);\n      } catch (e) {\n        if (i === maxRetries - 1) throw e;\n      }\n    }\n    return context;\n  };\n};\n\n// Add parallel steps\nconst parallelSteps = (steps: PaymentStep[]): PaymentStep => {\n  return async (context) => {\n    await Promise.all(steps.map(step => step(context)));\n    return context;\n  };\n};\n```\n\nThis composition-based approach scales as your flow grows increasingly complex."
      }
    },
    {
      "name": "bottleneck_analysis",
      "input": "We have a `LegacyManager` class in our system that takes 15 different service dependencies in its constructor and has methods like `createUser`, `processPayment`, `exportData`, and `sendNewsletter`. \n\nExplain the concrete risks of this design for a team of 10 developers working on this codebase simultaneously.",
      "expected": {
        "focus": "Does the answer identify conflicts, testing difficulty, and tight coupling?"
      },
      "baseline": {
        "pass": true,
        "response_preview": "# Concrete Risks of LegacyManager Design for a 10-Developer Team\n\n**Merge Conflict Chaos**\nEvery dev...",
        "response_full": "# Concrete Risks of LegacyManager Design for a 10-Developer Team\n\n**Merge Conflict Chaos**\nEvery developer touching different methods (`createUser`, `processPayment`, `exportData`, `sendNewsletter`) modifies the same file. With 10 developers, expect daily merge conflicts in `LegacyManager.java/LegacyManager.ts`, blocking pull requests and fragmenting focus.\n\n**Cascading Test Failures**\nAll 15 service dependencies must be mocked for any unit test. When one developer changes a dependency's interface, tests fail across the entire team's work-in-progress branches. A payment service refactor breaks tests for user creation and newsletter logic\u2014unrelated code, same file.\n\n**Deployment Bottlenecks**\nSimple bug fixes in `sendNewsletter` risk breaking `createUser` because the method signatures and constructor are tightly coupled. A developer must now coordinate with teammates, fear their change impacts payment processing, and increase test scope before deployment.\n\n**Onboarding Paralysis**\nA new developer investigating one feature (like fixing `exportData`) must understand all 15 dependencies and their interactions just to read the code. The complexity forces documentation debt and longer code reviews.\n\n**Impossible Code Ownership**\nNo developer can cleanly own a feature. The `processPayment` owner cannot independently refactor without negotiating changes with the `createUser` owner in the same shared class, creating artificial dependencies.\n\n**Slow Test Suites**\nWith 15 service dependencies injected, every test setup takes longer. Running tests becomes slower for all developers, increasing CI/CD friction and encouraging developers to skip local testing before pushing.\n\n**The Core Risk**: This design makes the class a shared resource bottleneck. At 10 developers, you've effectively created a single point of serial coordination for all changes touching these methods."
      },
      "skill": {
        "pass": true,
        "response_preview": "# Concrete Risks for a 10-Developer Team\n\n## Immediate Merge Conflicts & Bottleneck\n- **Every constr...",
        "response_full": "# Concrete Risks for a 10-Developer Team\n\n## Immediate Merge Conflicts & Bottleneck\n- **Every constructor change blocks multiple developers**: Adding a new dependency to support `sendNewsletter` requires modifying the class definition that 8 other developers may be touching simultaneously (for `createUser`, `processPayment`, `exportData` changes).\n- **Parallel feature work becomes serialized**: Developer A needs to add an email service; Developer B needs a payment service; Developer C needs a database service. All three collide on the same constructor, causing constant rebase cycles.\n\n## Testing & Verification Paralysis\n- **Test setup becomes prohibitively expensive**: To test `sendNewsletter`, you must mock or construct all 15 services correctly. No developer knows which ones are actually used. Two developers build contradictory test fixtures, leading to flaky tests.\n- **Test failures become blame-passing**: When `processPayment` tests fail, does it fail due to the payment service, the logger, the audit service, or the email service? The coupling hides causality.\n\n## Hidden Impact & Cascading Bugs\n- **Changes in one method silently break others**: A developer fixes `createUser` by caching a service result. Unknown to them, `processPayment` relied on that service being fresh. Bug appears in production weeks later.\n- **Dependency version conflicts force painful coordination**: Team A upgrades the email service; Team B needs the old version for payment notifications. Both modifications live in the same constructor\u2014impossible to resolve without one team backing down.\n\n## Onboarding & Cognitive Load\n- **New developers waste days understanding coupling**: \"Why does a user creation method hold a reference to the newsletter service? To the export service? To the payment processor?\" No clear answers. Reduced productivity for 2-3 weeks.\n- **Code review becomes meaningless**: Reviewers can't assess the impact of a change to `createUser` without understanding how it interacts with the other 14 dependencies.\n\n## Architectural Debt & Refactoring Lock-In\n- **Impossible to split work by responsibility**: You can't assign \"user creation\" to one team and \"payments\" to another\u2014they share the same class. Coordination overhead explodes with team size.\n- **Prevents incremental deployment**: You can't deploy `createUser` improvements without ensuring the payment service, export service, and newsletter service are all compatible and deployed first. A single dependency issue blocks all features.\n\n## Example Scenario: 2-Week Project\n- **Week 1**: Team wants to optimize `createUser`. Discovers it's coupled to payment and newsletter services. Changes constructor signature.\n- **Days later**: Three other teams have pending changes to the constructor (unrelated features). Merge conflicts rage. Lost 3 days to rebasing and coordination.\n- **Week 2**: Finally merged. New bug: `exportData` now mysteriously fails because it inadvertently relied on an initialization order that changed.\n\n**Bottom line**: The class is a single point of contention for 10 developers. Every change is a transaction that requires coordination. It transforms a technical problem (modular design) into an organizational one (constant meetings to resolve conflicts)."
      }
    }
  ],
  "judgment": {
    "principle_better": "B",
    "quality_better": "B",
    "overall_better": "B",
    "option_a_rating": "regular",
    "option_b_rating": "outstanding",
    "score": 100,
    "reasoning": "Solution A extracts focused units but immediately re-couples them through a central `PaymentFlow` coordinator class with orchestration logic in the `execute()` method, directly violating the principle's core premise. Solution B demonstrates pure composition\u2014simple functions composable directly via `createPaymentPipeline()` with zero central coordination, no class boilerplate, and extensibility through functional composition (wrappers, higher-order functions) rather than manager inheritance. Solution B achieves 'build from simple units'; Solution A adds a manager layer on top."
  },
  "timestamp": "2026-02-07T23:51:50",
  "provider": "copilot"
}