{
  "skill": "ps-policy-mechanism-separation",
  "severity": "WARN",
  "model": "claude-haiku-4.5",
  "skill_version": "1.0.0",
  "baseline_rate": 100,
  "skill_rate": 100,
  "baseline_rating": "good",
  "skill_rating": "outstanding",
  "baseline_pass_count": "2/2",
  "skill_pass_count": "2/2",
  "improvement": 0,
  "judge_error": false,
  "results": [
    {
      "name": "uploader_flexibility",
      "input": "Our `S3Uploader` class currently hardcodes a 30-second timeout and 3 retries. \n\nWe now need to use it for 1GB video files (which need 1 hour timeout) and for tiny 1KB JSON files (which need 500ms timeout).\n\nRedesign the class so that the *rules* (timeouts, retries) are separated from the *work* (uploading bytes).",
      "expected": {
        "focus": "Does the solution accept a config/policy object or strategy function?"
      },
      "baseline": {
        "pass": true,
        "response_preview": "# S3Uploader Redesign: Separation of Concerns\n\n**Extract upload rules into a separate configuration ...",
        "response_full": "# S3Uploader Redesign: Separation of Concerns\n\n**Extract upload rules into a separate configuration class:**\n\n```typescript\n// Rules (timeouts, retries) - separated from work\nclass UploadConfig {\n  constructor(\n    readonly timeoutMs: number,\n    readonly maxRetries: number\n  ) {}\n  \n  static forLargeVideo() {\n    return new UploadConfig(3600000, 5);  // 1 hour, more retries\n  }\n  \n  static forSmallJson() {\n    return new UploadConfig(500, 1);      // 500ms, minimal retries\n  }\n  \n  static default() {\n    return new UploadConfig(30000, 3);    // 30 seconds, 3 retries\n  }\n}\n\n// Work (uploading bytes) - uses injected rules\nclass S3Uploader {\n  constructor(private config: UploadConfig) {}\n  \n  async upload(bucket: string, key: string, data: Buffer): Promise<void> {\n    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {\n      try {\n        return await this.uploadWithTimeout(bucket, key, data);\n      } catch (error) {\n        if (attempt === this.config.maxRetries) throw error;\n      }\n    }\n  }\n  \n  private uploadWithTimeout(\n    bucket: string,\n    key: string,\n    data: Buffer\n  ): Promise<void> {\n    return Promise.race([\n      this.doUpload(bucket, key, data),\n      this.createTimeoutPromise(this.config.timeoutMs)\n    ]);\n  }\n  \n  private doUpload(bucket: string, key: string, data: Buffer): Promise<void> {\n    // Actual S3 upload logic\n  }\n  \n  private createTimeoutPromise(ms: number): Promise<never> {\n    return new Promise((_, reject) =>\n      setTimeout(() => reject(new Error(`Upload timeout after ${ms}ms`)), ms)\n    );\n  }\n}\n\n// Usage\nconst videoUploader = new S3Uploader(UploadConfig.forLargeVideo());\nawait videoUploader.upload('bucket', 'video.mp4', videoData);\n\nconst jsonUploader = new S3Uploader(UploadConfig.forSmallJson());\nawait jsonUploader.upload('bucket', 'data.json', jsonData);\n```\n\n**Key improvements:**\n- **UploadConfig** encapsulates all rules (timeout, retries)\n- **S3Uploader** focuses solely on upload logic\n- Reusable configurations for different scenarios\n- Easy to add new configs without modifying S3Uploader"
      },
      "skill": {
        "pass": true,
        "response_preview": "# S3Uploader Redesign: Policy-Mechanism Separation\n\n**Current problem:** Hardcoded 30-second timeout...",
        "response_full": "# S3Uploader Redesign: Policy-Mechanism Separation\n\n**Current problem:** Hardcoded 30-second timeout and 3 retries cannot accommodate different file types.\n\n**Solution:** Separate upload policies from the reusable upload mechanism.\n\n## Redesigned Code Structure\n\n```javascript\n// POLICY - Configuration for different scenarios\nconst UPLOAD_POLICIES = {\n  VIDEO: {\n    timeoutMs: 3600000,      // 1 hour\n    maxRetries: 5,\n    backoffMs: 10000,\n    shouldRetry: (error) => error.code !== 'InvalidFile'\n  },\n  JSON: {\n    timeoutMs: 500,          // 500ms\n    maxRetries: 1,\n    backoffMs: 50,\n    shouldRetry: (error) => error.code === 'NetworkTimeout'\n  },\n  DEFAULT: {\n    timeoutMs: 30000,        // Original default\n    maxRetries: 3,\n    backoffMs: 1000,\n    shouldRetry: (error) => error.retriable === true\n  }\n};\n\n// MECHANISM - Reusable implementation (no hardcoded rules)\nclass S3Uploader {\n  async upload(data, policy = UPLOAD_POLICIES.DEFAULT) {\n    return this._retryWithPolicy(\n      () => this._uploadBytes(data),\n      policy\n    );\n  }\n\n  async _retryWithPolicy(operation, policy) {\n    let lastError;\n    for (let attempt = 1; attempt <= policy.maxRetries; attempt++) {\n      try {\n        return await this._executeWithTimeout(\n          operation,\n          policy.timeoutMs\n        );\n      } catch (error) {\n        lastError = error;\n        if (attempt === policy.maxRetries || !policy.shouldRetry(error)) {\n          throw error;\n        }\n        await this._sleep(policy.backoffMs * attempt); // exponential backoff\n      }\n    }\n    throw lastError;\n  }\n\n  async _executeWithTimeout(operation, timeoutMs) {\n    return Promise.race([\n      operation(),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error('Upload timeout')), timeoutMs)\n      )\n    ]);\n  }\n\n  async _uploadBytes(data) {\n    // Core S3 upload logic - unchanged\n  }\n\n  _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n```\n\n## Usage\n\n```javascript\nconst uploader = new S3Uploader();\n\n// Video: 1 hour timeout, 5 retries\nawait uploader.upload(videoBuffer, UPLOAD_POLICIES.VIDEO);\n\n// JSON: 500ms timeout, 1 retry\nawait uploader.upload(jsonBuffer, UPLOAD_POLICIES.JSON);\n\n// Default behavior preserved\nawait uploader.upload(otherData); // Uses DEFAULT policy\n```\n\n**Result:** Rules are now editable without code changes. Same mechanism serves all file types. Policies can be stored in config files or environment variables."
      }
    },
    {
      "name": "cache_expiration_strategy",
      "input": "We have a simple `Cache` class. Currently, it deletes items if they are older than 1 hour.\n\nWe want to support different expiration rules for different data types (e.g., \"Expire if not accessed in 10 mins\" vs \"Expire at midnight specific timezone\").\n\nShow how you would restructure the Cache to separate the storage mechanism from the expiration logic.",
      "expected": {
        "focus": "Does the Cache delegate the \"should I expire?\" decision to a separate policy?"
      },
      "baseline": {
        "pass": true,
        "response_preview": "# Cache Architecture: Separating Storage from Expiration Logic\n\nUse the **Strategy Pattern** to deco...",
        "response_full": "# Cache Architecture: Separating Storage from Expiration Logic\n\nUse the **Strategy Pattern** to decouple expiration policies from storage:\n\n```csharp\n// Expiration strategy interface\npublic interface IExpirationPolicy\n{\n    bool IsExpired(CacheEntry entry);\n}\n\n// Concrete strategies\npublic class TimeBasedExpirationPolicy : IExpirationPolicy\n{\n    private readonly TimeSpan _duration;\n    public TimeBasedExpirationPolicy(TimeSpan duration) => _duration = duration;\n    public bool IsExpired(CacheEntry entry) => \n        DateTime.UtcNow - entry.CreatedAt > _duration;\n}\n\npublic class AccessTimeExpirationPolicy : IExpirationPolicy\n{\n    private readonly TimeSpan _inactivityDuration;\n    public AccessTimeExpirationPolicy(TimeSpan inactivityDuration) => \n        _inactivityDuration = inactivityDuration;\n    public bool IsExpired(CacheEntry entry) => \n        DateTime.UtcNow - entry.LastAccessedAt > _inactivityDuration;\n}\n\npublic class MidnightExpirationPolicy : IExpirationPolicy\n{\n    private readonly TimeZoneInfo _timezone;\n    public MidnightExpirationPolicy(TimeZoneInfo timezone) => _timezone = timezone;\n    public bool IsExpired(CacheEntry entry)\n    {\n        var localTime = TimeZoneInfo.ConvertTime(DateTime.UtcNow, _timezone);\n        var entryTime = TimeZoneInfo.ConvertTime(entry.CreatedAt, _timezone);\n        return localTime.Date > entryTime.Date;\n    }\n}\n\n// Core storage (policy-agnostic)\npublic class Cache<TKey, TValue>\n{\n    private readonly Dictionary<TKey, CacheEntry> _storage = new();\n    private readonly IExpirationPolicy _policy;\n\n    public Cache(IExpirationPolicy policy) => _policy = policy;\n\n    public void Set(TKey key, TValue value)\n    {\n        _storage[key] = new CacheEntry(value, DateTime.UtcNow);\n    }\n\n    public bool TryGet(TKey key, out TValue value)\n    {\n        if (_storage.TryGetValue(key, out var entry) && !_policy.IsExpired(entry))\n        {\n            entry.LastAccessedAt = DateTime.UtcNow; // Track access\n            value = (TValue)entry.Value;\n            return true;\n        }\n        _storage.Remove(key);\n        value = default;\n        return false;\n    }\n}\n\npublic class CacheEntry\n{\n    public object Value { get; }\n    public DateTime CreatedAt { get; }\n    public DateTime LastAccessedAt { get; set; }\n    \n    public CacheEntry(object value, DateTime createdAt)\n    {\n        Value = value;\n        CreatedAt = createdAt;\n        LastAccessedAt = createdAt;\n    }\n}\n```\n\n**Usage:**\n```csharp\nvar userCache = new Cache<int, User>(new TimeBasedExpirationPolicy(TimeSpan.FromHours(1)));\nvar sessionCache = new Cache<string, Session>(new AccessTimeExpirationPolicy(TimeSpan.FromMinutes(10)));\nvar reportCache = new Cache<string, Report>(new MidnightExpirationPolicy(TimeZoneInfo.FindSystemTimeZoneById(\"Eastern Standard Time\")));\n```\n\n**Benefits:**\n- **Single Responsibility**: Cache handles storage; policies handle expiration logic\n- **Open/Closed Principle**: Add new expiration strategies without modifying Cache\n- **Testability**: Mock expiration policies independently\n- **Flexibility**: Assign different policies to different cache instances"
      },
      "skill": {
        "pass": true,
        "response_preview": "# Cache Restructure: Policy/Mechanism Separation\n\n## Current Problem (Hardcoded Policy)\nThe Cache li...",
        "response_full": "# Cache Restructure: Policy/Mechanism Separation\n\n## Current Problem (Hardcoded Policy)\nThe Cache likely has expiration logic baked into the storage mechanism:\n```javascript\nclass Cache {\n  delete(key) {\n    const item = this.items[key];\n    if (Date.now() - item.timestamp > 3600000) { // 1 hour hardcoded\n      delete this.items[key];\n    }\n  }\n}\n```\n\n## Restructured Solution\n\n**MECHANISM** - Generic storage with pluggable expiration:\n```javascript\nclass Cache {\n  constructor(expirationPolicy) {\n    this.items = new Map();\n    this.expirationPolicy = expirationPolicy;\n  }\n\n  set(key, value) {\n    this.items.set(key, {\n      value,\n      metadata: this.expirationPolicy.createMetadata()\n    });\n  }\n\n  get(key) {\n    this.updateMetadata(key);\n    const item = this.items.get(key);\n    \n    if (item && this.expirationPolicy.isExpired(item.metadata)) {\n      this.items.delete(key);\n      return null;\n    }\n    return item?.value;\n  }\n\n  updateMetadata(key) {\n    const item = this.items.get(key);\n    if (item) {\n      this.expirationPolicy.updateMetadata(item.metadata);\n    }\n  }\n}\n```\n\n**POLICIES** - Different expiration strategies:\n```javascript\n// Policy 1: Expire after fixed duration\nconst fixedDurationPolicy = {\n  createMetadata: () => ({ createdAt: Date.now() }),\n  updateMetadata: () => {}, // No updates needed\n  isExpired: (meta) => Date.now() - meta.createdAt > 3600000\n};\n\n// Policy 2: Expire if not accessed in 10 mins\nconst accessTimePolicy = {\n  createMetadata: () => ({ lastAccessed: Date.now() }),\n  updateMetadata: (meta) => { meta.lastAccessed = Date.now(); },\n  isExpired: (meta) => Date.now() - meta.lastAccessed > 600000\n};\n\n// Policy 3: Expire at midnight specific timezone\nconst midnightPolicy = {\n  timezone: 'America/New_York',\n  createMetadata: () => ({ createdDate: new Date() }),\n  updateMetadata: () => {},\n  isExpired: (meta) => {\n    const now = new Date(new Date().toLocaleString('en-US', { timeZone: this.timezone }));\n    const created = new Date(meta.createdDate.toLocaleString('en-US', { timeZone: this.timezone }));\n    return now.toDateString() !== created.toDateString();\n  }\n};\n```\n\n**USAGE**:\n```javascript\nconst cache1 = new Cache(fixedDurationPolicy);\nconst cache2 = new Cache(accessTimePolicy);\nconst cache3 = new Cache(midnightPolicy);\n\ncache1.set('data', {foo: 'bar'});\ncache2.set('session', {id: 123});\ncache3.set('daily', {count: 5});\n```\n\n**Benefits:**\n- **Change policies without touching Cache code** \u2013 New expiration rules become new policy objects\n- **Test independently** \u2013 Mechanism tested with mock policies; policies tested standalone\n- **Reuse Cache** \u2013 Same storage mechanism works with any expiration policy\n- **Explicit rules** \u2013 Policy objects clearly document what triggers expiration"
      }
    }
  ],
  "judgment": {
    "principle_better": "B",
    "quality_better": "B",
    "overall_better": "B",
    "option_a_rating": "good",
    "option_b_rating": "outstanding",
    "score": 100,
    "reasoning": "Solution A demonstrates the principle competently through dependency injection of configuration objects, particularly in the Cache example with proper Strategy Pattern implementation. However, Solution B achieves mastery by recognizing that policies must include decision logic, not just static properties\u2014see the shouldRetry function and policy methods (isExpired, updateMetadata) that mechanisms delegate to. This behavioral encapsulation in Solution B means business rules can change entirely without modifying the S3Uploader or Cache mechanism, whereas Solution A still hardcodes retry loop structure and timeout logic in the mechanism itself."
  },
  "timestamp": "2026-02-07T23:51:50",
  "provider": "copilot"
}