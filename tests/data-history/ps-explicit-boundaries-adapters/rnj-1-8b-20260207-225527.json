{
  "skill": "ps-explicit-boundaries-adapters",
  "severity": "WARN",
  "model": "rnj-1:8b",
  "skill_version": "1.0.0",
  "baseline_rate": 100,
  "skill_rate": 100,
  "baseline_rating": "regular",
  "skill_rating": "good",
  "baseline_pass_count": "2/2",
  "skill_pass_count": "2/2",
  "improvement": 0,
  "results": [
    {
      "name": "discount_logic_isolation",
      "input": "We have a function `calculate_order_discount(order_id)` that needs to fetch the user's order history to determine the discount tier.\n\nCurrently, it imports `db_client` directly and queries the database inside the calculation logic. This makes it impossible to run simple unit tests on the discount rules without spinning up a test database.\n\nRewrite this feature so that we can verify the discount logic with instant, in-memory unit tests, while still being able to connect to the real database in production.",
      "expected": {
        "focus": "Does the solution introduce an interface/abstraction for the data fetching? Is the logic separated from the DB call?"
      },
      "baseline": {
        "pass": true,
        "response_preview": "To achieve this, we can refactor the `calculate_order_discount` function to accept a database client...",
        "response_full": "To achieve this, we can refactor the `calculate_order_discount` function to accept a database client as a parameter. This way, we can provide a mock database client during unit tests and the real database client in production.\n\nHere's how you can refactor the function:\n\n```python\n# Import necessary modules\nfrom typing import Optional\n\n# Define a type for the database client\nclass DatabaseClient:\n    def query(self, query: str) -> list:\n        # This is a placeholder for the actual database query logic\n        pass\n\ndef calculate_order_discount(order_id: int, db_client: DatabaseClient) -> float:\n    \"\"\"\n    Calculate the discount tier based on the user's order history.\n\n    :param order_id: The ID of the order to calculate the discount for.\n    :param db_client: The database client to use for querying the order history.\n    :return: The discount tier as a float.\n    \"\"\"\n    # Example query to fetch order history\n    query = f\"SELECT * FROM orders WHERE order_id = {order_id}\"\n    order_history = db_client.query(query)\n\n    # Example logic to determine the discount tier based on order history\n    # This is just a placeholder for the actual discount calculation logic\n    discount_tier = 0.0\n    if order_history:\n        # Example condition to determine the discount tier\n        if len(order_history) > 10:\n            discount_tier = 0.1\n        elif len(order_history) > 5:\n            discount_tier = 0.05\n        else:\n            discount_tier = 0.0\n\n    return discount_tier\n\n# Example usage with a mock database client\nclass MockDatabaseClient(DatabaseClient):\n    def query(self, query: str) -> list:\n        # Mock implementation of the query method\n        # This should return a list of dictionaries representing the order history\n        return [{\"order_id\": 1, \"amount\": 100}, {\"order_id\": 2, \"amount\": 200}]\n\n# Example usage\nif __name__ == \"__main__\":\n    mock_db_client = MockDatabaseClient()\n    discount = calculate_order_discount(1, mock_db_client)\n    print(f\"Discount tier: {discount}\")\n```\n\nIn this refactored code, the `calculate_order_discount` function now takes a `db_client` parameter, which allows us to provide a mock database client during unit tests and the real database client in production. This separation of concerns makes it possible to write unit tests for the discount logic without needing to spin up a test database."
      },
      "skill": {
        "pass": true,
        "response_preview": "```python\n# discount_service.py\nfrom typing import List, Dict, Any\nfrom abc import ABC, abstractmeth...",
        "response_full": "```python\n# discount_service.py\nfrom typing import List, Dict, Any\nfrom abc import ABC, abstractmethod\n\nclass OrderRepository(ABC):\n    \"\"\"Port interface for order data access\"\"\"\n    \n    @abstractmethod\n    def get_user_orders(self, user_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get all orders for a user\"\"\"\n        pass\n\nclass InMemoryOrderRepository(OrderRepository):\n    \"\"\"In-memory implementation for testing\"\"\"\n    \n    def __init__(self, orders: List[Dict[str, Any]]):\n        self.orders = orders\n    \n    def get_user_orders(self, user_id: str) -> List[Dict[str, Any]]:\n        return [order for order in self.orders if order['user_id'] == user_id]\n\nclass DatabaseOrderRepository(OrderRepository):\n    \"\"\"Database implementation\"\"\"\n    \n    def __init__(self, db_client):\n        self.db_client = db_client\n    \n    def get_user_orders(self, user_id: str) -> List[Dict[str, Any]]:\n        # Example query - replace with actual database query\n        return self.db_client.query(\"SELECT * FROM orders WHERE user_id = %s\", (user_id,))\n\ndef calculate_order_discount(order_id: str, repository: OrderRepository) -> float:\n    \"\"\"\n    Calculate discount based on order history.\n    Returns discount percentage (0-1).\n    \"\"\"\n    # Get user ID from order (simplified)\n    user_id = f\"user_{order_id[:3]}\"  # Example mapping\n    \n    # Get user's orders\n    orders = repository.get_user_orders(user_id)\n    \n    # Calculate discount based on order count\n    order_count = len(orders)\n    \n    if order_count < 5:\n        return 0.0\n    elif order_count < 10:\n        return 0.1\n    else:\n        return 0.2\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test with in-memory repository\n    test_orders = [\n        {\"order_id\": \"order_001\", \"user_id\": \"user_123\", \"amount\": 100},\n        {\"order_id\": \"order_002\", \"user_id\": \"user_123\", \"amount\": 150},\n    ]\n    \n    repo = InMemoryOrderRepository(test_orders)\n    discount = calculate_order_discount(\"order_001\", repo)\n    print(f\"Discount: {discount}\")\n```"
      }
    },
    {
      "name": "infrastructure_pollution_analysis",
      "input": "Review this code snippet:\n\n```javascript\nclass InvoiceService {\n  process(invoice) {\n    if (invoice.amount > 10000) {\n      const sns = new AWS.SNS(); // Direct AWS usage\n      sns.publish({ topic: 'high-value-tx', message: JSON.stringify(invoice) });\n    }\n    // ... rest of logic\n  }\n}\n```\n\nWhat are the long-term maintainability problems with instantiation like this inside business logic?",
      "expected": {
        "focus": "Does the answer mention vendor lock-in, testing difficulties, or mixing concerns?"
      },
      "baseline": {
        "pass": true,
        "response_preview": "The provided JavaScript code snippet has a few maintainability issues related to the direct instanti...",
        "response_full": "The provided JavaScript code snippet has a few maintainability issues related to the direct instantiation of AWS services within the business logic. Here are the long-term maintainability problems with such instantiation:\n\n1. **Tight Coupling**: The `InvoiceService` class is tightly coupled with AWS SDK. This makes the code less flexible and harder to test, as it directly depends on the AWS SDK.\n\n2. **Testing**: It becomes difficult to write unit tests for the `InvoiceService` class because it directly interacts with AWS services. This makes it harder to mock the AWS SDK and test the business logic in isolation.\n\n3. **Configuration Management**: The AWS SDK configuration (like credentials and region) is hardcoded within the `InvoiceService` class. This makes it harder to manage and change the configuration.\n\n4. **Scalability**: As the application grows, it becomes harder to scale and maintain the codebase due to the tight coupling with AWS services.\n\n5. **Dependency Injection**: The `InvoiceService` class should not be responsible for creating and managing AWS service instances. Instead, it should receive these instances as dependencies through dependency injection.\n\nTo address these issues, consider the following improvements:\n\n- Use dependency injection to provide the AWS SDK instance to the `InvoiceService` class.\n- Use a configuration management system to manage AWS credentials and region.\n- Write unit tests for the `InvoiceService` class by mocking the AWS SDK.\n- Use a dependency injection framework to manage dependencies.\n\nHere's an example of how the `InvoiceService` class can be refactored to use dependency injection:\n\n```javascript\nclass InvoiceService {\n  constructor(sns) {\n    this.sns = sns;\n  }\n\n  process(invoice) {\n    if (invoice.amount > 10000) {\n      this.sns.publish({ topic: 'high-value-tx', message: JSON.stringify(invoice) });\n    }\n    // ... rest of logic\n  }\n}\n\n// Usage\nconst sns = new AWS.SNS();\nconst invoiceService = new InvoiceService(sns);\n```\n\nBy using dependency injection, the `InvoiceService` class is no longer responsible for creating and managing AWS service instances, making the code more flexible, testable, and maintainable."
      },
      "skill": {
        "pass": true,
        "response_preview": "This code has several maintainability problems:\n\n1. **Tight coupling to AWS SDK**: The `InvoiceServi...",
        "response_full": "This code has several maintainability problems:\n\n1. **Tight coupling to AWS SDK**: The `InvoiceService` class directly depends on AWS SDK, making it impossible to test without AWS credentials and infrastructure.\n\n2. **Violation of Hexagonal Architecture**: Business logic depends on external infrastructure (AWS SNS), breaking the principle of isolating external systems behind boundaries.\n\n3. **Testing difficulties**: Unit tests require AWS credentials and network access, making tests brittle and slow.\n\n4. **Dependency inversion violation**: The code depends on concrete implementation (AWS SDK) rather than an abstraction.\n\n5. **No clear boundaries**: The external system (AWS SNS) is woven into the business logic, violating the principle of explicit boundaries.\n\nTo fix this, we should extract the AWS SNS dependency behind a port/interface and implement it with an adapter. Here's how the refactored code would look:\n\n```javascript\n// Port/interface for SNS dependency\nclass SnsPort {\n  publish(topic, message) {\n    throw new Error('Not implemented');\n  }\n}\n\n// Adapter for AWS SNS\nclass AwsSnsAdapter {\n  constructor() {\n    this.sns = new AWS.SNS();\n  }\n  \n  publish(topic, message) {\n    return this.sns.publish({\n      topic: topic,\n      message: JSON.stringify(message)\n    });\n  }\n}\n\n// Business logic now depends only on port\nclass InvoiceService {\n  constructor(snsPort) {\n    this.snsPort = snsPort;\n  }\n  \n  process(invoice) {\n    if (invoice.amount > 10000) {\n      this.snsPort.publish('high-value-tx', invoice);\n    }\n    // ... rest of logic\n  }\n}\n\n// Usage\nconst snsPort = new AwsSnsAdapter();\nconst invoiceService = new InvoiceService(snsPort);\n```\n\nThis refactoring:\n1. Extracts the AWS dependency behind a clear boundary (SnsPort interface)\n2. Makes the business logic independent of AWS SDK\n3. Allows easy testing with mock adapters\n4. Follows Hexagonal Architecture principles\n5. Makes dependencies explicit and manageable\n\nThe business logic now depends only on the port interface, not on AWS SDK. The adapter handles all infrastructure concerns."
      }
    }
  ],
  "judgment": {
    "principle_better": "B",
    "quality_better": "B",
    "overall_better": "B",
    "option_a_rating": "regular",
    "option_b_rating": "good",
    "score": 100,
    "reasoning": "Solution B is significantly better than Solution A. Solution A has multiple maintainability problems: tight coupling to AWS SDK, no clear boundaries, and poor testability. Solution B follows Hexagonal Architecture principles by extracting the AWS dependency behind a port interface, making the business logic independent of infrastructure. Solution B is more maintainable, testable, and flexible, with clear boundaries and proper dependency inversion. The refactoring demonstrates mastery of the principle with precise implementation."
  },
  "timestamp": "2026-02-07T22:55:27",
  "provider": "ollama"
}