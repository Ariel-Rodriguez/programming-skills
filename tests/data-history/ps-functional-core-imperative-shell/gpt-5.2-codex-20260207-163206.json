{
  "timestamp": "2026-02-07T16:37:22",
  "skill": "ps-functional-core-imperative-shell",
  "severity": "BLOCK",
  "model": "gpt-5.2-codex",
  "baseline_rate": 100,
  "skill_rate": 100,
  "baseline_rating": "good",
  "skill_rating": "good",
  "baseline_pass_count": "2/2",
  "skill_pass_count": "2/2",
  "improvement": 0,
  "results": [
    {
      "name": "refactor_mixed_logic",
      "baseline": {
        "pass": true,
        "response_preview": "Here\u2019s a Functional Core + Imperative Shell refactor. The core is pure and testable; the shell handl...",
        "response_full": "Here\u2019s a Functional Core + Imperative Shell refactor. The core is pure and testable; the shell handles DB and errors.\n\n```javascript\n// Functional core: pure logic\nfunction computeNewStock(currentStock, soldQuantity) {\n    if (soldQuantity <= 0) {\n        throw new Error('Sold quantity must be positive');\n    }\n    if (currentStock < soldQuantity) {\n        throw new Error('Insufficient stock');\n    }\n    return currentStock - soldQuantity;\n}\n\n// Imperative shell: IO + orchestration\nfunction updateStock(productId, soldQuantity) {\n    const product = db.query('SELECT * FROM products WHERE id = ?', productId);\n    const newStock = computeNewStock(product.stock, soldQuantity);\n    db.execute('UPDATE products SET stock = ? WHERE id = ?', [newStock, productId]);\n    return newStock;\n}\n```\n\nIf you want, I can further separate error handling or make the core return a `Result` instead of throwing."
      },
      "skill": {
        "pass": true,
        "response_preview": "Here\u2019s a Functional Core / Imperative Shell refactor that keeps business logic pure and moves all ef...",
        "response_full": "Here\u2019s a Functional Core / Imperative Shell refactor that keeps business logic pure and moves all effects to the shell:\n\n```javascript\n// PURE CORE\nfunction calculateNewStock(currentStock, soldQuantity) {\n    if (currentStock < soldQuantity) {\n        throw new Error('Insufficient stock');\n    }\n    return currentStock - soldQuantity;\n}\n\n// IMPERATIVE SHELL\nfunction updateStock(productId, soldQuantity, db) {\n    const product = db.query('SELECT * FROM products WHERE id = ?', productId);\n    const newStock = calculateNewStock(product.stock, soldQuantity);\n    db.execute('UPDATE products SET stock = ? WHERE id = ?', [newStock, productId]);\n    return newStock;\n}\n```\n\nNotes:\n- `calculateNewStock` is pure: no IO, no globals, deterministic.\n- `updateStock` is the shell: it loads data, calls the core, then persists results."
      }
    },
    {
      "name": "identify_side_effects",
      "baseline": {
        "pass": true,
        "response_preview": "Two side effects:\n\n1. `console.error('Invalid email')`\n2. `logger.info('User validated')`\n\nWhy this ...",
        "response_full": "Two side effects:\n\n1. `console.error('Invalid email')`\n2. `logger.info('User validated')`\n\nWhy this violates Functional Core:\n\n- Functional Core requires pure functions: output depends only on input, with no observable side effects.\n- Logging is an external effect (I/O). It makes the function do more than compute a boolean from `user`, so it isn\u2019t referentially transparent. The same input can now also produce different external behavior depending on runtime environment, which breaks the \u201cpure core\u201d rule."
      },
      "skill": {
        "pass": true,
        "response_preview": "Side effects here:\n\n1. `console.error('Invalid email')`  \nThis performs IO by writing to stderr. Pur...",
        "response_full": "Side effects here:\n\n1. `console.error('Invalid email')`  \nThis performs IO by writing to stderr. Pure functions should not perform logging or any external interaction.\n\n2. `logger.info('User validated')`  \nThis performs logging via an external logger, another IO side effect.\n\nWhy this violates Functional Core:\n\n- The function\u2019s behavior depends on and affects external systems (logging), so it\u2019s not deterministic and not purely computational.\n- It mixes business logic (email validation) with effects (logging), so it can\u2019t be tested as a pure core without mocks.\n\nA pure core version would return a validation result (and maybe a message), and the shell would do the logging based on that result."
      }
    }
  ],
  "judgment": {
    "principle_better": "B",
    "quality_better": "B",
    "overall_better": "B",
    "option_a_rating": "good",
    "option_b_rating": "good",
    "score": 100,
    "reasoning": "Both separate core computation from IO, but B is slightly cleaner by injecting the DB into the shell, making dependencies explicit. A also includes unrelated logging discussion that muddies the example. B\u2019s structure is more maintainable and testable with less coupling."
  },
  "provider": "codex"
}