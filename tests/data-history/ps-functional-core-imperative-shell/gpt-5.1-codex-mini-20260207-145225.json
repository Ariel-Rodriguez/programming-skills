{
  "timestamp": "2026-02-07T14:52:25",
  "skill": "ps-functional-core-imperative-shell",
  "severity": "BLOCK",
  "model": "gpt-5.1-codex-mini",
  "baseline_rate": 100,
  "skill_rate": 100,
  "baseline_rating": "good",
  "skill_rating": "outstanding",
  "baseline_pass_count": "2/2",
  "skill_pass_count": "2/2",
  "improvement": 0,
  "results": [
    {
      "name": "refactor_mixed_logic",
      "baseline": {
        "pass": true,
        "response_preview": "**Functional Core / Imperative Shell**\n\n- Split the query/update logic (side effects) into a thin im...",
        "response_full": "**Functional Core / Imperative Shell**\n\n- Split the query/update logic (side effects) into a thin imperative wrapper and keep the pure calculation in a function.\n- Example:\n  ```javascript\n  function calculateNewStock(currentStock, soldQuantity) {\n    if (currentStock < soldQuantity) {\n      throw new Error('Insufficient stock');\n    }\n    return currentStock - soldQuantity;\n  }\n\n  async function updateStock(productId, soldQuantity) {\n    const product = await db.query('SELECT * FROM products WHERE id = ?', productId);\n    const newStock = calculateNewStock(product.stock, soldQuantity);\n    await db.execute('UPDATE products SET stock = ? WHERE id = ?', [newStock, productId]);\n    return newStock;\n  }\n  ```\n- `calculateNewStock` is the functional core (deterministic, no side effects); `updateStock` is the imperative shell (handles I/O).\n- If `db.query/execute` are asynchronous in your environment, keep the `await`s; otherwise they can be synchronous as before."
      },
      "skill": {
        "pass": true,
        "response_preview": "**Functional Core**\n\n- Extracted the stock adjustment logic into `calculateNewStock(stock, soldQuant...",
        "response_full": "**Functional Core**\n\n- Extracted the stock adjustment logic into `calculateNewStock(stock, soldQuantity)`, which is purely deterministic: it validates the inputs and returns the new stock (or throws when there isn\u2019t enough). No DB or side effects happen there.\n\n**Imperative Shell**\n\n- `updateStock(productId, soldQuantity)` now drives the side effects: it queries the product, calls the pure core, and writes the new stock back to the database.\n\n```javascript\n// PURE CORE: deterministic computation\nfunction calculateNewStock(currentStock, soldQuantity) {\n    if (soldQuantity < 0) {\n        throw new Error('Sold quantity must be non-negative');\n    }\n    if (currentStock < soldQuantity) {\n        throw new Error('Insufficient stock');\n    }\n    return currentStock - soldQuantity;\n}\n\n// IMPERATIVE SHELL: handles effects\nfunction updateStock(productId, soldQuantity) {\n    const product = db.query('SELECT * FROM products WHERE id = ?', productId);\n    const newStock = calculateNewStock(product.stock, soldQuantity);\n    db.execute('UPDATE products SET stock = ? WHERE id = ?', [newStock, productId]);\n    return newStock;\n}\n```\n\nNext steps you might consider:\n1. Add unit tests for `calculateNewStock` so the pure logic stays covered.\n2. Wrap the shell in a retry/logging layer if needed for resiliency."
      }
    },
    {
      "name": "identify_side_effects",
      "baseline": {
        "pass": true,
        "response_preview": "- Function `validateAndLog` mixes validation (the functional core) with runtime effects: calling `co...",
        "response_full": "- Function `validateAndLog` mixes validation (the functional core) with runtime effects: calling `console.error` and `logger.info` both mutate external state (emitting logs) and break referential transparency.  \n- Because the error/log calls depend on external systems instead of returning values, the function no longer guarantees the same result for the same input; it also becomes harder to test and reuse.  \n- According to the Functional Core principle, the computational part should stay pure and isolated; side effects like logging should be pushed to an outer layer (the imperative shell) so the core stays predictable."
      },
      "skill": {
        "pass": true,
        "response_preview": "- **Issue**: `validateAndLog` mixes pure validation with logging, so it\u2019s not a pure \u201ccore\u201d function...",
        "response_full": "- **Issue**: `validateAndLog` mixes pure validation with logging, so it\u2019s not a pure \u201ccore\u201d function; `console.error` and `logger.info` are side effects (they interact with the console/log system) and make the output dependent on the environment rather than just the `user` input. This violates the core principle that pure functions should only compute and return values without touching IO.\n- **Fix idea**: Split into two steps\u2014one pure `isValidEmail(user)` that just returns a boolean, and an imperative shell that handles logging based on that boolean (e.g., log the error or success outside the pure function)."
      }
    }
  ],
  "judgment": {
    "principle_better": "B",
    "quality_better": "B",
    "overall_better": "B",
    "option_a_rating": "good",
    "option_b_rating": "outstanding",
    "score": 100,
    "reasoning": "Solution B keeps the business logic deterministic while adding extra validation and clearer layering, so its pure core is easier to test and the shell stays thin. Solution A already separates effects but lacks the additional rigor and explicit structure that makes B stand out."
  },
  "provider": "codex"
}