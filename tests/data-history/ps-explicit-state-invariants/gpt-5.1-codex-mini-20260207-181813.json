{
  "skill": "ps-explicit-state-invariants",
  "severity": "BLOCK",
  "model": "gpt-5.1-codex-mini",
  "baseline_rate": 100,
  "skill_rate": 100,
  "baseline_rating": "good",
  "skill_rating": "outstanding",
  "baseline_pass_count": "2/2",
  "skill_pass_count": "2/2",
  "improvement": 0,
  "results": [
    {
      "name": "refactor_boolean_explosion",
      "baseline": {
        "pass": true,
        "response_preview": "Use a discriminated union for each valid state, e.g.\n\n```ts\ntype LoadingState = { status: 'loading';...",
        "response_full": "Use a discriminated union for each valid state, e.g.\n\n```ts\ntype LoadingState = { status: 'loading'; isLoading: true; isError: false; data: null; error: null };\ntype ErrorState = { status: 'error'; isLoading: false; isError: true; data: null; error: string };\ntype SuccessState = { status: 'success'; isLoading: false; isError: false; data: DataType; error: null };\n\ntype State = LoadingState | ErrorState | SuccessState;\n\nconst state: State = {\n  status: 'error',\n  isLoading: false,\n  isError: true,\n  data: null,\n  error: 'Network timeout'\n};\n```\n\nNow `state` must match one of those variants, so (for example) `status: 'error'` automatically enforces the other fields for the error case."
      },
      "skill": {
        "pass": true,
        "response_preview": "Model the state as a discriminated union so only one of the mutually exclusive statuses can exist at...",
        "response_full": "Model the state as a discriminated union so only one of the mutually exclusive statuses can exist at a time, e.g.:\n\n```ts\ntype LoadState =\n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: Data }\n  | { status: 'error'; error: string };\n```\n\nInvariant: exactly one variant is active, so you can\u2019t simultaneously be loading and in error. Each transition is expressed by swapping to the appropriate variant (e.g., `state = { status: 'loading' }` before fetching, then `state = { status: 'success', data }` on success or `state = { status: 'error', error }` on failure)."
      }
    },
    {
      "name": "state_invariant_definition",
      "baseline": {
        "pass": true,
        "response_preview": "The primary invariant is that the state must always represent exactly one well\u2011formed wizard phase: ...",
        "response_full": "The primary invariant is that the state must always represent exactly one well\u2011formed wizard phase: `CurrentStep` identifies which step is active, `FormData` contains only the collected values for steps up through that active step, and `SubmissionResult` is populated only when `CurrentStep` equals the final step (and remains empty otherwise)."
      },
      "skill": {
        "pass": true,
        "response_preview": "**Multi-Step Wizard Invariant**: The wizard state must always be in exactly one of the discrete phas...",
        "response_full": "**Multi-Step Wizard Invariant**: The wizard state must always be in exactly one of the discrete phases\u2014e.g., `AwaitingStep(step, formData)`, `Submitting(step, formData)`, or `Submitted(step, formData, result)`\u2014such that the `current step` is the sole active step, `form data` covers exactly the inputs for steps up through that current step, and `submission result` exists only once the final step has completed (all other states keep it absent)."
      }
    }
  ],
  "judgment": {
    "principle_better": "B",
    "quality_better": "B",
    "overall_better": "B",
    "option_a_rating": "good",
    "option_b_rating": "outstanding",
    "score": 100,
    "reasoning": "Both use discriminated unions and state invariants, but B pairs those invariants with an explicit multi-step wizard model and keeps each transition focused on a single variant, which makes it more precise. B\u2019s lighter, more focused representation avoids redundant flags and keeps transitions atomic, improving maintainability and testability versus A\u2019s heavier flag combination. Therefore B better encapsulates the principle and yields a clearer, more adaptable implementation."
  },
  "timestamp": "2026-02-07T18:18:13",
  "provider": "codex"
}