{
  "skill": "ps-illegal-states-unrepresentable",
  "severity": "SUGGEST",
  "model": "rnj-1:8b",
  "skill_version": "1.0.0",
  "baseline_rate": 100,
  "skill_rate": 100,
  "baseline_rating": "regular",
  "skill_rating": "outstanding",
  "baseline_pass_count": "2/2",
  "skill_pass_count": "2/2",
  "improvement": 0,
  "results": [
    {
      "name": "email_verification_bug",
      "input": "We have a `User` record with an `email` field (string, optional) and an `email_verified` field (boolean).\n\nA bug recently caused the system to send \"Password Reset\" emails to `null` because `email_verified` was true but `email` was missing.\n\nChange the data model so that it is structurally impossible to have a \"verified\" status without an associated email address.",
      "expected": {
        "focus": "Does the solution link the verification status directly to the email field (e.g., a VerifiedEmail type)? "
      },
      "baseline": {
        "pass": true,
        "response_preview": "```python\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass User:\n    ...",
        "response_full": "```python\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass User:\n    email: Optional[str]\n    email_verified: bool\n\n    def __post_init__(self):\n        if self.email_verified and not self.email:\n            raise ValueError(\"Cannot have email_verified=True without an email address\")\n```"
      },
      "skill": {
        "pass": true,
        "response_preview": "We need to make it impossible to have `email_verified: true` without an `email`. This can be enforce...",
        "response_full": "We need to make it impossible to have `email_verified: true` without an `email`. This can be enforced by:\n\n1. Making `email` required in the database schema\n2. Adding a database constraint\n3. Adding application-level validation\n\nLet's implement this change:\n\n```sql\n-- Add NOT NULL constraint to email column\nALTER TABLE users\nALTER COLUMN email\nSET NOT NULL;\n\n-- Add CHECK constraint to ensure email_verified only when email exists\nALTER TABLE users\nADD CONSTRAINT email_verified_requires_email\nCHECK (\n    (email IS NOT NULL) OR (email_verified = false)\n);\n```\n\n```python\n# In application code, add validation\nclass User:\n    def __init__(self, email: str, email_verified: bool):\n        if email_verified and not email:\n            raise ValueError(\"Cannot have email_verified=True without email\")\n        self.email = email\n        self.email_verified = email_verified\n```\n\nThis ensures that:\n1. The database prevents invalid states at the schema level\n2. Application code validates the invariant\n3. It's impossible to have `email_verified: true` without an email address\n\nThe system will now be protected against the bug where password reset emails were sent to null addresses."
      }
    },
    {
      "name": "parser_vs_validator",
      "input": "We accept a 'phone number' string from an API. We validate it with regex, but then we continue to pass it around as a raw string.\n\nLater in the pipeline, another function has to re-validate it because it doesn't trust the string. This happens 5 times across the codebase.\n\nShow how to fix this redundancy. We want to validate once and then *know* for sure that the data is valid for the rest of the flow.",
      "expected": {
        "focus": "Does the solution parse the string into a specific 'PhoneNumber' type/object once, rather than validating ad-hoc?"
      },
      "baseline": {
        "pass": true,
        "response_preview": "To fix the redundancy of re-validating the phone number string multiple times, we can encapsulate th...",
        "response_full": "To fix the redundancy of re-validating the phone number string multiple times, we can encapsulate the validation logic within a class. This class will ensure that the phone number is validated only once and can be trusted throughout the pipeline.\n\nHere's how you can implement this:\n\n```python\nimport re\n\nclass PhoneNumber:\n    def __init__(self, phone_number):\n        if not self._is_valid(phone_number):\n            raise ValueError(\"Invalid phone number\")\n        self.phone_number = phone_number\n\n    def _is_valid(self, phone_number):\n        # Define your regex pattern here\n        pattern = r'^\\d{10}$'  # Example pattern for a 10-digit phone number\n        return re.match(pattern, phone_number) is not None\n\n    def get_phone_number(self):\n        return self.phone_number\n\n# Example usage:\ntry:\n    phone_number = PhoneNumber(\"1234567890\")\n    print(phone_number.get_phone_number())  # Output: 1234567890\nexcept ValueError as e:\n    print(e)\n```\n\nIn this solution:\n- The `PhoneNumber` class encapsulates the validation logic.\n- The `__init__` method validates the phone number during initialization.\n- The `_is_valid` method contains the regex pattern for validation.\n- The `get_phone_number` method returns the validated phone number.\n- If the phone number is invalid, a `ValueError` is raised, ensuring that the invalid phone number is not used further in the pipeline."
      },
      "skill": {
        "pass": true,
        "response_preview": "We'll fix this by creating a `PhoneNumber` type that validates once and then is guaranteed valid for...",
        "response_full": "We'll fix this by creating a `PhoneNumber` type that validates once and then is guaranteed valid for the rest of the pipeline. This eliminates redundant validation and makes the code safer.\n\n```python\nimport re\nfrom typing import Optional\n\n# Define the PhoneNumber type that validates once\nclass PhoneNumber:\n    def __init__(self, number: str):\n        # Validate once and only once\n        if not self._is_valid(number):\n            raise ValueError(f\"Invalid phone number: {number}\")\n        self._number = number\n    \n    @staticmethod\n    def _is_valid(number: str) -> bool:\n        # Simple regex for phone number validation\n        # This is just an example - adjust based on your actual requirements\n        pattern = r'^\\+?[1-9]\\d{1,14}$'  # Example pattern\n        return bool(re.match(pattern, number))\n    \n    def __str__(self):\n        return self._number\n    \n    def __repr__(self):\n        return f\"PhoneNumber({self._number})\"\n\n# Example usage\ndef process_phone_number(phone_str: str) -> None:\n    # Validate once and only once\n    phone = PhoneNumber(phone_str)\n    \n    # Now we know the phone number is valid\n    # No more validation needed anywhere else in the codebase\n    print(f\"Processing: {phone}\")\n    \n    # Example: No more validation needed\n    # This was a problem in the original code - multiple validation points\n    # Now we have only one validation point\n\n# Test the solution\nif __name__ == \"__main__\":\n    # Test valid and invalid numbers\n    valid_numbers = [\"+1234567890\", \"+19876543210\"]\n    invalid_numbers = [\"123\", \"abc\", \"12345678901234567890\"]\n    \n    print(\"Testing valid numbers:\")\n    for num in valid_numbers:\n        try:\n            phone = PhoneNumber(num)\n            process_phone_number(num)\n        except ValueError as e:\n            print(f\"Error: {e}\")\n    \n    print(\"\\nTesting invalid numbers:\")\n    for num in invalid_numbers:\n        try:\n            phone = PhoneNumber(num)\n            process_phone_number(num)\n        except ValueError as e:\n            print(f\"Error: {e}\")\n```\n\n**Key Improvements:**\n\n1. **Single Validation Point:** The `PhoneNumber` class validates once and only once. No more redundant validation in the codebase.\n\n2. **Type Safety:** The `PhoneNumber` class ensures that any code working with phone numbers knows the number is valid.\n\n3. **No More Defensive Checks:** No more `if is_valid(phone):` checks scattered throughout the codebase.\n\n4. **Clearer Intent:** The code now clearly shows that phone numbers are validated once and only once.\n\n5. **Testable:** The `PhoneNumber` class can be easily tested with unit tests.\n\nThis approach eliminates the redundancy of validating the same data multiple times and makes the codebase safer and more maintainable."
      }
    }
  ],
  "judgment": {
    "principle_better": "B",
    "quality_better": "B",
    "overall_better": "B",
    "option_a_rating": "regular",
    "option_b_rating": "outstanding",
    "score": 100,
    "reasoning": "Solution B is outstanding because it fully implements the principle by making illegal states unrepresentable through type system enforcement. Solution A only partially addresses the issue by adding database constraints but still allows invalid states in the application layer. Solution B's PhoneNumber type ensures that invalid phone numbers are impossible to create, making the system more robust and maintainable. The type-safe approach eliminates redundant validation and makes the codebase safer."
  },
  "timestamp": "2026-02-07T22:55:27",
  "provider": "ollama"
}