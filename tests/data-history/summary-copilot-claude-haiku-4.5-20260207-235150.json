{
  "timestamp": "2026-02-07T23:51:50",
  "results": [
    {
      "skill": "ps-composition-over-coordination",
      "severity": "SUGGEST",
      "model": "claude-haiku-4.5",
      "skill_version": "1.0.0",
      "baseline_rate": 100,
      "skill_rate": 100,
      "baseline_rating": "regular",
      "skill_rating": "outstanding",
      "baseline_pass_count": "2/2",
      "skill_pass_count": "2/2",
      "improvement": 0,
      "judge_error": false,
      "results": [
        {
          "name": "payment_system_design",
          "input": "We are building a new payment processing backend. The current requirement is linear: \n1. Authenticate Request\n2. Validate Input\n3. Fraud Check\n4. Charge Card\n5. Save Receipt\n6. Send Email\n\nHowever, we expect the flow to become much more complex soon (e.g., conditional steps, A/B testing different flows). \n\nWrite code to implement this flow. Focus on making it easy to change the order of steps or add new steps without rewriting the whole flow.",
          "expected": {
            "focus": "Does the solution use small, independent functions/classes? Does it avoid a single giant function that does everything?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "# Payment Processing Flow Engine\n\nHere's a flexible, extensible implementation using a **pipeline pa...",
            "response_full": "# Payment Processing Flow Engine\n\nHere's a flexible, extensible implementation using a **pipeline pattern** that makes it trivial to reorder steps or add new ones:\n\n```typescript\n// Core Flow Engine\ntype StepResult<T> = { success: boolean; data: T; error?: string };\ntype StepHandler<T> = (context: T) => Promise<StepResult<T>>;\n\ninterface PaymentContext {\n  request?: any;\n  validated?: boolean;\n  riskScore?: number;\n  chargeResult?: any;\n  receipt?: any;\n  email?: string;\n  [key: string]: any;\n}\n\nclass PaymentFlow {\n  private steps: Map<string, StepHandler<PaymentContext>> = new Map();\n  private order: string[] = [];\n\n  registerStep(name: string, handler: StepHandler<PaymentContext>): this {\n    this.steps.set(name, handler);\n    return this;\n  }\n\n  setOrder(stepNames: string[]): this {\n    this.order = stepNames;\n    return this;\n  }\n\n  async execute(context: PaymentContext): Promise<PaymentContext> {\n    for (const stepName of this.order) {\n      const handler = this.steps.get(stepName);\n      if (!handler) throw new Error(`Step not found: ${stepName}`);\n\n      console.log(`Executing: ${stepName}`);\n      const result = await handler(context);\n\n      if (!result.success) {\n        throw new Error(`${stepName} failed: ${result.error}`);\n      }\n      context = result.data;\n    }\n    return context;\n  }\n}\n\n// Step Implementations\nconst authenticateRequest: StepHandler<PaymentContext> = async (context) => {\n  // Validate API key, JWT, etc.\n  console.log(\"  \u2713 Request authenticated\");\n  return { success: true, data: { ...context, authenticated: true } };\n};\n\nconst validateInput: StepHandler<PaymentContext> = async (context) => {\n  const { amount, cardNumber, email } = context.request;\n  const valid = amount > 0 && cardNumber && email;\n  if (!valid) {\n    return { success: false, data: context, error: \"Invalid input\" };\n  }\n  console.log(\"  \u2713 Input validated\");\n  return { success: true, data: { ...context, validated: true, email } };\n};\n\nconst fraudCheck: StepHandler<PaymentContext> = async (context) => {\n  // Call fraud detection service\n  const riskScore = Math.random() * 100;\n  if (riskScore > 80) {\n    return { success: false, data: context, error: \"High fraud risk\" };\n  }\n  console.log(`  \u2713 Fraud check passed (risk: ${riskScore.toFixed(1)}%)`);\n  return { success: true, data: { ...context, riskScore } };\n};\n\nconst chargeCard: StepHandler<PaymentContext> = async (context) => {\n  // Call payment processor\n  const chargeResult = {\n    transactionId: `txn_${Date.now()}`,\n    amount: context.request.amount,\n    status: \"success\"\n  };\n  console.log(`  \u2713 Card charged (${chargeResult.transactionId})`);\n  return { success: true, data: { ...context, chargeResult } };\n};\n\nconst saveReceipt: StepHandler<PaymentContext> = async (context) => {\n  // Save to database\n  const receipt = {\n    id: `rcpt_${Date.now()}`,\n    transactionId: context.chargeResult.transactionId,\n    amount: context.chargeResult.amount,\n    timestamp: new Date().toISOString()\n  };\n  console.log(`  \u2713 Receipt saved (${receipt.id})`);\n  return { success: true, data: { ...context, receipt } };\n};\n\nconst sendEmail: StepHandler<PaymentContext> = async (context) => {\n  // Queue email job\n  console.log(`  \u2713 Confirmation email queued to ${context.email}`);\n  return { success: true, data: context };\n};\n\n// Usage: Standard flow\nasync function processPayment() {\n  const flow = new PaymentFlow();\n\n  flow\n    .registerStep(\"authenticate\", authenticateRequest)\n    .registerStep(\"validate\", validateInput)\n    .registerStep(\"fraud_check\", fraudCheck)\n    .registerStep(\"charge\", chargeCard)\n    .registerStep(\"receipt\", saveReceipt)\n    .registerStep(\"email\", sendEmail)\n    .setOrder([\"authenticate\", \"validate\", \"fraud_check\", \"charge\", \"receipt\", \"email\"]);\n\n  const result = await flow.execute({\n    request: {\n      amount: 99.99,\n      cardNumber: \"4111111111111111\",\n      email: \"customer@example.com\"\n    }\n  });\n\n  console.log(\"Payment successful:\", result.chargeResult);\n}\n\n// CHANGING THE ORDER: Just reorder the steps\n// flow.setOrder([\"authenticate\", \"validate\", \"receipt\", \"charge\", \"fraud_check\", \"email\"]);\n\n// ADDING NEW STEPS:\n// flow.registerStep(\"log_analytics\", async (ctx) => { /* track metrics */ });\n// flow.setOrder([..., \"log_analytics\"]);\n\n// CONDITIONAL LOGIC (Advanced):\nclass ConditionalPaymentFlow extends PaymentFlow {\n  async executeConditional(context: PaymentContext, conditions: Map<string, boolean>) {\n    const steps = this[\"order\"].filter(step => \n      conditions.get(step) !== false\n    );\n    // Execute filtered steps...\n  }\n}\n\n// A/B TESTING (Advanced):\nclass ABTestFlow extends PaymentFlow {\n  async executeABTest(context: PaymentContext, variant: \"A\" | \"B\") {\n    const orderA = [\"authenticate\", \"validate\", \"fraud_check\", \"charge\", \"receipt\", \"email\"];\n    const orderB = [\"authenticate\", \"charge\", \"fraud_check\", \"validate\", \"receipt\", \"email\"]; // Reordered\n    this.setOrder(variant === \"A\" ? orderA : orderB);\n    return await this.execute(context);\n  }\n}\n\nprocessPayment().catch(console.error);\n```\n\n**Key Design Benefits:**\n\n1. **Easy Reordering**: Change `.setOrder([...])` without touching step logic\n2. **Easy Addition**: New steps are `.registerStep()` + add to order\n3. **Extensible**: Inherit `PaymentFlow` for conditional/A/B testing logic\n4. **Composable**: Each step is isolated and can be unit tested\n5. **Centralized Control**: See entire flow in one place via `setOrder()`\n\n**For Complex Future Needs:**\n- Wrap steps in conditionals: `if (context.country === 'US') execute('additional_check')`\n- Create parallel flows for A/B testing\n- Add retry logic or rollback handlers\n- Implement step dependencies and branching"
          },
          "skill": {
            "pass": true,
            "response_preview": "# Payment Processing Pipeline - Composition Design\n\nHere's a payment processing backend built on com...",
            "response_full": "# Payment Processing Pipeline - Composition Design\n\nHere's a payment processing backend built on composition, designed for easy modification and extension:\n\n```typescript\n// Step interfaces - each step is a focused unit\ninterface PaymentContext {\n  request: PaymentRequest;\n  userId: string;\n  isAuthenticated: boolean;\n  isValid: boolean;\n  fraudScore: number;\n  chargeId?: string;\n  receiptId?: string;\n  emailSent?: boolean;\n}\n\ninterface PaymentRequest {\n  amount: number;\n  currency: string;\n  cardToken: string;\n}\n\ntype PaymentStep = (context: PaymentContext) => Promise<PaymentContext>;\n\n// Individual focused units - each does ONE thing\nconst authenticateRequest: PaymentStep = async (context) => {\n  // Authenticate and extract userId\n  context.userId = await verifyToken(context.request);\n  context.isAuthenticated = true;\n  return context;\n};\n\nconst validateInput: PaymentStep = async (context) => {\n  if (context.request.amount <= 0) throw new Error(\"Invalid amount\");\n  if (!context.request.cardToken) throw new Error(\"Missing card token\");\n  context.isValid = true;\n  return context;\n};\n\nconst fraudCheck: PaymentStep = async (context) => {\n  context.fraudScore = await calculateFraudScore(context.userId, context.request);\n  if (context.fraudScore > 0.8) throw new Error(\"Fraud detected\");\n  return context;\n};\n\nconst chargeCard: PaymentStep = async (context) => {\n  context.chargeId = await processCardCharge(context.request, context.userId);\n  return context;\n};\n\nconst saveReceipt: PaymentStep = async (context) => {\n  context.receiptId = await storeReceipt({\n    userId: context.userId,\n    amount: context.request.amount,\n    chargeId: context.chargeId,\n  });\n  return context;\n};\n\nconst sendEmail: PaymentStep = async (context) => {\n  await emailService.sendReceipt(context.userId, context.receiptId);\n  context.emailSent = true;\n  return context;\n};\n\n// Pipeline composer - chains steps together\nconst createPaymentPipeline = (...steps: PaymentStep[]) => {\n  return async (request: PaymentRequest): Promise<PaymentContext> => {\n    let context: PaymentContext = {\n      request,\n      userId: \"\",\n      isAuthenticated: false,\n      isValid: false,\n      fraudScore: 0,\n    };\n\n    for (const step of steps) {\n      context = await step(context);\n    }\n\n    return context;\n  };\n};\n\n// Usage - compose the pipeline easily\nconst processPayment = createPaymentPipeline(\n  authenticateRequest,\n  validateInput,\n  fraudCheck,\n  chargeCard,\n  saveReceipt,\n  sendEmail\n);\n\n// Example: Easy to reorder\nconst fastTrackPayment = createPaymentPipeline(\n  authenticateRequest,\n  chargeCard,\n  validateInput, // Validate after charge for speed\n  fraudCheck,\n  saveReceipt,\n  sendEmail\n);\n\n// Example: Easy to extend - add new steps without touching existing ones\nconst riskBasedPayment = createPaymentPipeline(\n  authenticateRequest,\n  validateInput,\n  fraudCheck,\n  async (context) => {\n    // New conditional step\n    if (context.fraudScore > 0.5) {\n      await notifySecurityTeam(context.userId);\n    }\n    return context;\n  },\n  chargeCard,\n  saveReceipt,\n  sendEmail\n);\n\n// Implementation details (dependencies)\nasync function verifyToken(request: PaymentRequest): Promise<string> {\n  // Authenticate token, return userId\n  return \"user-123\";\n}\n\nasync function calculateFraudScore(userId: string, request: PaymentRequest): Promise<number> {\n  // Calculate fraud risk\n  return 0.2;\n}\n\nasync function processCardCharge(request: PaymentRequest, userId: string): Promise<string> {\n  // Charge the card\n  return \"charge-456\";\n}\n\nasync function storeReceipt(data: { userId: string; amount: number; chargeId: string }): Promise<string> {\n  // Save receipt to database\n  return \"receipt-789\";\n}\n\nconst emailService = {\n  sendReceipt: async (userId: string, receiptId: string) => {\n    // Send email\n  },\n};\n\nasync function notifySecurityTeam(userId: string) {\n  // Alert security\n}\n```\n\n## Key Benefits of This Design\n\n\u2705 **Easy to reorder steps**: Just pass them in different order to `createPaymentPipeline`  \n\u2705 **Easy to add new steps**: Create a new step function, add to pipeline  \n\u2705 **Easy to conditionally skip steps**: Wrap in a step that checks a condition  \n\u2705 **Easy to A/B test flows**: Create multiple pipelines with different step orders  \n\u2705 **Each step is testable**: Mock the context, test step in isolation  \n\u2705 **No central coordinator**: No \"PaymentManager\" orchestrating everything  \n\n## To extend further:\n\n```typescript\n// Add retry logic without changing steps\nconst retryableStep = (step: PaymentStep, maxRetries = 3): PaymentStep => {\n  return async (context) => {\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        return await step(context);\n      } catch (e) {\n        if (i === maxRetries - 1) throw e;\n      }\n    }\n    return context;\n  };\n};\n\n// Add parallel steps\nconst parallelSteps = (steps: PaymentStep[]): PaymentStep => {\n  return async (context) => {\n    await Promise.all(steps.map(step => step(context)));\n    return context;\n  };\n};\n```\n\nThis composition-based approach scales as your flow grows increasingly complex."
          }
        },
        {
          "name": "bottleneck_analysis",
          "input": "We have a `LegacyManager` class in our system that takes 15 different service dependencies in its constructor and has methods like `createUser`, `processPayment`, `exportData`, and `sendNewsletter`. \n\nExplain the concrete risks of this design for a team of 10 developers working on this codebase simultaneously.",
          "expected": {
            "focus": "Does the answer identify conflicts, testing difficulty, and tight coupling?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "# Concrete Risks of LegacyManager Design for a 10-Developer Team\n\n**Merge Conflict Chaos**\nEvery dev...",
            "response_full": "# Concrete Risks of LegacyManager Design for a 10-Developer Team\n\n**Merge Conflict Chaos**\nEvery developer touching different methods (`createUser`, `processPayment`, `exportData`, `sendNewsletter`) modifies the same file. With 10 developers, expect daily merge conflicts in `LegacyManager.java/LegacyManager.ts`, blocking pull requests and fragmenting focus.\n\n**Cascading Test Failures**\nAll 15 service dependencies must be mocked for any unit test. When one developer changes a dependency's interface, tests fail across the entire team's work-in-progress branches. A payment service refactor breaks tests for user creation and newsletter logic\u2014unrelated code, same file.\n\n**Deployment Bottlenecks**\nSimple bug fixes in `sendNewsletter` risk breaking `createUser` because the method signatures and constructor are tightly coupled. A developer must now coordinate with teammates, fear their change impacts payment processing, and increase test scope before deployment.\n\n**Onboarding Paralysis**\nA new developer investigating one feature (like fixing `exportData`) must understand all 15 dependencies and their interactions just to read the code. The complexity forces documentation debt and longer code reviews.\n\n**Impossible Code Ownership**\nNo developer can cleanly own a feature. The `processPayment` owner cannot independently refactor without negotiating changes with the `createUser` owner in the same shared class, creating artificial dependencies.\n\n**Slow Test Suites**\nWith 15 service dependencies injected, every test setup takes longer. Running tests becomes slower for all developers, increasing CI/CD friction and encouraging developers to skip local testing before pushing.\n\n**The Core Risk**: This design makes the class a shared resource bottleneck. At 10 developers, you've effectively created a single point of serial coordination for all changes touching these methods."
          },
          "skill": {
            "pass": true,
            "response_preview": "# Concrete Risks for a 10-Developer Team\n\n## Immediate Merge Conflicts & Bottleneck\n- **Every constr...",
            "response_full": "# Concrete Risks for a 10-Developer Team\n\n## Immediate Merge Conflicts & Bottleneck\n- **Every constructor change blocks multiple developers**: Adding a new dependency to support `sendNewsletter` requires modifying the class definition that 8 other developers may be touching simultaneously (for `createUser`, `processPayment`, `exportData` changes).\n- **Parallel feature work becomes serialized**: Developer A needs to add an email service; Developer B needs a payment service; Developer C needs a database service. All three collide on the same constructor, causing constant rebase cycles.\n\n## Testing & Verification Paralysis\n- **Test setup becomes prohibitively expensive**: To test `sendNewsletter`, you must mock or construct all 15 services correctly. No developer knows which ones are actually used. Two developers build contradictory test fixtures, leading to flaky tests.\n- **Test failures become blame-passing**: When `processPayment` tests fail, does it fail due to the payment service, the logger, the audit service, or the email service? The coupling hides causality.\n\n## Hidden Impact & Cascading Bugs\n- **Changes in one method silently break others**: A developer fixes `createUser` by caching a service result. Unknown to them, `processPayment` relied on that service being fresh. Bug appears in production weeks later.\n- **Dependency version conflicts force painful coordination**: Team A upgrades the email service; Team B needs the old version for payment notifications. Both modifications live in the same constructor\u2014impossible to resolve without one team backing down.\n\n## Onboarding & Cognitive Load\n- **New developers waste days understanding coupling**: \"Why does a user creation method hold a reference to the newsletter service? To the export service? To the payment processor?\" No clear answers. Reduced productivity for 2-3 weeks.\n- **Code review becomes meaningless**: Reviewers can't assess the impact of a change to `createUser` without understanding how it interacts with the other 14 dependencies.\n\n## Architectural Debt & Refactoring Lock-In\n- **Impossible to split work by responsibility**: You can't assign \"user creation\" to one team and \"payments\" to another\u2014they share the same class. Coordination overhead explodes with team size.\n- **Prevents incremental deployment**: You can't deploy `createUser` improvements without ensuring the payment service, export service, and newsletter service are all compatible and deployed first. A single dependency issue blocks all features.\n\n## Example Scenario: 2-Week Project\n- **Week 1**: Team wants to optimize `createUser`. Discovers it's coupled to payment and newsletter services. Changes constructor signature.\n- **Days later**: Three other teams have pending changes to the constructor (unrelated features). Merge conflicts rage. Lost 3 days to rebasing and coordination.\n- **Week 2**: Finally merged. New bug: `exportData` now mysteriously fails because it inadvertently relied on an initialization order that changed.\n\n**Bottom line**: The class is a single point of contention for 10 developers. Every change is a transaction that requires coordination. It transforms a technical problem (modular design) into an organizational one (constant meetings to resolve conflicts)."
          }
        }
      ],
      "judgment": {
        "principle_better": "B",
        "quality_better": "B",
        "overall_better": "B",
        "option_a_rating": "regular",
        "option_b_rating": "outstanding",
        "score": 100,
        "reasoning": "Solution A extracts focused units but immediately re-couples them through a central `PaymentFlow` coordinator class with orchestration logic in the `execute()` method, directly violating the principle's core premise. Solution B demonstrates pure composition\u2014simple functions composable directly via `createPaymentPipeline()` with zero central coordination, no class boilerplate, and extensibility through functional composition (wrappers, higher-order functions) rather than manager inheritance. Solution B achieves 'build from simple units'; Solution A adds a manager layer on top."
      }
    },
    {
      "skill": "ps-error-handling-design",
      "severity": "WARN",
      "model": "claude-haiku-4.5",
      "skill_version": "1.0.0",
      "baseline_rate": 100,
      "skill_rate": 100,
      "baseline_rating": "good",
      "skill_rating": "outstanding",
      "baseline_pass_count": "2/2",
      "skill_pass_count": "2/2",
      "improvement": 0,
      "judge_error": false,
      "results": [
        {
          "name": "auth_error_handling",
          "input": "The current `login` function returns `null` if anything goes wrong (user missing, wrong password, db down). This leads to a generic \"Login Failed\" error on the frontend, which frustrates users who might just have a typo, and confuses support teams when the DB is actually down.\n\nRefactor the return values/mechanism so the caller can definitively distinguish between:\n1. Invalid Credentials (user actionable)\n2. Account Locked (user actionable)\n3. System/Network Failure (retryable)\n\nProvide the code for the logic and the data structures used.",
          "expected": {
            "focus": "Does the solution return structured error info (e.g., error codes, types) instead of a generic null/false?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "I'll provide the refactored code structure for distinguishing login failures:\n\n## Data Structures\n\n`...",
            "response_full": "I'll provide the refactored code structure for distinguishing login failures:\n\n## Data Structures\n\n```typescript\n// Define error types as an enum\nenum LoginErrorType {\n  INVALID_CREDENTIALS = \"INVALID_CREDENTIALS\",\n  ACCOUNT_LOCKED = \"ACCOUNT_LOCKED\",\n  SYSTEM_FAILURE = \"SYSTEM_FAILURE\"\n}\n\n// Result type for login function\ntype LoginResult = \n  | { success: true; user: User; token: string }\n  | { success: false; error: LoginErrorType; message: string; retryable: boolean };\n```\n\n## Refactored Login Function\n\n```typescript\nasync function login(email: string, password: string): Promise<LoginResult> {\n  try {\n    // Attempt database connection\n    const user = await db.users.findByEmail(email);\n    \n    // User not found\n    if (!user) {\n      return {\n        success: false,\n        error: LoginErrorType.INVALID_CREDENTIALS,\n        message: \"Invalid email or password\",\n        retryable: false\n      };\n    }\n    \n    // Check if account is locked\n    if (user.lockedUntil && user.lockedUntil > new Date()) {\n      return {\n        success: false,\n        error: LoginErrorType.ACCOUNT_LOCKED,\n        message: `Account locked until ${user.lockedUntil.toISOString()}`,\n        retryable: false\n      };\n    }\n    \n    // Verify password\n    const isValid = await bcrypt.compare(password, user.passwordHash);\n    if (!isValid) {\n      // Increment failed attempts\n      await db.users.incrementFailedAttempts(user.id);\n      \n      return {\n        success: false,\n        error: LoginErrorType.INVALID_CREDENTIALS,\n        message: \"Invalid email or password\",\n        retryable: false\n      };\n    }\n    \n    // Reset failed attempts on success\n    await db.users.resetFailedAttempts(user.id);\n    \n    // Generate token\n    const token = generateJWT(user);\n    \n    return {\n      success: true,\n      user,\n      token\n    };\n    \n  } catch (error) {\n    // Network/database/system failures\n    if (error instanceof DatabaseConnectionError || \n        error instanceof NetworkTimeoutError) {\n      return {\n        success: false,\n        error: LoginErrorType.SYSTEM_FAILURE,\n        message: \"Service temporarily unavailable. Please try again later.\",\n        retryable: true\n      };\n    }\n    \n    // Log unexpected errors\n    logger.error(\"Login error:\", error);\n    \n    return {\n      success: false,\n      error: LoginErrorType.SYSTEM_FAILURE,\n      message: \"An unexpected error occurred. Please try again.\",\n      retryable: true\n    };\n  }\n}\n```\n\n## Frontend Usage\n\n```typescript\nconst result = await login(email, password);\n\nif (result.success) {\n  // Login successful\n  localStorage.setItem('token', result.token);\n  navigateTo('/dashboard');\n} else {\n  switch (result.error) {\n    case LoginErrorType.INVALID_CREDENTIALS:\n      showError(\"Invalid email or password. Check for typos.\");\n      break;\n    case LoginErrorType.ACCOUNT_LOCKED:\n      showError(result.message);\n      disableRetryButton(); // Don't allow immediate retry\n      break;\n    case LoginErrorType.SYSTEM_FAILURE:\n      showError(result.message);\n      enableRetryButton(); // Allow retry for transient failures\n      break;\n  }\n}\n```\n\n## Key Benefits\n\n- **Type-safe**: TypeScript compiler enforces handling all error cases\n- **Actionable frontend**: Different error types trigger different UI responses\n- **Support clarity**: System teams can diagnose by error type, not generic \"Login Failed\"\n- **User-friendly**: Invalid credentials message doesn't reveal account enumeration info\n- **Retryable flag**: Frontend can intelligently show/hide retry options"
          },
          "skill": {
            "pass": true,
            "response_preview": "# Explicit Error Handling for Login\n\nHere's the refactored implementation using a Result type patter...",
            "response_full": "# Explicit Error Handling for Login\n\nHere's the refactored implementation using a Result type pattern:\n\n## Data Structures\n\n```typescript\n// Error type definitions\ntype LoginError = \n  | { type: \"INVALID_CREDENTIALS\"; attemptedUsername: string }\n  | { type: \"ACCOUNT_LOCKED\"; lockedUntil: Date; reason: string }\n  | { type: \"SYSTEM_FAILURE\"; cause: \"DATABASE\" | \"NETWORK\"; retryable: true }\n\n// Result wrapper type\ntype Result<T, E> = \n  | { success: true; value: T }\n  | { success: false; error: E }\n\n// Success type\ninterface LoginSuccess {\n  userId: string\n  token: string\n  sessionId: string\n}\n```\n\n## Refactored Login Function\n\n```typescript\nfunction login(username: string, password: string): Result<LoginSuccess, LoginError> {\n  // Validate input first (prevents null pointer errors)\n  if (!username?.trim() || !password) {\n    return {\n      success: false,\n      error: { type: \"INVALID_CREDENTIALS\", attemptedUsername: username }\n    }\n  }\n\n  try {\n    // Try to fetch user from database\n    const user = database.findByUsername(username)\n    \n    // User not found = invalid credentials (expected business failure)\n    if (!user) {\n      return {\n        success: false,\n        error: { type: \"INVALID_CREDENTIALS\", attemptedUsername: username }\n      }\n    }\n\n    // Check if account is locked (expected domain rule)\n    if (user.isLocked) {\n      return {\n        success: false,\n        error: {\n          type: \"ACCOUNT_LOCKED\",\n          lockedUntil: user.lockedUntil,\n          reason: \"Too many failed attempts\"\n        }\n      }\n    }\n\n    // Verify password (expected business check)\n    const passwordMatch = crypto.compare(password, user.passwordHash)\n    if (!passwordMatch) {\n      // Increment failed attempts\n      user.failedAttempts += 1\n      if (user.failedAttempts >= 5) {\n        user.isLocked = true\n        user.lockedUntil = new Date(Date.now() + 30 * 60 * 1000) // 30 min\n      }\n      database.updateUser(user)\n\n      return {\n        success: false,\n        error: { type: \"INVALID_CREDENTIALS\", attemptedUsername: username }\n      }\n    }\n\n    // Success path\n    const token = generateJWT(user.id)\n    user.failedAttempts = 0 // Reset on success\n    database.updateUser(user)\n\n    return {\n      success: true,\n      value: {\n        userId: user.id,\n        token,\n        sessionId: generateSessionId()\n      }\n    }\n\n  } catch (error) {\n    // Infrastructure failure (non-recoverable at this layer)\n    // Distinguish by error type\n    if (error instanceof DatabaseError) {\n      return {\n        success: false,\n        error: { type: \"SYSTEM_FAILURE\", cause: \"DATABASE\", retryable: true }\n      }\n    }\n    \n    if (error instanceof NetworkError) {\n      return {\n        success: false,\n        error: { type: \"SYSTEM_FAILURE\", cause: \"NETWORK\", retryable: true }\n      }\n    }\n\n    // Unexpected error = programming error, crash\n    throw error\n  }\n}\n```\n\n## Caller Usage Pattern\n\n```typescript\nfunction handleLoginRequest(username: string, password: string): HttpResponse {\n  const result = login(username, password)\n\n  if (result.success) {\n    // Happy path: user authenticated\n    return {\n      status: 200,\n      body: { token: result.value.token, sessionId: result.value.sessionId }\n    }\n  }\n\n  // Error handling by type\n  switch (result.error.type) {\n    case \"INVALID_CREDENTIALS\":\n      // User actionable - they made a mistake\n      return {\n        status: 401,\n        body: { error: \"Invalid username or password\" }\n      }\n\n    case \"ACCOUNT_LOCKED\":\n      // User actionable - tell them when they can try again\n      return {\n        status: 403,\n        body: {\n          error: \"Account locked due to too many failed attempts\",\n          lockedUntil: result.error.lockedUntil,\n          retryAfter: Math.ceil((result.error.lockedUntil.getTime() - Date.now()) / 1000)\n        }\n      }\n\n    case \"SYSTEM_FAILURE\":\n      // Retryable infrastructure failure\n      logger.error(\"Login system failure\", {\n        cause: result.error.cause,\n        timestamp: new Date(),\n        username\n      })\n\n      if (result.error.cause === \"DATABASE\") {\n        // Maybe retry with exponential backoff internally\n        return {\n          status: 503,\n          body: { error: \"Database temporarily unavailable. Please try again.\" }\n        }\n      } else {\n        // Network error\n        return {\n          status: 503,\n          body: { error: \"Service temporarily unavailable. Please try again.\" }\n        }\n      }\n  }\n}\n```\n\n## Key Improvements\n\n1. **Explicit return type**: `Result<LoginSuccess, LoginError>` makes failure modes visible\n2. **Categorized errors**: Domain errors (invalid creds, locked) vs infrastructure errors\n3. **Type-safe handling**: Caller's compiler forces handling all error cases\n4. **User actionable**: Each error provides specific guidance (retry when, why locked, etc.)\n5. **Support friendly**: Logs distinguish between user error and system failure\n6. **No null returns**: Errors are explicit values, not absence of a value\n\nThe caller can now implement retry logic only for `SYSTEM_FAILURE`, provide specific UI messages for `INVALID_CREDENTIALS`, and handle `ACCOUNT_LOCKED` with countdown timers\u2014all because the error type makes these distinctions explicit."
          }
        },
        {
          "name": "robust_registration_design",
          "input": "We need to process a batch of user imports. Some might have invalid data, others might fail due to database constraint violations.\n\nwrite a processor function that handles these failures appropriately:\n- Invalid data: Skip and report.\n- DB Constraint: Skip and report.\n- DB Connection Loss: Stop processing and throw/alert.\n\nShow how you distinguish these cases in code.",
          "expected": {
            "focus": "Does the code differentiate between recoverable item-level errors and fatal batch-level errors?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "```javascript\nclass UserImportProcessor {\n  async processBatch(users) {\n    const results = { proces...",
            "response_full": "```javascript\nclass UserImportProcessor {\n  async processBatch(users) {\n    const results = { processed: 0, skipped: 0, errors: [] };\n    \n    for (const user of users) {\n      try {\n        await this.validateAndInsert(user);\n        results.processed++;\n      } catch (error) {\n        // Distinguish error types\n        if (this.isValidationError(error)) {\n          results.errors.push({\n            type: 'INVALID_DATA',\n            user: user.id,\n            reason: error.message\n          });\n          results.skipped++;\n        } \n        else if (this.isConstraintError(error)) {\n          results.errors.push({\n            type: 'DB_CONSTRAINT',\n            user: user.id,\n            reason: error.message\n          });\n          results.skipped++;\n        } \n        else if (this.isConnectionError(error)) {\n          // Stop immediately on connection loss\n          results.errors.push({\n            type: 'DB_CONNECTION_LOST',\n            user: user.id,\n            reason: error.message\n          });\n          throw new Error(`Processing halted at user ${user.id}: Connection lost`);\n        } \n        else {\n          // Unknown error - also stop\n          throw error;\n        }\n      }\n    }\n    \n    return results;\n  }\n  \n  isValidationError(error) {\n    return error.name === 'ValidationError' || \n           error.code === 'INVALID_DATA' ||\n           error instanceof ValidationError;\n  }\n  \n  isConstraintError(error) {\n    // Check for database-specific constraint violation codes\n    return error.code === 'ER_DUP_ENTRY' ||           // MySQL duplicate key\n           error.code === '23505' ||                   // PostgreSQL unique violation\n           error.code === 'SQLITE_CONSTRAINT' ||       // SQLite\n           error.constraint !== undefined ||           // Generic constraint property\n           error.message?.includes('UNIQUE constraint failed') ||\n           error.message?.includes('duplicate key');\n  }\n  \n  isConnectionError(error) {\n    return error.code === 'ECONNREFUSED' ||\n           error.code === 'ENOTFOUND' ||\n           error.code === 'PROTOCOL_CONNECTION_LOST' ||\n           error.code === 'PROTOCOL_SEQUENCE_TIMEOUT' ||\n           error.message?.includes('connection') && \n           (error.message?.includes('lost') || \n            error.message?.includes('refused') ||\n            error.message?.includes('timeout'));\n  }\n  \n  async validateAndInsert(user) {\n    // Validation happens first\n    if (!user.email || !user.name) {\n      const error = new Error('Missing required fields');\n      error.code = 'INVALID_DATA';\n      throw error;\n    }\n    \n    // Database insert\n    return await db.users.insert(user);\n  }\n}\n\n// Usage\nconst processor = new UserImportProcessor();\ntry {\n  const results = await processor.processBatch(users);\n  console.log(`Processed: ${results.processed}, Skipped: ${results.skipped}`);\n  console.log('Skipped errors:', results.errors);\n} catch (error) {\n  console.error('CRITICAL - Processing stopped:', error.message);\n  // Alert/notify system of connection loss\n  await notificationService.alert(error.message);\n}\n```\n\n**Key distinctions:**\n- **Validation errors**: Caught immediately, skipped with error logged\n- **Constraint errors**: DB-specific codes (ER_DUP_ENTRY, 23505) caught, skipped with error logged  \n- **Connection errors**: ECONNREFUSED, ENOTFOUND, PROTOCOL_* codes trigger immediate halt with throw/alert"
          },
          "skill": {
            "pass": true,
            "response_preview": "# User Import Processor with Explicit Error Handling\n\nHere's a solution applying the principle\u2014disti...",
            "response_full": "# User Import Processor with Explicit Error Handling\n\nHere's a solution applying the principle\u2014distinguishing **recoverable domain errors** (skip & report) from **non-recoverable infrastructure errors** (fail-fast):\n\n```typescript\n// ============ Error Types ============\n\n// Domain errors: Recoverable, return as Result\ntype ValidationError = {\n  type: \"VALIDATION_ERROR\";\n  field: string;\n  message: string;\n  userId: string;\n};\n\ntype ConstraintError = {\n  type: \"CONSTRAINT_VIOLATION\";\n  constraint: string;\n  message: string;\n  userId: string;\n};\n\ntype DomainError = ValidationError | ConstraintError;\n\n// Result type: Forces callers to handle both paths\ntype Result<T, E> = { ok: true; value: T } | { ok: false; error: E };\n\n// Infrastructure errors: Non-recoverable, thrown directly\nclass DatabaseConnectionError extends Error {\n  constructor(message: string, readonly originalError: Error) {\n    super(`Database connection lost: ${message}`);\n    this.name = \"DatabaseConnectionError\";\n  }\n}\n\n// ============ Domain Logic Layer ============\n\nfunction validateUser(data: any): Result<User, ValidationError> {\n  if (!data.email || !data.email.includes(\"@\")) {\n    return {\n      ok: false,\n      error: {\n        type: \"VALIDATION_ERROR\",\n        field: \"email\",\n        message: \"Invalid email format\",\n        userId: data.id,\n      },\n    };\n  }\n  if (!data.name || data.name.trim().length === 0) {\n    return {\n      ok: false,\n      error: {\n        type: \"VALIDATION_ERROR\",\n        field: \"name\",\n        message: \"Name cannot be empty\",\n        userId: data.id,\n      },\n    };\n  }\n  return { ok: true, value: { id: data.id, email: data.email, name: data.name } };\n}\n\n// ============ Infrastructure Layer ============\n\nasync function insertUserToDatabase(\n  user: User,\n  db: Database\n): Promise<Result<User, ConstraintError>> {\n  try {\n    // Non-recoverable: connection lost mid-operation\n    const saved = await db.users.insert(user);\n    return { ok: true, value: saved };\n  } catch (error) {\n    // Distinguish error type\n    if (error instanceof DatabaseConnectionError) {\n      // Non-recoverable: PROPAGATE immediately (rethrow)\n      throw error;\n    }\n\n    if (error.code === \"UNIQUE_VIOLATION\" && error.constraint === \"email\") {\n      // Recoverable: Return as Result\n      return {\n        ok: false,\n        error: {\n          type: \"CONSTRAINT_VIOLATION\",\n          constraint: \"email_unique\",\n          message: `Email already exists: ${user.email}`,\n          userId: user.id,\n        },\n      };\n    }\n\n    // Unknown DB error: Treat as non-recoverable (safer)\n    throw new DatabaseConnectionError(\n      `Unexpected database error: ${error.message}`,\n      error\n    );\n  }\n}\n\n// ============ Application Layer (Processor) ============\n\ntype ImportReport = {\n  processed: number;\n  succeeded: number;\n  skipped: { id: string; reason: string; error: DomainError }[];\n};\n\nasync function processBatchUserImport(\n  users: any[],\n  db: Database\n): Promise<ImportReport> {\n  const report: ImportReport = {\n    processed: 0,\n    succeeded: 0,\n    skipped: [],\n  };\n\n  for (const userData of users) {\n    try {\n      report.processed++;\n\n      // Step 1: Validate (domain layer)\n      const validationResult = validateUser(userData);\n      if (!validationResult.ok) {\n        // Recoverable: Skip and report\n        report.skipped.push({\n          id: userData.id,\n          reason: \"validation_failed\",\n          error: validationResult.error,\n        });\n        continue; // Move to next user\n      }\n\n      // Step 2: Persist (infrastructure layer)\n      const insertResult = await insertUserToDatabase(validationResult.value, db);\n      if (!insertResult.ok) {\n        // Recoverable: Skip and report\n        report.skipped.push({\n          id: userData.id,\n          reason: \"constraint_violation\",\n          error: insertResult.error,\n        });\n        continue; // Move to next user\n      }\n\n      // Success path\n      report.succeeded++;\n    } catch (error) {\n      // Non-recoverable errors reach here\n      if (error instanceof DatabaseConnectionError) {\n        // FAIL FAST: Stop entire batch, alert caller\n        throw new Error(\n          `Batch import aborted at user ${userData.id}: ${error.message}`\n        );\n      }\n\n      // Unexpected error: Safer to fail fast than corrupt data\n      throw error;\n    }\n  }\n\n  return report;\n}\n\n// ============ Presentation Layer (Usage) ============\n\nasync function handleUserImportRequest(req: Request, db: Database) {\n  try {\n    const report = await processBatchUserImport(req.body.users, db);\n\n    if (report.skipped.length > 0) {\n      // Recoverable errors: Send detailed report\n      return {\n        status: 207, // Partial success\n        body: {\n          message: `Imported ${report.succeeded}/${report.processed} users`,\n          skipped: report.skipped.map((item) => ({\n            userId: item.id,\n            reason: item.error.type,\n            detail: item.error.message,\n          })),\n        },\n      };\n    }\n\n    return {\n      status: 200,\n      body: { message: `Successfully imported ${report.succeeded} users` },\n    };\n  } catch (error) {\n    if (error instanceof DatabaseConnectionError) {\n      // Non-recoverable: Alert ops, return 503\n      alertOps(`Critical: Database connection lost during import: ${error.message}`);\n      return {\n        status: 503,\n        body: { error: \"Database unavailable. Please retry later.\" },\n      };\n    }\n\n    // Other non-recoverable errors\n    alertOps(`Import processor crash: ${error.message}`);\n    return {\n      status: 500,\n      body: { error: \"Import failed due to unexpected error\" },\n    };\n  }\n}\n```\n\n## Key Distinctions:\n\n| Error Type | Handling | Mechanism | Example |\n|---|---|---|---|\n| **Validation** | Skip & report | Return `Result<T, ValidationError>` | Bad email format |\n| **Constraint** | Skip & report | Return `Result<T, ConstraintError>` | Duplicate email |\n| **Connection Loss** | Fail-fast | `throw DatabaseConnectionError` | Network down |\n\n**Why this works:**\n- \u2705 Compiler forces handling of domain errors (`Result` type)\n- \u2705 Connection errors bypass safe handling (exception), triggering alerts immediately\n- \u2705 Caller can't ignore validation/constraint failures (they're in the type)\n- \u2705 Batch continues for recoverable errors but stops on infrastructure errors\n- \u2705 Report provides actionable feedback for retry/investigation"
          }
        }
      ],
      "judgment": {
        "principle_better": "B",
        "quality_better": "B",
        "overall_better": "B",
        "option_a_rating": "good",
        "option_b_rating": "outstanding",
        "score": 100,
        "reasoning": "Solution A demonstrates solid understanding of Result types in the login example but undermines the principle in the UserImportProcessor by using try-catch blocks to handle domain errors (validation, constraints), violating the core tenet of avoiding exceptions for domain errors. Solution B consistently applies Result types for all domain errors across both examples, properly distinguishes recoverable errors (returned) from non-recoverable ones (thrown), and provides clear separation across layers with explicit error handling throughout\u2014achieving true mastery of the pattern rather than partial application."
      }
    },
    {
      "skill": "ps-explicit-boundaries-adapters",
      "severity": "WARN",
      "model": "claude-haiku-4.5",
      "skill_version": "1.0.0",
      "baseline_rate": 100,
      "skill_rate": 100,
      "baseline_rating": "regular",
      "skill_rating": "outstanding",
      "baseline_pass_count": "2/2",
      "skill_pass_count": "2/2",
      "improvement": 0,
      "judge_error": false,
      "results": [
        {
          "name": "discount_logic_isolation",
          "input": "We have a function `calculate_order_discount(order_id)` that needs to fetch the user's order history to determine the discount tier.\n\nCurrently, it imports `db_client` directly and queries the database inside the calculation logic. This makes it impossible to run simple unit tests on the discount rules without spinning up a test database.\n\nRewrite this feature so that we can verify the discount logic with instant, in-memory unit tests, while still being able to connect to the real database in production.",
          "expected": {
            "focus": "Does the solution introduce an interface/abstraction for the data fetching? Is the logic separated from the DB call?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "# Solution: Dependency Injection for Testability\n\nRefactor `calculate_order_discount()` to accept or...",
            "response_full": "# Solution: Dependency Injection for Testability\n\nRefactor `calculate_order_discount()` to accept order history as a parameter instead of querying the database internally. This decouples the discount logic from data access.\n\n## Before (Tightly Coupled)\n```python\nfrom db_client import db_client\n\ndef calculate_order_discount(order_id):\n    order_history = db_client.query(\"SELECT * FROM orders WHERE user_id = ?\", order_id)\n    if len(order_history) >= 10:\n        return 0.20\n    elif len(order_history) >= 5:\n        return 0.10\n    return 0.0\n```\n\n## After (Dependency Injected)\n```python\nfrom db_client import db_client\n\ndef calculate_order_discount(order_history):\n    \"\"\"Pure function - no database dependency.\"\"\"\n    if len(order_history) >= 10:\n        return 0.20\n    elif len(order_history) >= 5:\n        return 0.10\n    return 0.0\n\ndef apply_discount_to_order(order_id):\n    \"\"\"Production wrapper that fetches data and applies logic.\"\"\"\n    order_history = db_client.query(\"SELECT * FROM orders WHERE user_id = ?\", order_id)\n    return calculate_order_discount(order_history)\n```\n\n## Unit Tests (No Database Required)\n```python\ndef test_discount_tier_1():\n    assert calculate_order_discount([{}, {}, {}]) == 0.0\n\ndef test_discount_tier_2():\n    assert calculate_order_discount([{}] * 5) == 0.10\n\ndef test_discount_tier_3():\n    assert calculate_order_discount([{}] * 10) == 0.20\n```\n\n## Production Usage\nCall `apply_discount_to_order(order_id)` to get the real database + discount logic.\n\n**Key Benefits:**\n- `calculate_order_discount()` is now a pure function that runs instantly in tests\n- No test database setup needed\n- Production still uses real database via wrapper function\n- Discount rules are easy to verify and maintain"
          },
          "skill": {
            "pass": true,
            "response_preview": "# Refactored Order Discount with Ports & Adapters\n\n## Core Domain: Pure Business Logic\n```python\n# d...",
            "response_full": "# Refactored Order Discount with Ports & Adapters\n\n## Core Domain: Pure Business Logic\n```python\n# domain/discount.py\nfrom dataclasses import dataclass\nfrom typing import Protocol\n\n@dataclass\nclass OrderHistory:\n    total_spent: float\n    purchase_count: int\n\nclass OrderRepository(Protocol):\n    \"\"\"Port: What discount calculation needs from storage\"\"\"\n    def get_order_history(self, user_id: str) -> OrderHistory:\n        \"\"\"Return domain object, not database model\"\"\"\n        ...\n\ndef calculate_order_discount(user_id: str, repository: OrderRepository) -> float:\n    \"\"\"Core: Zero external dependencies\"\"\"\n    history = repository.get_order_history(user_id)\n    \n    if history.purchase_count >= 10:\n        return 0.20  # 20% discount\n    elif history.total_spent > 1000:\n        return 0.15  # 15% discount\n    elif history.purchase_count >= 5:\n        return 0.10  # 10% discount\n    return 0.0\n```\n\n## Production Adapter: Real Database\n```python\n# adapters/postgres_order_repository.py\nfrom domain.discount import OrderRepository, OrderHistory\n\nclass PostgresOrderRepository(OrderRepository):\n    \"\"\"Adapter: Translates between database and domain\"\"\"\n    def __init__(self, db_client):\n        self.db_client = db_client\n    \n    def get_order_history(self, user_id: str) -> OrderHistory:\n        # Database access stays here\n        result = self.db_client.query(\n            \"SELECT COUNT(*) as count, SUM(amount) as total FROM orders WHERE user_id = %s\",\n            (user_id,)\n        )\n        return OrderHistory(\n            total_spent=result['total'] or 0,\n            purchase_count=result['count']\n        )\n```\n\n## Unit Tests: No Database Needed\n```python\n# tests/test_discount.py\nfrom domain.discount import calculate_order_discount, OrderHistory\n\ndef test_vip_discount_threshold():\n    \"\"\"Instant unit test - no infrastructure\"\"\"\n    class FakeRepository:\n        def get_order_history(self, user_id):\n            return OrderHistory(total_spent=5000, purchase_count=15)\n    \n    discount = calculate_order_discount(\"user123\", FakeRepository())\n    assert discount == 0.20\n\ndef test_loyal_customer_discount():\n    \"\"\"Pure logic verification\"\"\"\n    class FakeRepository:\n        def get_order_history(self, user_id):\n            return OrderHistory(total_spent=500, purchase_count=6)\n    \n    discount = calculate_order_discount(\"user456\", FakeRepository())\n    assert discount == 0.10\n\ndef test_no_discount_for_new_customer():\n    \"\"\"Boundary condition\"\"\"\n    class FakeRepository:\n        def get_order_history(self, user_id):\n            return OrderHistory(total_spent=50, purchase_count=1)\n    \n    discount = calculate_order_discount(\"user789\", FakeRepository())\n    assert discount == 0.0\n```\n\n## Application Startup: Wire Dependencies\n```python\n# main.py\nfrom adapters.postgres_order_repository import PostgresOrderRepository\nfrom domain.discount import calculate_order_discount\n\n# Composition root - only place where concrete adapter is instantiated\ndb_client = connect_to_database()\nrepository = PostgresOrderRepository(db_client)\n\n# Usage\nuser_discount = calculate_order_discount(\"user123\", repository)\n```\n\n## Key Improvements\n\n\u2705 **Testability**: Run 100 discount rule tests in milliseconds, zero database setup  \n\u2705 **Flexibility**: Swap PostgreSQL for MongoDB by creating `MongoOrderRepository` adapter  \n\u2705 **Maintainability**: Discount rules isolated from database changes  \n\u2705 **Dependency Direction**: Domain depends on `OrderRepository` interface, adapter depends on both interface + database library"
          }
        },
        {
          "name": "infrastructure_pollution_analysis",
          "input": "Review this code snippet:\n\n```javascript\nclass InvoiceService {\n  process(invoice) {\n    if (invoice.amount > 10000) {\n      const sns = new AWS.SNS(); // Direct AWS usage\n      sns.publish({ topic: 'high-value-tx', message: JSON.stringify(invoice) });\n    }\n    // ... rest of logic\n  }\n}\n```\n\nWhat are the long-term maintainability problems with instantiation like this inside business logic?",
          "expected": {
            "focus": "Does the answer mention vendor lock-in, testing difficulties, or mixing concerns?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "## Long-Term Maintainability Problems\n\nThis instantiation pattern creates several critical issues:\n\n...",
            "response_full": "## Long-Term Maintainability Problems\n\nThis instantiation pattern creates several critical issues:\n\n1. **Tight Coupling & Testability Nightmare**: InvoiceService is locked into AWS.SNS. Unit tests can't run without hitting AWS infrastructure or complex global mocks. Every test becomes an integration test, making tests slow and brittle.\n\n2. **Resource Waste**: A new SNS client is instantiated on every high-value transaction. Clients should be reused; this creates connection overhead and wastes memory.\n\n3. **Hidden Dependencies**: The SNS dependency isn't declared in the constructor or method signature. New developers don't see what InvoiceService actually depends on until reading the implementation details.\n\n4. **Violation of Single Responsibility**: InvoiceService now handles both invoice processing AND AWS notification logic. Changing notification behavior requires modifying this class.\n\n5. **Impossible to Swap Implementations**: Want to use SQS, Kafka, or a webhook instead? You must modify InvoiceService directly. No way to support multiple notification strategies without branching logic.\n\n6. **Dependency Inversion Violation**: The class depends on a concrete AWS implementation rather than an abstraction, making it rigid and hard to extend.\n\n**Fix**: Inject the messaging service as a dependency (constructor or method parameter), depend on an abstraction (interface/contract), and let the caller decide the implementation. This decouples business logic from infrastructure concerns, enables easy testing with mocks, and allows runtime swapping of notification mechanisms."
          },
          "skill": {
            "pass": true,
            "response_preview": "# Long-term Maintainability Problems\n\nThis code violates the ports & adapters principle by tightly c...",
            "response_full": "# Long-term Maintainability Problems\n\nThis code violates the ports & adapters principle by tightly coupling business logic to AWS infrastructure. The long-term problems are:\n\n1. **Testability collapse**: `InvoiceService.process()` cannot be unit tested without AWS credentials, network access, and real SNS topics. Every test becomes an integration test requiring infrastructure setup.\n\n2. **Infrastructure lock-in**: Switching from SNS to SQS, email, Kafka, or any other notification system requires modifying `InvoiceService` itself. The business logic becomes a prisoner of the chosen infrastructure.\n\n3. **Configuration hell**: AWS credentials and topic names are hardcoded or rely on implicit environment configuration scattered across the codebase. Environment-specific setup becomes fragile.\n\n4. **Violation of dependency rule**: Business logic should never import external frameworks. Changes to AWS SDK APIs, authentication mechanisms, or library versions cascade directly into domain code.\n\n5. **Hidden side effects**: The `process()` method's contract is unclear\u2014callers don't know it triggers network I/O. Adding notification logic later (email, Slack, webhooks) requires modifying this same service repeatedly.\n\n**Solution**: Extract a `NotificationPort` interface (e.g., `notify(subject, message)`), implement it with an `AwsSnsAdapter`, and inject it into `InvoiceService`. Now the service is testable with mocks, swappable between notification systems, and isolated from AWS SDK changes."
          }
        }
      ],
      "judgment": {
        "principle_better": "B",
        "quality_better": "B",
        "overall_better": "B",
        "option_a_rating": "regular",
        "option_b_rating": "outstanding",
        "score": 100,
        "reasoning": "Solution A demonstrates dependency injection and pure functions but fails to implement the ports & adapters pattern\u2014the `db_client` import remains in production code in the wrapper function, and there is no port interface or adapter layer. Solution B fully implements the pattern with a proper `OrderRepository` port interface, `PostgresOrderRepository` adapter handling database translation, and pure domain logic with zero framework imports, enabling true infrastructure independence and instant zero-setup unit testing."
      }
    },
    {
      "skill": "ps-explicit-ownership-lifecycle",
      "severity": "WARN",
      "model": "claude-haiku-4.5",
      "skill_version": "1.0.0",
      "baseline_rate": 100,
      "skill_rate": 100,
      "baseline_rating": "good",
      "skill_rating": "outstanding",
      "baseline_pass_count": "2/2",
      "skill_pass_count": "2/2",
      "improvement": 0,
      "judge_error": false,
      "results": [
        {
          "name": "resource_cleanup_guarantee",
          "input": "A function `process_large_file(path)` opens a file handle to read data. If a parsing error occurs halfway through, the function throws an exception. We've noticed that this leaves the file handle open, eventually causing an \"Too many open files\" error on the server.\n\nFix the code structure so that the file is *always* closed, whether the function succeeds, fails, or crashes.",
          "expected": {
            "focus": "Does the solution use a try/finally block, a 'using' statement, or a RAII pattern to guarantee cleanup?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "Use a try-finally block or context manager to ensure the file is always closed:\n\n**Python solution (...",
            "response_full": "Use a try-finally block or context manager to ensure the file is always closed:\n\n**Python solution (recommended):**\n```python\ndef process_large_file(path):\n    with open(path) as f:\n        # parsing code here\n        # exceptions automatically trigger cleanup\n```\n\n**Python solution (explicit try-finally):**\n```python\ndef process_large_file(path):\n    f = open(path)\n    try:\n        # parsing code here\n    finally:\n        f.close()\n```\n\n**Other languages:**\n- **JavaScript**: Use try-finally with `file.close()` in finally block\n- **Java**: Use try-with-resources: `try (FileReader f = new FileReader(path)) { ... }`\n- **C#**: Use `using` statement: `using (var f = File.Open(path)) { ... }`\n\nThe `with` statement (or equivalent) in your language guarantees the file handle is released even if an exception occurs inside the block."
          },
          "skill": {
            "pass": true,
            "response_preview": "Wrap the file operation in a try-finally block to ensure deterministic cleanup regardless of success...",
            "response_full": "Wrap the file operation in a try-finally block to ensure deterministic cleanup regardless of success or exception:\n\n```python\ndef process_large_file(path):\n    file = open(path)\n    try:\n        data = file.read()\n        result = parse_data(data)  # Parsing error throws here\n        return result\n    finally:\n        file.close()  # Always executes, even on exception\n```\n\n**Why this fixes the issue:**\n\n- **Single Owner**: The function owns the file resource\n- **Deterministic Cleanup**: The finally block executes unconditionally after try block, catching success, parsing errors, and crashes\n- **No Leaks**: File is always closed, preventing \"Too many open files\" errors\n\n**Alternative modern approaches:**\n\nContext manager (Python):\n```python\ndef process_large_file(path):\n    with open(path) as file:\n        data = file.read()\n        return parse_data(data)  # Automatic cleanup on exit\n```\n\nTry-catch-finally (Java/C#):\n```java\nFileReader file = new FileReader(path);\ntry {\n    String data = readFile(file);\n    return parseData(data);\n} finally {\n    file.close();  // Guaranteed cleanup\n}\n```\n\n**Key principle applied:**\nResource acquisition (open) paired with guaranteed release (close/finally block) ensures the file handle's lifetime is explicit and deterministic, preventing leaks even in error paths."
          }
        },
        {
          "name": "event_subscription_leak",
          "input": "In our Single Page Application, when a user navigates to the 'Dashboard', the component subscribes to a global WebSocket stream. When they navigate away, the connection seems to stay open, and if they come back, a second connection is opened. This leads to duplicate data and memory leaks.\n\nimplment a pattern for the Dashboard component that ensures the subscription is strictly tied to the component's lifetime.",
          "expected": {
            "focus": "Does the solution explicitly pair the subscription creation with its destruction (e.g., onMount/onUnmount)?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "# WebSocket Subscription Management Pattern\n\nImplement a **lifetime-scoped subscription** using your...",
            "response_full": "# WebSocket Subscription Management Pattern\n\nImplement a **lifetime-scoped subscription** using your framework's lifecycle management:\n\n**For React:**\n```javascript\nuseEffect(() => {\n  const subscription = webSocketStream.subscribe(data => {\n    setDashboardData(data);\n  });\n  \n  return () => subscription.unsubscribe(); // Cleanup on unmount\n}, []);\n```\n\n**For Angular:**\n```typescript\nngOnInit() {\n  this.subscription = this.webSocketStream.subscribe(data => {\n    this.dashboardData = data;\n  });\n}\n\nngOnDestroy() {\n  this.subscription.unsubscribe(); // Cleanup on destroy\n}\n```\n\n**For Vue 3:**\n```javascript\nonMounted(() => {\n  subscription = webSocketStream.subscribe(data => {\n    dashboardData.value = data;\n  });\n});\n\nonBeforeUnmount(() => {\n  subscription.unsubscribe(); // Cleanup on unmount\n});\n```\n\n**Key principles:**\n1. Subscribe in mount/init hook \u2192 creates connection when component enters DOM\n2. Unsubscribe in cleanup/destroy hook \u2192 closes connection when component leaves DOM\n3. Store subscription reference \u2192 allows controlled cleanup\n4. Empty dependency array (React) \u2192 ensures single subscription per component instance\n\nThis ensures each Dashboard instance creates exactly one connection, properly closed when the component unmounts, preventing duplicate subscriptions and memory leaks."
          },
          "skill": {
            "pass": true,
            "response_preview": "The current working directory appears to be empty. Based on the **Explicit Ownership Lifecycle** ski...",
            "response_full": "The current working directory appears to be empty. Based on the **Explicit Ownership Lifecycle** skill provided, here is the direct solution for fixing the Dashboard WebSocket subscription leak:\n\n## Solution: Implement Ownership-Based Subscription Management\n\n**The Problem:** The Dashboard component subscribes to a global WebSocket but doesn't unsubscribe on unmount, violating the Single Owner Rule and creating resource leaks.\n\n**The Fix:** Use React's `useEffect` cleanup pattern (or equivalent in your framework) to tie subscription lifetime to component lifecycle:\n\n```javascript\n// Dashboard Component - JavaScript/TypeScript Example\nfunction Dashboard() {\n  useEffect(() => {\n    // ACQUIRE: Subscribe when component mounts\n    const unsubscribe = webSocketStream.subscribe(handleData);\n\n    // RELEASE: Cleanup in return function (cleanup runs on unmount)\n    return () => {\n      unsubscribe();  // Explicit cleanup - ownership ends here\n    };\n  }, []);  // Empty dependency array = once per component lifetime\n\n  return <div>Dashboard Content</div>;\n}\n```\n\n**Key Principles Applied:**\n\n1. **Single Owner**: The component itself owns the subscription (created in `useEffect`, destroyed in return function)\n2. **Deterministic Cleanup**: Not relying on garbage collection\u2014explicit `unsubscribe()` call\n3. **Tight Scope**: Subscription lifetime exactly matches component mount/unmount cycle\n4. **Error Path Safety**: Cleanup happens regardless of how component unmounts\n\n**If using a custom hook for reusability:**\n\n```javascript\nfunction useWebSocketSubscription(stream, handler) {\n  useEffect(() => {\n    const unsubscribe = stream.subscribe(handler);\n    return () => unsubscribe();  // Owner cleanup pattern\n  }, [stream, handler]);\n}\n\n// In Dashboard:\nfunction Dashboard() {\n  useWebSocketSubscription(webSocketStream, handleData);\n  return <div>Dashboard Content</div>;\n}\n```\n\n**This enforces the Enforcement Checklist:**\n- \u2705 Clear owner: Dashboard component\n- \u2705 Deterministic cleanup: happens on unmount\n- \u2705 Error paths protected: cleanup in finally equivalent\n- \u2705 No resource leak: subscription ends with component\n- \u2705 Ownership explicit: dependency array declares resubscribe conditions"
          }
        }
      ],
      "judgment": {
        "principle_better": "B",
        "quality_better": "A",
        "overall_better": "B",
        "option_a_rating": "good",
        "option_b_rating": "outstanding",
        "score": 100,
        "reasoning": "Solution A demonstrates correct patterns (context managers, lifecycle hooks) but treats them as implementation techniques without explicitly naming or connecting to the principle itself. Solution B directly names the principle (Single Owner Rule, Deterministic Cleanup, No Leaks), explains WHY each pattern works, and explicitly references the Enforcement Checklist\u2014making the principle crystal clear. While A has broader language/framework coverage, B excels at principle articulation and understanding, which is what the evaluation asks: does the solution demonstrate mastery of the principle."
      }
    },
    {
      "skill": "ps-explicit-state-invariants",
      "severity": "BLOCK",
      "model": "claude-haiku-4.5",
      "skill_version": "1.0.0",
      "baseline_rate": 100,
      "skill_rate": 100,
      "baseline_rating": "good",
      "skill_rating": "outstanding",
      "baseline_pass_count": "2/2",
      "skill_pass_count": "2/2",
      "improvement": 0,
      "judge_error": false,
      "results": [
        {
          "name": "ui_state_flags_bug",
          "input": "Our UI component tracks data loading with three separate flags: `isLoading`, `isSuccess`, and `isError`. \n\nWe keep receiving bug reports where the \"Loading...\" spinner is visible *on top of* the Error message (isLoading=true, isError=true). \n\nRedesign the state structure to make this UI bug impossible to represent in data.",
          "expected": {
            "focus": "Does the solution combine the flags into a single status field or union type?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "# Redesigned State Structure\n\nReplace three separate boolean flags with a **discriminated union** th...",
            "response_full": "# Redesigned State Structure\n\nReplace three separate boolean flags with a **discriminated union** that enforces only one state at a time:\n\n```typescript\ntype LoadingState = \n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: Error };\n```\n\nOr as a simple enum if you don't need to attach data:\n\n```typescript\nenum UIState {\n  IDLE = 'idle',\n  LOADING = 'loading',\n  SUCCESS = 'success',\n  ERROR = 'error'\n}\n```\n\n## Why This Works\n\n- **Mutually exclusive**: Only one state can exist at a time; impossible to have `loading=true` and `error=true` simultaneously\n- **Type-safe**: TypeScript prevents invalid state combinations at compile time\n- **Self-documenting**: The state structure clearly shows all valid transitions\n- **Simpler logic**: Conditionals use single value instead of checking multiple flags:\n\n```typescript\n// Before (buggy)\n{isLoading && <Spinner />}\n{isError && <ErrorMessage />}\n\n// After (correct)\n{state.status === 'loading' && <Spinner />}\n{state.status === 'error' && <ErrorMessage error={state.error} />}\n```\n\nThis pattern prevents the visual bug entirely\u2014the compiler won't let you write invalid state transitions."
          },
          "skill": {
            "pass": true,
            "response_preview": "## Redesigned State Structure\n\nReplace the three independent boolean flags with a **discriminated un...",
            "response_full": "## Redesigned State Structure\n\nReplace the three independent boolean flags with a **discriminated union** that represents mutually exclusive states:\n\n```typescript\ntype DataLoadingState = \n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: unknown }\n  | { status: 'error'; error: string }\n\n// Invariant: Exactly ONE status at a time\n// Cannot be both 'loading' AND 'error' simultaneously\n// Data only exists when status is 'success'\n// Error message only exists when status is 'error'\n```\n\n**Usage in component:**\n\n```typescript\nfunction MyComponent({ state }: { state: DataLoadingState }) {\n  switch (state.status) {\n    case 'idle':\n      return <button onClick={load}>Load Data</button>\n    case 'loading':\n      return <div>Loading...</div>\n    case 'success':\n      return <div>{state.data}</div>\n    case 'error':\n      return <div className=\"error\">{state.error}</div>\n  }\n}\n```\n\n**State transitions (explicit functions):**\n\n```typescript\nconst transitions = {\n  startLoading: (): DataLoadingState => ({ status: 'loading' }),\n  succeed: (data: unknown): DataLoadingState => ({ status: 'success', data }),\n  fail: (error: string): DataLoadingState => ({ status: 'error', error }),\n  reset: (): DataLoadingState => ({ status: 'idle' }),\n}\n```\n\n**Why this eliminates the bug:**\n\nThe union type makes `{ status: 'loading', error: '...' }` a **compile-time error**. The impossible state cannot exist in the type system. The spinner and error message can never render simultaneously because TypeScript enforces that only one state property can be true at any moment."
          }
        },
        {
          "name": "wizard_step_dependency",
          "input": "We are building a checkout wizard. Step 2 (Shipping) requires the address from Step 1 (Contact). Step 3 (Payment) requires the shipping method from Step 2.\n\nCurrently, developers often try to render the Payment screen with an empty address, causing a crash. \n\nDefine a data structure for this wizard that enforces these dependencies. It should be a compile-time (or runtime structure) error to try to access Payment info if Shipping info doesn't exist.",
          "expected": {
            "focus": "Does the data structure nest the steps or use a state machine logic to prevent out-of-order execution?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "# Type-Safe Checkout Wizard with Enforced Dependencies\n\nHere's a TypeScript solution using **discrim...",
            "response_full": "# Type-Safe Checkout Wizard with Enforced Dependencies\n\nHere's a TypeScript solution using **discriminated unions** that makes it a compile-time error to access Payment data without Shipping data:\n\n```typescript\n// Step 1: Contact Information\ninterface ContactInfo {\n  name: string;\n  email: string;\n  address: string;\n}\n\n// Step 2: Shipping Information (requires ContactInfo)\ninterface ShippingInfo {\n  method: 'standard' | 'express' | 'overnight';\n  cost: number;\n  estimatedDays: number;\n}\n\n// Step 3: Payment Information (requires ShippingInfo)\ninterface PaymentInfo {\n  cardNumber: string;\n  cvv: string;\n  total: number; // Includes shipping cost\n}\n\n// Discriminated union - only one state at a time\ntype CheckoutState =\n  | { step: 'contact' }\n  | { step: 'shipping'; contact: ContactInfo }\n  | { step: 'payment'; contact: ContactInfo; shipping: ShippingInfo }\n  | { step: 'complete'; contact: ContactInfo; shipping: ShippingInfo; payment: PaymentInfo };\n\n// Type-safe wizard class\nclass CheckoutWizard {\n  private state: CheckoutState = { step: 'contact' };\n\n  // Only accessible on contact step\n  setContact(contact: ContactInfo): void {\n    if (this.state.step !== 'contact') throw new Error('Cannot set contact after step 1');\n    this.state = { step: 'shipping', contact };\n  }\n\n  // Requires contact to exist (type-safe)\n  getContact(): ContactInfo | undefined {\n    if (this.state.step === 'contact') return undefined;\n    return this.state.contact;\n  }\n\n  // Only accessible on shipping step\n  setShipping(shipping: ShippingInfo): void {\n    if (this.state.step !== 'shipping') throw new Error('Shipping step requires contact info');\n    this.state = { step: 'payment', contact: this.state.contact, shipping };\n  }\n\n  // Compile-time error if you try to access without shipping\n  getShipping(): ShippingInfo | undefined {\n    if (this.state.step === 'contact' || this.state.step === 'shipping') return undefined;\n    return this.state.shipping;\n  }\n\n  // Compile-time error: can't access without shipping\n  setPayment(payment: PaymentInfo): void {\n    if (this.state.step !== 'payment') {\n      throw new Error('Payment requires shipping info');\n    }\n    this.state = { step: 'complete', ...this.state, payment };\n  }\n\n  // Only returns if payment step reached\n  getPayment(): PaymentInfo | undefined {\n    if (this.state.step !== 'complete') return undefined;\n    return this.state.payment;\n  }\n\n  getCurrentStep(): CheckoutState['step'] {\n    return this.state.step;\n  }\n}\n\n// Usage - TypeScript enforces the flow:\nconst wizard = new CheckoutWizard();\nconst contact = { name: 'John', email: 'john@example.com', address: '123 Main St' };\nwizard.setContact(contact);\n\n// \u274c TypeScript ERROR - wizard.getPayment() returns undefined\n// Cannot read property 'cardNumber' of undefined\n// const payment = wizard.getPayment()?.cardNumber;\n\n// \u2705 Correct flow\nconst shipping = { method: 'express' as const, cost: 15, estimatedDays: 2 };\nwizard.setShipping(shipping);\n\nconst payment = { cardNumber: '4111...', cvv: '123', total: 115 };\nwizard.setPayment(payment);\n\n// \u2705 Now accessible\nconsole.log(wizard.getPayment()?.cardNumber);\n```\n\n**Key Benefits:**\n\n1. **Compile-time safety**: TypeScript prevents accessing `payment` if `shipping` hasn't been set\n2. **Impossible invalid states**: The union type makes it impossible to have Payment without Shipping without Contact\n3. **Self-documenting**: The type definition clearly shows dependencies\n4. **No runtime crash**: Invalid transitions throw explicit errors before rendering\n\nThis ensures developers can't accidentally render the Payment screen without completing prior steps\u2014the type system catches the error before code runs."
          },
          "skill": {
            "pass": true,
            "response_preview": "# Checkout Wizard: Explicit State Structure\n\nDefine the wizard state using a **discriminated union**...",
            "response_full": "# Checkout Wizard: Explicit State Structure\n\nDefine the wizard state using a **discriminated union** that makes invalid states unrepresentable:\n\n```typescript\n// Invariant: Each step's data includes ALL required dependencies\n\ntype CheckoutWizard = \n  | { status: 'step1'; contactData?: undefined }\n  | { status: 'step2'; contactData: ContactInfo; shippingData?: undefined }\n  | { status: 'step3'; contactData: ContactInfo; shippingData: ShippingInfo; paymentData?: undefined }\n  | { status: 'complete'; contactData: ContactInfo; shippingData: ShippingInfo; paymentData: PaymentInfo }\n\ninterface ContactInfo {\n  email: string;\n  address: string; // Step 2 REQUIRES this\n}\n\ninterface ShippingInfo {\n  method: 'standard' | 'express'; // Step 3 REQUIRES this\n  cost: number;\n}\n\ninterface PaymentInfo {\n  cardToken: string;\n  amount: number;\n}\n\n// Transitions enforce invariants\nfunction advanceToStep2(state: CheckoutWizard, contact: ContactInfo): CheckoutWizard {\n  if (state.status !== 'step1') throw new Error('Invalid transition');\n  return { status: 'step2', contactData: contact };\n}\n\nfunction advanceToStep3(state: CheckoutWizard, shipping: ShippingInfo): CheckoutWizard {\n  if (state.status !== 'step2') throw new Error('Invalid transition');\n  // contactData is guaranteed to exist here by the type system\n  return { status: 'step3', contactData: state.contactData, shippingData: shipping };\n}\n\nfunction renderPayment(state: CheckoutWizard): void {\n  if (state.status !== 'step3') throw new Error('Payment requires completed shipping');\n  // Compiler knows both contactData AND shippingData exist - no crash possible\n  console.log(`Address: ${state.contactData.address}, Method: ${state.shippingData.method}`);\n}\n```\n\n**Why this works:**\n\n- \u2705 **Type-safe**: Accessing `state.shippingData` on step2 is a compile error\n- \u2705 **Invalid states impossible**: Can't represent \"Payment step without Shipping data\"\n- \u2705 **Dependencies encoded**: Step 3 state type literally includes all prior data\n- \u2705 **No defensive checks**: No `if (shippingData !== null)` guards needed\u2014types guarantee it exists in step3\n\nThe crash is **impossible by design**, not prevented by runtime guards."
          }
        }
      ],
      "judgment": {
        "principle_better": "B",
        "quality_better": "B",
        "overall_better": "B",
        "option_a_rating": "good",
        "option_b_rating": "outstanding",
        "score": 100,
        "reasoning": "Solution B explicitly states invariants in comments and fully encodes them in the type system by including all required prior data in each state variant (e.g., step3 includes contactData AND shippingData), making invalid states truly unrepresentable. Solution A correctly uses discriminated unions but weakens type-safety by having getters return undefined, requiring runtime checks and type narrowing that Solution B's approach eliminates entirely."
      }
    },
    {
      "skill": "ps-functional-core-imperative-shell",
      "severity": "BLOCK",
      "model": "claude-haiku-4.5",
      "skill_version": "1.0.0",
      "baseline_rate": 100,
      "skill_rate": 100,
      "baseline_rating": "good",
      "skill_rating": "outstanding",
      "baseline_pass_count": "2/2",
      "skill_pass_count": "2/2",
      "improvement": 0,
      "judge_error": false,
      "results": [
        {
          "name": "user_registration_refactor",
          "input": "Our `register_user` function is proving brittle. It mixes data validation, password hashing, database insertion, and sending a welcome email all in a single procedural flow.\n\nWe want to be able to verify the *decisions* the system makes (e.g., \"Given this input, we *should* save X and email Y\") without actually performing the side effects during the test.\n\nredesign this flow to make the business decisions purely testable.",
          "expected": {
            "focus": "Does the solution separate the decision-making (pure) from the execution (imperative)?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "# Redesign: Decision/Effect Separation\n\nRestructure `register_user` into a **two-phase pattern**:\n\n1...",
            "response_full": "# Redesign: Decision/Effect Separation\n\nRestructure `register_user` into a **two-phase pattern**:\n\n1. **Pure Decision Phase** \u2014 returns a command object describing what *should* happen\n2. **Effect Execution Phase** \u2014 executes the command (database, email, etc.)\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Union\n\n# Domain decisions (pure, testable)\n@dataclass\nclass RegisterCommand:\n    user_id: str\n    username: str\n    email: str\n    password_hash: str\n\n@dataclass\nclass ValidationError:\n    field: str\n    message: str\n\ndef decide_registration(username: str, email: str, password: str) -> Union[RegisterCommand, ValidationError]:\n    \"\"\"Pure function: business logic only, no side effects\"\"\"\n    \n    # Validation decisions\n    if len(username) < 3:\n        return ValidationError(\"username\", \"Too short\")\n    if \"@\" not in email:\n        return ValidationError(\"email\", \"Invalid\")\n    if len(password) < 8:\n        return ValidationError(\"password\", \"Too weak\")\n    \n    # Hashing is deterministic here (or inject a pure hash function)\n    password_hash = hash_password(password)\n    user_id = generate_id()\n    \n    # Return decision: \"we should execute this command\"\n    return RegisterCommand(\n        user_id=user_id,\n        username=username,\n        email=email,\n        password_hash=password_hash\n    )\n\n# Execution layer (testable by mocking)\ndef execute_registration(command: RegisterCommand, db, emailer):\n    \"\"\"Executes the decision\"\"\"\n    db.insert_user(command.user_id, command.username, command.email, command.password_hash)\n    emailer.send_welcome(command.email, command.username)\n    return command.user_id\n```\n\n**Testing the decisions (no side effects):**\n```python\ndef test_rejects_short_username():\n    result = decide_registration(\"ab\", \"test@example.com\", \"password123\")\n    assert isinstance(result, ValidationError)\n    assert result.field == \"username\"\n\ndef test_creates_command_for_valid_input():\n    result = decide_registration(\"alice\", \"alice@example.com\", \"securepass123\")\n    assert isinstance(result, RegisterCommand)\n    assert result.username == \"alice\"\n    # No database touched, no email sent\n```\n\n**Testing execution (with mocks):**\n```python\ndef test_saves_user_and_emails():\n    command = RegisterCommand(...)\n    mock_db = Mock()\n    mock_emailer = Mock()\n    \n    execute_registration(command, mock_db, mock_emailer)\n    \n    mock_db.insert_user.assert_called_once()\n    mock_emailer.send_welcome.assert_called_once()\n```\n\n**Key benefits:**\n- **Decision logic is pure** \u2014 fast, deterministic, no mocks needed\n- **Effects are isolated** \u2014 inject dependencies, test separately  \n- **Easy to verify correctness** \u2014 \"given this input, should we create this command?\"\n- **Side effects are testable with mocks** \u2014 verify *that* effects happen, not all the details"
          },
          "skill": {
            "pass": true,
            "response_preview": "Let me check what files exist in the current directory:\n\nThe directory is empty. Since you've provid...",
            "response_full": "Let me check what files exist in the current directory:\n\nThe directory is empty. Since you've provided the skill guidance and mentioned that \"our `register_user` function is proving brittle,\" I'll provide the complete refactored design for you to implement.\n\n## Refactored `register_user` - Functional Core, Imperative Shell\n\n**Pure Core (Business Logic):**\n```typescript\n// core.ts - Pure functions, zero side effects, fully testable\ninterface UserRegistrationDecision {\n  isValid: boolean;\n  errors: string[];\n  userToCreate?: {\n    email: string;\n    passwordHash: string;\n    username: string;\n  };\n  shouldSendWelcomeEmail: boolean;\n}\n\nexport function validateRegistration(\n  email: string,\n  password: string,\n  username: string\n): { isValid: boolean; errors: string[] } {\n  const errors: string[] = [];\n  if (!email.includes('@')) errors.push('Invalid email');\n  if (password.length < 8) errors.push('Password too short');\n  if (username.length < 3) errors.push('Username too short');\n  return { isValid: errors.length === 0, errors };\n}\n\nexport function makeRegistrationDecision(\n  email: string,\n  password: string,\n  username: string,\n  existingEmails: string[]\n): UserRegistrationDecision {\n  const validation = validateRegistration(email, password, username);\n  \n  if (!validation.isValid) {\n    return { isValid: false, errors: validation.errors, shouldSendWelcomeEmail: false };\n  }\n  \n  if (existingEmails.includes(email)) {\n    return { \n      isValid: false, \n      errors: ['Email already registered'],\n      shouldSendWelcomeEmail: false \n    };\n  }\n\n  return {\n    isValid: true,\n    errors: [],\n    userToCreate: { email, username, passwordHash: password }, // placeholder\n    shouldSendWelcomeEmail: true\n  };\n}\n```\n\n**Imperative Shell (Coordinates Effects):**\n```typescript\n// shell.ts - Orchestrates IO and side effects\nimport bcrypt from 'bcrypt';\nimport { database } from './db';\nimport { emailService } from './email';\nimport { makeRegistrationDecision } from './core';\n\nexport async function register_user(\n  email: string,\n  password: string,\n  username: string\n): Promise<{ success: boolean; message: string; userId?: string }> {\n  // Load data from external sources\n  const existingEmails = await database.getRegisteredEmails();\n  \n  // Call pure decision logic\n  const decision = makeRegistrationDecision(email, password, username, existingEmails);\n  \n  if (!decision.isValid) {\n    return { success: false, message: decision.errors.join(', ') };\n  }\n\n  // Hash password (side effect)\n  const passwordHash = await bcrypt.hash(password, 10);\n  \n  // Save to database\n  const userId = await database.createUser({\n    email,\n    username,\n    passwordHash\n  });\n\n  // Send welcome email if needed\n  if (decision.shouldSendWelcomeEmail) {\n    await emailService.sendWelcomeEmail(email, username);\n  }\n\n  return { success: true, message: 'User registered', userId };\n}\n```\n\n**Pure Tests (No Mocks, No Database):**\n```typescript\ndescribe('Core - makeRegistrationDecision', () => {\n  it('rejects invalid email', () => {\n    const decision = makeRegistrationDecision('invalid', 'password123', 'user', []);\n    expect(decision.isValid).toBe(false);\n    expect(decision.errors).toContain('Invalid email');\n  });\n\n  it('rejects duplicate email', () => {\n    const decision = makeRegistrationDecision('test@test.com', 'password123', 'user', ['test@test.com']);\n    expect(decision.isValid).toBe(false);\n    expect(decision.errors).toContain('Email already registered');\n  });\n\n  it('accepts valid registration and decides to email', () => {\n    const decision = makeRegistrationDecision('new@test.com', 'password123', 'john', []);\n    expect(decision.isValid).toBe(true);\n    expect(decision.shouldSendWelcomeEmail).toBe(true);\n  });\n});\n```\n\n**Key Benefits:**\n- **Core logic tested without database/email**: `makeRegistrationDecision` is deterministic and pure\n- **Clear separation**: Business decisions isolated from effects\n- **Reusable**: Core logic can be called from CLI, API, or batch jobs\n- **Mockable shell only**: If testing the full flow, mock only `database` and `emailService`, not the decisions"
          }
        },
        {
          "name": "side_effect_audit",
          "input": "Analyze this function:\n\n```javascript\nfunction checkAccess(user) {\n  if (user.isBanned) {\n    auditLogger.log(`Banned access attempt: ${user.id}`);\n    return false;\n  }\n  return true;\n}\n```\n\nIs this function easy to test in parallel? Why or why not?",
          "expected": {
            "focus": "Does the answer identify the external logger call as a side effect that complicates testing?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "No, this function is **not easy to test in parallel**.\n\n**Why:**\n\n1. **Global dependency**: The func...",
            "response_full": "No, this function is **not easy to test in parallel**.\n\n**Why:**\n\n1. **Global dependency**: The function relies on `auditLogger`, which is a global/external singleton. When tests run in parallel, they all share the same logger instance.\n\n2. **Shared state interference**: Parallel tests would pollute each other's logs. One test's `Banned access attempt` log entry could be read/verified by another test, causing non-deterministic test results and false failures.\n\n3. **Unpredictable ordering**: The order of log entries becomes indeterminate when tests run concurrently, making it impossible to reliably assert what was logged.\n\n4. **Difficult isolation**: Without mocking/injecting the logger, there's no clean way to isolate the logging side effect per test.\n\n**To make it testable in parallel**, inject the logger as a dependency parameter instead of using a global, allowing each test to provide a mock or spy logger."
          },
          "skill": {
            "pass": true,
            "response_preview": "No, this function is **not easy to test in parallel** because it has a side effect (the `auditLogger...",
            "response_full": "No, this function is **not easy to test in parallel** because it has a side effect (the `auditLogger.log()` call). Parallel tests executing this function would need to coordinate mocking the shared `auditLogger`, creating race conditions and test interdependencies. The function violates the Functional Core principle by mixing pure business logic (access check) with imperative effects (logging).\n\n**Better approach** (following the pattern):\n\n```javascript\n// PURE CORE - testable in parallel, no mocks needed\nfunction checkAccess(user) {\n  return !user.isBanned;\n}\n\n// IMPERATIVE SHELL - coordinates effects\nfunction processAccessRequest(user) {\n  const isAllowed = checkAccess(user);\n  \n  if (!isAllowed) {\n    auditLogger.log(`Banned access attempt: ${user.id}`);\n  }\n  \n  return isAllowed;\n}\n```\n\nNow `checkAccess()` is pure, deterministic, and thousands of tests can run it in parallel without interference. The shell handles the logging side effect."
          }
        }
      ],
      "judgment": {
        "principle_better": "B",
        "quality_better": "B",
        "overall_better": "B",
        "option_a_rating": "good",
        "option_b_rating": "outstanding",
        "score": 100,
        "reasoning": "Solution A has solid structure but critically places `hash_password()` and `generate_id()` in the pure core\u2014these are non-deterministic operations that violate purity. Solution B correctly recognizes that hashing must live in the imperative shell since bcrypt is non-deterministic; it keeps the core purely deterministic with proper validation logic. Solution B also provides better type safety (TypeScript interfaces) and demonstrates deeper understanding of what 'pure' actually means in practice."
      }
    },
    {
      "skill": "ps-illegal-states-unrepresentable",
      "severity": "SUGGEST",
      "model": "claude-haiku-4.5",
      "skill_version": "1.0.0",
      "baseline_rate": 100,
      "skill_rate": 100,
      "baseline_rating": "regular",
      "skill_rating": "good",
      "baseline_pass_count": "2/2",
      "skill_pass_count": "2/2",
      "improvement": 0,
      "judge_error": false,
      "results": [
        {
          "name": "email_verification_bug",
          "input": "We have a `User` record with an `email` field (string, optional) and an `email_verified` field (boolean).\n\nA bug recently caused the system to send \"Password Reset\" emails to `null` because `email_verified` was true but `email` was missing.\n\nChange the data model so that it is structurally impossible to have a \"verified\" status without an associated email address.",
          "expected": {
            "focus": "Does the solution link the verification status directly to the email field (e.g., a VerifiedEmail type)? "
          },
          "baseline": {
            "pass": true,
            "response_preview": "# Solution: Union the `email` and `email_verified` Fields\n\nReplace the two separate fields with a si...",
            "response_full": "# Solution: Union the `email` and `email_verified` Fields\n\nReplace the two separate fields with a single `verified_email` field:\n\n**Before:**\n```\nemail: string | null\nemail_verified: boolean\n```\n\n**After:**\n```\nverified_email: string | null\n```\n\nThis change makes it **structurally impossible** to have a verified email without an actual email address:\n- `verified_email: null` \u2192 no email provided\n- `verified_email: \"user@example.com\"` \u2192 email exists and is verified\n- There is no way to set `verified_email: true` without a string value\n\n**Implementation:**\n- If you need to track unverified emails, add a separate `unverified_email: string | null` field\n- Migrations: set `verified_email` to the current `email` value only where `email_verified` was true; all other records get `null`\n- Remove the old `email` and `email_verified` fields after migration\n\nThis prevents the bug at the type/schema level rather than relying on application logic."
          },
          "skill": {
            "pass": true,
            "response_preview": "The directory appears to be empty. Let me check the current working directory:\n\nThe temporary direct...",
            "response_full": "The directory appears to be empty. Let me check the current working directory:\n\nThe temporary directory is empty. Let me check if there are any files in the current directory:\n\nSince there are no files provided in the workspace, I'll provide the direct answer based on the skill guidance and the bug description:\n\n## Fix for Email Verification Bug\n\n**The Problem:**\nThe current design allows `email_verified = true` with `email = null`, causing the system to send emails to null addresses.\n\n**Current Structure (Bad):**\n```typescript\ntype User = {\n  email: string | null;\n  email_verified: boolean;\n}\n```\n\n**Fixed Structure (Good):**\n```typescript\ntype User = {\n  email: EmailStatus;\n}\n\ntype EmailStatus = \n  | { status: 'unverified'; email: string }\n  | { status: 'verified'; email: string }\n  | { status: 'no_email' };\n```\n\n**Alternative (More Idiomatic):**\n```typescript\ntype User = {\n  email: EmailAddress | null;\n}\n\ntype EmailAddress = {\n  address: string;\n  verified: true;\n} | {\n  address: string;\n  verified: false;\n}\n```\n\n**Key Changes:**\n1. Remove the boolean `email_verified` flag\n2. Use a discriminated union to represent mutually exclusive email states\n3. The type system now prevents `verified: true` without an email address\n4. The type system prevents null email with verified status\n\n**Why This Works:**\n- **Illegal state becomes impossible**: You cannot construct a verified email state without an actual email address\n- **Type-safe**: TypeScript/compiler catches any attempt to access email on a verified status\n- **Eliminates runtime checks**: No need for defensive validations like `if (email_verified && !email)`\n- **Self-documenting**: The type declaration shows all valid email states explicitly"
          }
        },
        {
          "name": "parser_vs_validator",
          "input": "We accept a 'phone number' string from an API. We validate it with regex, but then we continue to pass it around as a raw string.\n\nLater in the pipeline, another function has to re-validate it because it doesn't trust the string. This happens 5 times across the codebase.\n\nShow how to fix this redundancy. We want to validate once and then *know* for sure that the data is valid for the rest of the flow.",
          "expected": {
            "focus": "Does the solution parse the string into a specific 'PhoneNumber' type/object once, rather than validating ad-hoc?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "# Use a Branded Type (or Newtype Pattern)\n\nCreate a type wrapper that represents a *validated* phone...",
            "response_full": "# Use a Branded Type (or Newtype Pattern)\n\nCreate a type wrapper that represents a *validated* phone number. Only the validation function can construct it, and functions throughout your codebase accept this type instead of raw strings.\n\n## Solution\n\n```typescript\n// Create a branded type that only validation can create\ntype ValidatedPhoneNumber = string & { readonly __brand: \"ValidatedPhoneNumber\" };\n\nfunction validatePhoneNumber(input: string): ValidatedPhoneNumber | null {\n  const phoneRegex = /^\\+?1?\\d{9,15}$/;\n  if (!phoneRegex.test(input)) {\n    return null;\n  }\n  return input as ValidatedPhoneNumber;\n}\n\n// Now functions require the branded type - no re-validation needed\nfunction sendSMS(phone: ValidatedPhoneNumber): void {\n  // phone is guaranteed to be valid\n  console.log(`Sending SMS to ${phone}`);\n}\n\nfunction storeInDatabase(phone: ValidatedPhoneNumber): void {\n  // phone is guaranteed to be valid\n  console.log(`Storing ${phone} in database`);\n}\n\nfunction logPhoneEvent(phone: ValidatedPhoneNumber): void {\n  // phone is guaranteed to be valid\n  console.log(`Logged ${phone}`);\n}\n\n// Usage - validation happens once at the entry point\nconst userInput = \"+1234567890\";\nconst validPhone = validatePhoneNumber(userInput);\n\nif (validPhone) {\n  sendSMS(validPhone);        // \u2713 No re-validation\n  storeInDatabase(validPhone); // \u2713 No re-validation\n  logPhoneEvent(validPhone);   // \u2713 No re-validation\n} else {\n  console.error(\"Invalid phone number\");\n}\n```\n\n## Why This Works\n\n1. **Single validation point** - Phone is validated once when the branded type is created\n2. **Compiler enforcement** - Raw strings are rejected by type system; only `ValidatedPhoneNumber` is accepted\n3. **Zero runtime overhead** - The branded type is just a TypeScript type annotation; it's erased at runtime\n4. **Self-documenting** - Developers see `ValidatedPhoneNumber` and instantly know it's been validated\n\nThis pattern is called \"**making invalid states unrepresentable**\" \u2014 once the type exists, all downstream code is guaranteed to receive valid data without redundant re-validation."
          },
          "skill": {
            "pass": true,
            "response_preview": "# Solution: Parse Phone Number Once at the Boundary\n\n**The Problem:** Raw string passed around, vali...",
            "response_full": "# Solution: Parse Phone Number Once at the Boundary\n\n**The Problem:** Raw string passed around, validated 5 times defensively.\n\n**The Fix:** Create a `PhoneNumber` type. Validate at the API boundary. Internal code uses only the validated type.\n\n```typescript\n// \u274c BEFORE: Validate everywhere (fragile)\nfunction processPayment(phoneNumber: string) {\n  if (!validatePhone(phoneNumber)) throw Error(\"Invalid\");\n  // ...\n}\n\nfunction sendNotification(phoneNumber: string) {\n  if (!validatePhone(phoneNumber)) throw Error(\"Invalid\");\n  // ...\n}\n\nfunction updateContact(phoneNumber: string) {\n  if (!validatePhone(phoneNumber)) throw Error(\"Invalid\");\n  // ...\n}\n// Validation scattered across 5+ places\n```\n\n---\n\n```typescript\n// \u2705 AFTER: Validate once, use guaranteed-valid type everywhere\n\n// Domain type - only valid phone numbers can exist\ntype PhoneNumber = string & { readonly __brand: \"PhoneNumber\" };\n\n// Parse at boundary (single point of validation)\nfunction parsePhoneNumber(input: string): PhoneNumber | Error {\n  const phoneRegex = /^\\+?[1-9]\\d{1,14}$/;\n  if (!phoneRegex.test(input)) {\n    return Error(`Invalid phone number: ${input}`);\n  }\n  return input as PhoneNumber;\n}\n\n// Internal functions accept ONLY validated PhoneNumber type\nfunction processPayment(phoneNumber: PhoneNumber) {\n  // No validation needed - type guarantees it's valid\n  chargeCard(phoneNumber);\n}\n\nfunction sendNotification(phoneNumber: PhoneNumber) {\n  sms.send(phoneNumber);\n}\n\nfunction updateContact(phoneNumber: PhoneNumber) {\n  db.update(phoneNumber);\n}\n\n// At API boundary: parse once, convert to domain type\napp.post(\"/charge\", (req) => {\n  const result = parsePhoneNumber(req.body.phone);\n  \n  if (result instanceof Error) {\n    return res.status(400).json({ error: result.message });\n  }\n  \n  // result is now PhoneNumber - type is guaranteed valid\n  processPayment(result);\n  sendNotification(result);\n  updateContact(result);\n  // No re-validation needed - compiler enforces it\n});\n```\n\n**Result:**\n- \u2705 Validation happens once at the boundary\n- \u2705 Type system guarantees validity for the entire pipeline\n- \u2705 No defensive checks scattered in 5 places\n- \u2705 Impossible to pass invalid phone number to internal functions\n- \u2705 Refactoring is safe\u2014compiler catches mistakes"
          }
        }
      ],
      "judgment": {
        "principle_better": "B",
        "quality_better": "B",
        "overall_better": "B",
        "option_a_rating": "regular",
        "option_b_rating": "good",
        "score": 100,
        "reasoning": "Solution A uses a single nullable field approach for email verification, which is an improvement but leaves room for invalid combinations when adding `unverified_email` separately. Solution B uses discriminated unions to make email states mutually exclusive\u2014the textbook pattern for this principle. While both solutions apply the branded type pattern effectively for phone validation, Solution B's consistent use of discriminated unions throughout demonstrates superior principle adherence and creates genuinely unrepresentable illegal states rather than merely reducing them."
      }
    },
    {
      "skill": "ps-local-reasoning",
      "severity": "WARN",
      "model": "claude-haiku-4.5",
      "skill_version": "1.0.0",
      "baseline_rate": 100,
      "skill_rate": 100,
      "baseline_rating": "good",
      "skill_rating": "outstanding",
      "baseline_pass_count": "2/2",
      "skill_pass_count": "2/2",
      "improvement": 0,
      "judge_error": false,
      "results": [
        {
          "name": "spaghetti_dependencies",
          "input": "The `calculate_invoice_total(invoice_id)` function is hard to debug. To know what it will return, you have to check the state of the Global Feature Flags, the Session Singleton, and the current system time.\n\nRewrite this function so that its behavior is completely deterministic based *only* on its input arguments.",
          "expected": {
            "focus": "Does the refactor pass the feature flags, session data, and time in as arguments?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "Let me check the current directory structure:\n\nThe directory appears empty. Since you cannot edit fi...",
            "response_full": "Let me check the current directory structure:\n\nThe directory appears empty. Since you cannot edit files in this read-only sandbox, here is the refactored function:\n\n## Refactored `calculate_invoice_total()` Function\n\n**Original approach (non-deterministic):**\n- Depends on global feature flags\n- Depends on session singleton state\n- Depends on system time\n- Hard to debug and test\n\n**Refactored approach (deterministic):**\n\n```python\ndef calculate_invoice_total(invoice_id, invoice_data):\n    \"\"\"\n    Calculate invoice total based purely on invoice data.\n    \n    Args:\n        invoice_id: str - The invoice identifier\n        invoice_data: dict - Complete invoice data containing:\n            - items: list of dicts with 'amount' and 'quantity'\n            - tax_rate: float - Tax rate (0.0 to 1.0)\n            - discounts: list of dicts with 'amount' and 'type'\n            - currency: str - Currency code\n            - invoice_date: datetime - Invoice date (replaces system time dependency)\n            - apply_loyalty_discount: bool (replaces feature flag dependency)\n    \n    Returns:\n        dict: {\n            'subtotal': float,\n            'tax': float,\n            'total': float,\n            'currency': str\n        }\n    \"\"\"\n    subtotal = sum(item['amount'] * item['quantity'] for item in invoice_data.get('items', []))\n    \n    # Apply discounts\n    discount_total = sum(d['amount'] for d in invoice_data.get('discounts', []))\n    subtotal -= discount_total\n    \n    # Apply loyalty discount if explicitly enabled in input\n    if invoice_data.get('apply_loyalty_discount', False):\n        subtotal *= 0.95  # 5% loyalty discount\n    \n    # Calculate tax based on provided rate\n    tax = subtotal * invoice_data.get('tax_rate', 0.0)\n    \n    # Calculate total\n    total = subtotal + tax\n    \n    return {\n        'subtotal': round(subtotal, 2),\n        'tax': round(tax, 2),\n        'total': round(total, 2),\n        'currency': invoice_data.get('currency', 'USD')\n    }\n```\n\n**Key improvements:**\n1. **Explicit parameters** - All data needed is passed via `invoice_data` argument\n2. **No global dependencies** - Feature flags, singleton state, and system time are now inputs\n3. **Fully testable** - Same inputs always produce same outputs\n4. **Debuggable** - Complete input visible in function call, no hidden state"
          },
          "skill": {
            "pass": true,
            "response_preview": "I cannot edit files in this read-only sandbox, so I cannot directly rewrite the function in the code...",
            "response_full": "I cannot edit files in this read-only sandbox, so I cannot directly rewrite the function in the codebase. However, here's how the `calculate_invoice_total` function should be refactored according to the Local Reasoning principle:\n\n**Current (problematic):**\n```javascript\nfunction calculate_invoice_total(invoice_id) {\n  const invoice = fetchInvoice(invoice_id)\n  const flags = GLOBAL_FEATURE_FLAGS  // Hidden dependency\n  const user = SESSION.currentUser    // Hidden dependency\n  const now = Date.now()              // Hidden dependency\n  \n  let total = invoice.items.sum(i => i.price)\n  if (flags.applyDiscount) {\n    total *= user.discountRate\n  }\n  if (now > invoice.dueDate) {\n    total *= 1.1 // Late fee\n  }\n  return total\n}\n```\n\n**Refactored (explicit dependencies):**\n```javascript\nfunction calculate_invoice_total(invoice, discountRate, appliesDiscount, currentTime, invoiceDueDate) {\n  let total = invoice.items.sum(i => i.price)\n  \n  if (appliesDiscount) {\n    total *= discountRate\n  }\n  \n  if (currentTime > invoiceDueDate) {\n    total *= 1.1 // Late fee\n  }\n  \n  return total\n}\n\n// Caller handles all state\nconst invoice = fetchInvoice(invoice_id)\nconst total = calculate_invoice_total(\n  invoice,\n  SESSION.currentUser.discountRate,\n  GLOBAL_FEATURE_FLAGS.applyDiscount,\n  Date.now(),\n  invoice.dueDate\n)\n```\n\n**Key improvements:**\n- All dependencies are explicit parameters\n- Function is fully deterministic and testable in isolation\n- No jumping between files to understand behavior\n- Hidden state moved to the caller"
          }
        },
        {
          "name": "hidden_api_call",
          "input": "A developer wrote a `User.save()` method. It looks like it just saves to the database, but secretly it also makes an HTTP call to a CRM system if the user is a VIP. This causes the test suite to hang randomly.\n\nWhy is this design problematic for someone reading the code for the first time? How would you fix it to make the side effect explicit?",
          "expected": {
            "focus": "Does the solution propose passing the CRM service as a dependency or returning an instruction to sync?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "## The Core Problem\n\nThis design violates the **Principle of Least Surprise**. A developer reading `...",
            "response_full": "## The Core Problem\n\nThis design violates the **Principle of Least Surprise**. A developer reading `User.save()` expects it to only persist data to the database. The hidden HTTP call is a **violation of the method's contract** \u2014 it does more than its name implies. This causes:\n\n1. **Unintended test failures** - Callers don't mock the HTTP dependency, causing network hangs\n2. **Unpredictable performance** - A database write suddenly becomes dependent on network latency\n3. **Hidden bugs** - Conditional logic (only for VIP) makes the side effect even harder to discover\n4. **Violated Single Responsibility Principle** - The method owns two concerns: data persistence + external notification\n\n## How to Fix It\n\n**Move the side effect out of `save()` and make it explicit:**\n\n```javascript\n// Option 1: Separate method (simplest)\nuser.save();  // Only saves to database\nif (user.isVIP) {\n  user.notifyCRM();  // Explicit, visible side effect\n}\n\n// Option 2: Event-driven (most scalable)\nuser.save();  // Emits 'user.saved' event\n// Elsewhere, subscribe: on('user.saved', (user) => { \n//   if (user.isVIP) crmService.notify(user); \n// })\n\n// Option 3: Service layer (cleanest architecture)\nuserService.saveAndNotify(user);  // Method name is honest about what it does\n```\n\nThe key: **Make side effects part of the visible API contract**. If `User.save()` has consequences beyond the database, callers need to see it in the code they write. This is why frameworks like Django recommend service layers and why React encourages explicit effect handling (useEffect)."
          },
          "skill": {
            "pass": true,
            "response_preview": "# Why This Design Violates Local Reasoning\n\n**The core problem**: A reader looking at `User.save()` ...",
            "response_full": "# Why This Design Violates Local Reasoning\n\n**The core problem**: A reader looking at `User.save()` sees a method name implying simple database persistence, but the actual behavior includes a hidden HTTP call to an external CRM system. This creates several violations of local reasoning:\n\n1. **Method signature lies** - `save()` doesn't reveal it does more than save\n2. **Hidden dependency** - The CRM service access is buried inside the method, not visible as a dependency\n3. **Implicit behavior triggered by state** - Whether the HTTP call executes depends on checking VIP status internally (global/external state access)\n4. **Side effects from nowhere** - Tests hang because the side effect is completely invisible; developers don't know to mock it\n5. **Requires jumping files** - To understand why tests fail, you must trace through the implementation to discover the CRM call\n\n**Result**: New developers or those maintaining tests waste time debugging mysterious hangs instead of understanding the code immediately.\n\n---\n\n# How to Fix It: Make the Side Effect Explicit\n\n**Option A: Separate the Concerns**\n```javascript\n// Clear what each method does\nuser.saveToDatabase();\nif (user.isVIP()) {\n  crmService.syncUser(user);  // Called explicitly, visible at call site\n}\n```\n\n**Option B: Explicit Parameter (Dependency Injection)**\n```javascript\n// Dependency injected, side effect visible in signature\nuser.save(database, { syncWithCRM: crmService });\n\n// Inside save():\n// - database.persist(user)\n// - if (syncWithCRM && user.isVIP()) syncWithCRM.sync(user)\n```\n\n**Option C: Declarative Configuration**\n```javascript\n// Make sync behavior a parameter, not hidden logic\nuser.save({ \n  persistence: database,\n  crmSync: crmService  // Explicitly passed; reader knows this might make HTTP calls\n});\n```\n\n**Why these work**: All dependencies and side effects become visible at the call site. Tests can mock `crmService`, new developers understand immediately what `save()` actually does, and the code is understandable *in isolation*."
          }
        }
      ],
      "judgment": {
        "principle_better": "B",
        "quality_better": "A",
        "overall_better": "B",
        "option_a_rating": "good",
        "option_b_rating": "outstanding",
        "score": 100,
        "reasoning": "Solution A correctly makes dependencies explicit by grouping them in an `invoice_data` object, which is practical and maintainable. Solution B demonstrates superior adherence to the Local Reasoning principle by using individual explicit parameters\u2014the function signature itself reveals every dependency without requiring inspection of a grouped object. While Solution A's grouped approach is more maintainable for long parameter lists, Solution B precisely aligns with the principle's core tenet: 'Function signature shows exactly what it needs.' Solution B also provides superior clarity for local reasoning since dependencies are immediately visible at the call site."
      }
    },
    {
      "skill": "ps-minimize-mutation",
      "severity": "WARN",
      "model": "claude-haiku-4.5",
      "skill_version": "1.0.0",
      "baseline_rate": 100,
      "skill_rate": 100,
      "baseline_rating": "good",
      "skill_rating": "outstanding",
      "baseline_pass_count": "2/2",
      "skill_pass_count": "2/2",
      "improvement": 0,
      "judge_error": false,
      "results": [
        {
          "name": "cart_bug_fix",
          "input": "We have a bug in our shopping cart. When a user opens the \"Preview\" modal and adds an item to see the shipping cost, that item gets added to their *actual* cart because we passed the cart object by reference. \n\nFix the `preview_item(cart, item)` function so it calculates the new total *without* modifying the original cart object.",
          "expected": {
            "focus": "Does the solution create a copy of the cart or use a new array/object?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "Let me search more broadly for cart-related files:\n\nThe directory appears to be empty. Since you men...",
            "response_full": "Let me search more broadly for cart-related files:\n\nThe directory appears to be empty. Since you mentioned this is a read-only sandbox and I cannot edit files, I'll provide the direct solution:\n\n**The fix for `preview_item(cart, item)` is to create a shallow copy of the cart object before modifying it:**\n\n```python\n# Python example\ndef preview_item(cart, item):\n    preview_cart = cart.copy()  # Create shallow copy\n    preview_cart['items'].append(item)\n    preview_cart['total'] = calculate_total(preview_cart)\n    return preview_cart\n```\n\n```javascript\n// JavaScript example\nfunction preview_item(cart, item) {\n    const previewCart = { ...cart, items: [...cart.items, item] };\n    previewCart.total = calculateTotal(previewCart);\n    return previewCart;\n}\n```\n\n**The core solution:** Use object spreading (`...`) or `.copy()` to create a shallow copy of the cart, and copy the items array separately to avoid mutation of the original cart. Return the preview totals without modifying the input `cart` parameter."
          },
          "skill": {
            "pass": true,
            "response_preview": "Let me check the current directory structure:\n\nThe directory is empty. Based on the problem descript...",
            "response_full": "Let me check the current directory structure:\n\nThe directory is empty. Based on the problem description, you need to fix the `preview_item(cart, item)` function to use **immutable updates** instead of mutating the original cart. Here's the correct implementation:\n\n## Fixed Code\n\n**\u274c Current (Buggy):**\n```javascript\nfunction preview_item(cart, item) {\n    cart.items.push(item)  // Mutates original cart!\n    cart.total += item.price\n    return cart\n}\n```\n\n**\u2705 Fixed:**\n```javascript\nfunction preview_item(cart, item) {\n    return {\n        ...cart,\n        items: [...cart.items, item],\n        total: cart.total + item.price\n    }\n}\n```\n\nThe fix creates a **new cart object** with the updated items and total, leaving the original untouched. The spread operator (`...`) creates shallow copies of the cart and items array, so the preview modal sees the new total without affecting the user's actual cart."
          }
        },
        {
          "name": "default_config_danger",
          "input": "Our `initialize_widget(config = {})` function sets `config.isEnabled = true`. \n\nA developer called this function with a shared constant `DEFAULT_OPTS`. Now, every other widget on the page is accidentally enabled because the shared object was modified.\n\nrewrite the initialization logic to prevent this side effect.",
          "expected": {
            "focus": "Does the solution treated the input object as read-only?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "```javascript\nfunction initialize_widget(config = {}) {\n  const safeConfig = { ...config };\n  safeCo...",
            "response_full": "```javascript\nfunction initialize_widget(config = {}) {\n  const safeConfig = { ...config };\n  safeConfig.isEnabled = true;\n  return safeConfig;\n}\n```\n\nThis creates a shallow copy of the passed config object using the spread operator, so modifications don't affect the original shared constant. If you need to handle nested objects, use `JSON.parse(JSON.stringify(config))` for a deep clone, though the spread operator is sufficient for most cases where only top-level properties are being set."
          },
          "skill": {
            "pass": true,
            "response_preview": "# Fixed Implementation\n\n## Problem\nThe function mutates the input `config` object, affecting shared ...",
            "response_full": "# Fixed Implementation\n\n## Problem\nThe function mutates the input `config` object, affecting shared constants:\n\n```javascript\nfunction initialize_widget(config = {}) {\n    config.isEnabled = true;  // \u274c Mutates shared object\n    return config;\n}\n\nconst DEFAULT_OPTS = { /* ... */ };\ninitialize_widget(DEFAULT_OPTS);  // DEFAULT_OPTS.isEnabled is now true!\n```\n\n## Solution\nCreate a new object instead of mutating the input:\n\n```javascript\nfunction initialize_widget(config = {}) {\n    return {\n        ...config,\n        isEnabled: true\n    };\n}\n\n// Usage:\nconst DEFAULT_OPTS = { /* ... */ };\nconst widgetConfig = initialize_widget(DEFAULT_OPTS);\n// DEFAULT_OPTS remains unchanged\n// widgetConfig has isEnabled: true\n```\n\n## Key Changes\n1. **Return a new object** using the spread operator (`...config`) instead of mutating\n2. **Original `config` untouched** \u2014 safe for shared constants\n3. **Explicit at call site** \u2014 caller gets a new config and must use the return value\n4. **Predictable behavior** \u2014 no hidden side effects affecting other widgets\n\nThis follows the \"Minimize Mutation\" principle: mutation is avoided entirely, preventing the bug where shared constants get accidentally modified across the application."
          }
        }
      ],
      "judgment": {
        "principle_better": "B",
        "quality_better": "B",
        "overall_better": "B",
        "option_a_rating": "good",
        "option_b_rating": "outstanding",
        "score": 100,
        "reasoning": "Solution B excels by clearly contrasting buggy code (showing actual mutation of `cart.items.push()` and `cart.total +=`) with the fixed immutable version, demonstrating the precise problem being solved. It explicitly shows how mutation affects shared constants like `DEFAULT_OPTS`, illustrating the real-world danger. Solution A provides correct examples but lacks this depth of problem exposition and impact explanation, making it competent but less comprehensive in demonstrating principle mastery."
      }
    },
    {
      "skill": "ps-policy-mechanism-separation",
      "severity": "WARN",
      "model": "claude-haiku-4.5",
      "skill_version": "1.0.0",
      "baseline_rate": 100,
      "skill_rate": 100,
      "baseline_rating": "good",
      "skill_rating": "outstanding",
      "baseline_pass_count": "2/2",
      "skill_pass_count": "2/2",
      "improvement": 0,
      "judge_error": false,
      "results": [
        {
          "name": "uploader_flexibility",
          "input": "Our `S3Uploader` class currently hardcodes a 30-second timeout and 3 retries. \n\nWe now need to use it for 1GB video files (which need 1 hour timeout) and for tiny 1KB JSON files (which need 500ms timeout).\n\nRedesign the class so that the *rules* (timeouts, retries) are separated from the *work* (uploading bytes).",
          "expected": {
            "focus": "Does the solution accept a config/policy object or strategy function?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "# S3Uploader Redesign: Separation of Concerns\n\n**Extract upload rules into a separate configuration ...",
            "response_full": "# S3Uploader Redesign: Separation of Concerns\n\n**Extract upload rules into a separate configuration class:**\n\n```typescript\n// Rules (timeouts, retries) - separated from work\nclass UploadConfig {\n  constructor(\n    readonly timeoutMs: number,\n    readonly maxRetries: number\n  ) {}\n  \n  static forLargeVideo() {\n    return new UploadConfig(3600000, 5);  // 1 hour, more retries\n  }\n  \n  static forSmallJson() {\n    return new UploadConfig(500, 1);      // 500ms, minimal retries\n  }\n  \n  static default() {\n    return new UploadConfig(30000, 3);    // 30 seconds, 3 retries\n  }\n}\n\n// Work (uploading bytes) - uses injected rules\nclass S3Uploader {\n  constructor(private config: UploadConfig) {}\n  \n  async upload(bucket: string, key: string, data: Buffer): Promise<void> {\n    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {\n      try {\n        return await this.uploadWithTimeout(bucket, key, data);\n      } catch (error) {\n        if (attempt === this.config.maxRetries) throw error;\n      }\n    }\n  }\n  \n  private uploadWithTimeout(\n    bucket: string,\n    key: string,\n    data: Buffer\n  ): Promise<void> {\n    return Promise.race([\n      this.doUpload(bucket, key, data),\n      this.createTimeoutPromise(this.config.timeoutMs)\n    ]);\n  }\n  \n  private doUpload(bucket: string, key: string, data: Buffer): Promise<void> {\n    // Actual S3 upload logic\n  }\n  \n  private createTimeoutPromise(ms: number): Promise<never> {\n    return new Promise((_, reject) =>\n      setTimeout(() => reject(new Error(`Upload timeout after ${ms}ms`)), ms)\n    );\n  }\n}\n\n// Usage\nconst videoUploader = new S3Uploader(UploadConfig.forLargeVideo());\nawait videoUploader.upload('bucket', 'video.mp4', videoData);\n\nconst jsonUploader = new S3Uploader(UploadConfig.forSmallJson());\nawait jsonUploader.upload('bucket', 'data.json', jsonData);\n```\n\n**Key improvements:**\n- **UploadConfig** encapsulates all rules (timeout, retries)\n- **S3Uploader** focuses solely on upload logic\n- Reusable configurations for different scenarios\n- Easy to add new configs without modifying S3Uploader"
          },
          "skill": {
            "pass": true,
            "response_preview": "# S3Uploader Redesign: Policy-Mechanism Separation\n\n**Current problem:** Hardcoded 30-second timeout...",
            "response_full": "# S3Uploader Redesign: Policy-Mechanism Separation\n\n**Current problem:** Hardcoded 30-second timeout and 3 retries cannot accommodate different file types.\n\n**Solution:** Separate upload policies from the reusable upload mechanism.\n\n## Redesigned Code Structure\n\n```javascript\n// POLICY - Configuration for different scenarios\nconst UPLOAD_POLICIES = {\n  VIDEO: {\n    timeoutMs: 3600000,      // 1 hour\n    maxRetries: 5,\n    backoffMs: 10000,\n    shouldRetry: (error) => error.code !== 'InvalidFile'\n  },\n  JSON: {\n    timeoutMs: 500,          // 500ms\n    maxRetries: 1,\n    backoffMs: 50,\n    shouldRetry: (error) => error.code === 'NetworkTimeout'\n  },\n  DEFAULT: {\n    timeoutMs: 30000,        // Original default\n    maxRetries: 3,\n    backoffMs: 1000,\n    shouldRetry: (error) => error.retriable === true\n  }\n};\n\n// MECHANISM - Reusable implementation (no hardcoded rules)\nclass S3Uploader {\n  async upload(data, policy = UPLOAD_POLICIES.DEFAULT) {\n    return this._retryWithPolicy(\n      () => this._uploadBytes(data),\n      policy\n    );\n  }\n\n  async _retryWithPolicy(operation, policy) {\n    let lastError;\n    for (let attempt = 1; attempt <= policy.maxRetries; attempt++) {\n      try {\n        return await this._executeWithTimeout(\n          operation,\n          policy.timeoutMs\n        );\n      } catch (error) {\n        lastError = error;\n        if (attempt === policy.maxRetries || !policy.shouldRetry(error)) {\n          throw error;\n        }\n        await this._sleep(policy.backoffMs * attempt); // exponential backoff\n      }\n    }\n    throw lastError;\n  }\n\n  async _executeWithTimeout(operation, timeoutMs) {\n    return Promise.race([\n      operation(),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error('Upload timeout')), timeoutMs)\n      )\n    ]);\n  }\n\n  async _uploadBytes(data) {\n    // Core S3 upload logic - unchanged\n  }\n\n  _sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n```\n\n## Usage\n\n```javascript\nconst uploader = new S3Uploader();\n\n// Video: 1 hour timeout, 5 retries\nawait uploader.upload(videoBuffer, UPLOAD_POLICIES.VIDEO);\n\n// JSON: 500ms timeout, 1 retry\nawait uploader.upload(jsonBuffer, UPLOAD_POLICIES.JSON);\n\n// Default behavior preserved\nawait uploader.upload(otherData); // Uses DEFAULT policy\n```\n\n**Result:** Rules are now editable without code changes. Same mechanism serves all file types. Policies can be stored in config files or environment variables."
          }
        },
        {
          "name": "cache_expiration_strategy",
          "input": "We have a simple `Cache` class. Currently, it deletes items if they are older than 1 hour.\n\nWe want to support different expiration rules for different data types (e.g., \"Expire if not accessed in 10 mins\" vs \"Expire at midnight specific timezone\").\n\nShow how you would restructure the Cache to separate the storage mechanism from the expiration logic.",
          "expected": {
            "focus": "Does the Cache delegate the \"should I expire?\" decision to a separate policy?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "# Cache Architecture: Separating Storage from Expiration Logic\n\nUse the **Strategy Pattern** to deco...",
            "response_full": "# Cache Architecture: Separating Storage from Expiration Logic\n\nUse the **Strategy Pattern** to decouple expiration policies from storage:\n\n```csharp\n// Expiration strategy interface\npublic interface IExpirationPolicy\n{\n    bool IsExpired(CacheEntry entry);\n}\n\n// Concrete strategies\npublic class TimeBasedExpirationPolicy : IExpirationPolicy\n{\n    private readonly TimeSpan _duration;\n    public TimeBasedExpirationPolicy(TimeSpan duration) => _duration = duration;\n    public bool IsExpired(CacheEntry entry) => \n        DateTime.UtcNow - entry.CreatedAt > _duration;\n}\n\npublic class AccessTimeExpirationPolicy : IExpirationPolicy\n{\n    private readonly TimeSpan _inactivityDuration;\n    public AccessTimeExpirationPolicy(TimeSpan inactivityDuration) => \n        _inactivityDuration = inactivityDuration;\n    public bool IsExpired(CacheEntry entry) => \n        DateTime.UtcNow - entry.LastAccessedAt > _inactivityDuration;\n}\n\npublic class MidnightExpirationPolicy : IExpirationPolicy\n{\n    private readonly TimeZoneInfo _timezone;\n    public MidnightExpirationPolicy(TimeZoneInfo timezone) => _timezone = timezone;\n    public bool IsExpired(CacheEntry entry)\n    {\n        var localTime = TimeZoneInfo.ConvertTime(DateTime.UtcNow, _timezone);\n        var entryTime = TimeZoneInfo.ConvertTime(entry.CreatedAt, _timezone);\n        return localTime.Date > entryTime.Date;\n    }\n}\n\n// Core storage (policy-agnostic)\npublic class Cache<TKey, TValue>\n{\n    private readonly Dictionary<TKey, CacheEntry> _storage = new();\n    private readonly IExpirationPolicy _policy;\n\n    public Cache(IExpirationPolicy policy) => _policy = policy;\n\n    public void Set(TKey key, TValue value)\n    {\n        _storage[key] = new CacheEntry(value, DateTime.UtcNow);\n    }\n\n    public bool TryGet(TKey key, out TValue value)\n    {\n        if (_storage.TryGetValue(key, out var entry) && !_policy.IsExpired(entry))\n        {\n            entry.LastAccessedAt = DateTime.UtcNow; // Track access\n            value = (TValue)entry.Value;\n            return true;\n        }\n        _storage.Remove(key);\n        value = default;\n        return false;\n    }\n}\n\npublic class CacheEntry\n{\n    public object Value { get; }\n    public DateTime CreatedAt { get; }\n    public DateTime LastAccessedAt { get; set; }\n    \n    public CacheEntry(object value, DateTime createdAt)\n    {\n        Value = value;\n        CreatedAt = createdAt;\n        LastAccessedAt = createdAt;\n    }\n}\n```\n\n**Usage:**\n```csharp\nvar userCache = new Cache<int, User>(new TimeBasedExpirationPolicy(TimeSpan.FromHours(1)));\nvar sessionCache = new Cache<string, Session>(new AccessTimeExpirationPolicy(TimeSpan.FromMinutes(10)));\nvar reportCache = new Cache<string, Report>(new MidnightExpirationPolicy(TimeZoneInfo.FindSystemTimeZoneById(\"Eastern Standard Time\")));\n```\n\n**Benefits:**\n- **Single Responsibility**: Cache handles storage; policies handle expiration logic\n- **Open/Closed Principle**: Add new expiration strategies without modifying Cache\n- **Testability**: Mock expiration policies independently\n- **Flexibility**: Assign different policies to different cache instances"
          },
          "skill": {
            "pass": true,
            "response_preview": "# Cache Restructure: Policy/Mechanism Separation\n\n## Current Problem (Hardcoded Policy)\nThe Cache li...",
            "response_full": "# Cache Restructure: Policy/Mechanism Separation\n\n## Current Problem (Hardcoded Policy)\nThe Cache likely has expiration logic baked into the storage mechanism:\n```javascript\nclass Cache {\n  delete(key) {\n    const item = this.items[key];\n    if (Date.now() - item.timestamp > 3600000) { // 1 hour hardcoded\n      delete this.items[key];\n    }\n  }\n}\n```\n\n## Restructured Solution\n\n**MECHANISM** - Generic storage with pluggable expiration:\n```javascript\nclass Cache {\n  constructor(expirationPolicy) {\n    this.items = new Map();\n    this.expirationPolicy = expirationPolicy;\n  }\n\n  set(key, value) {\n    this.items.set(key, {\n      value,\n      metadata: this.expirationPolicy.createMetadata()\n    });\n  }\n\n  get(key) {\n    this.updateMetadata(key);\n    const item = this.items.get(key);\n    \n    if (item && this.expirationPolicy.isExpired(item.metadata)) {\n      this.items.delete(key);\n      return null;\n    }\n    return item?.value;\n  }\n\n  updateMetadata(key) {\n    const item = this.items.get(key);\n    if (item) {\n      this.expirationPolicy.updateMetadata(item.metadata);\n    }\n  }\n}\n```\n\n**POLICIES** - Different expiration strategies:\n```javascript\n// Policy 1: Expire after fixed duration\nconst fixedDurationPolicy = {\n  createMetadata: () => ({ createdAt: Date.now() }),\n  updateMetadata: () => {}, // No updates needed\n  isExpired: (meta) => Date.now() - meta.createdAt > 3600000\n};\n\n// Policy 2: Expire if not accessed in 10 mins\nconst accessTimePolicy = {\n  createMetadata: () => ({ lastAccessed: Date.now() }),\n  updateMetadata: (meta) => { meta.lastAccessed = Date.now(); },\n  isExpired: (meta) => Date.now() - meta.lastAccessed > 600000\n};\n\n// Policy 3: Expire at midnight specific timezone\nconst midnightPolicy = {\n  timezone: 'America/New_York',\n  createMetadata: () => ({ createdDate: new Date() }),\n  updateMetadata: () => {},\n  isExpired: (meta) => {\n    const now = new Date(new Date().toLocaleString('en-US', { timeZone: this.timezone }));\n    const created = new Date(meta.createdDate.toLocaleString('en-US', { timeZone: this.timezone }));\n    return now.toDateString() !== created.toDateString();\n  }\n};\n```\n\n**USAGE**:\n```javascript\nconst cache1 = new Cache(fixedDurationPolicy);\nconst cache2 = new Cache(accessTimePolicy);\nconst cache3 = new Cache(midnightPolicy);\n\ncache1.set('data', {foo: 'bar'});\ncache2.set('session', {id: 123});\ncache3.set('daily', {count: 5});\n```\n\n**Benefits:**\n- **Change policies without touching Cache code** \u2013 New expiration rules become new policy objects\n- **Test independently** \u2013 Mechanism tested with mock policies; policies tested standalone\n- **Reuse Cache** \u2013 Same storage mechanism works with any expiration policy\n- **Explicit rules** \u2013 Policy objects clearly document what triggers expiration"
          }
        }
      ],
      "judgment": {
        "principle_better": "B",
        "quality_better": "B",
        "overall_better": "B",
        "option_a_rating": "good",
        "option_b_rating": "outstanding",
        "score": 100,
        "reasoning": "Solution A demonstrates the principle competently through dependency injection of configuration objects, particularly in the Cache example with proper Strategy Pattern implementation. However, Solution B achieves mastery by recognizing that policies must include decision logic, not just static properties\u2014see the shouldRetry function and policy methods (isExpired, updateMetadata) that mechanisms delegate to. This behavioral encapsulation in Solution B means business rules can change entirely without modifying the S3Uploader or Cache mechanism, whereas Solution A still hardcodes retry loop structure and timeout logic in the mechanism itself."
      }
    },
    {
      "skill": "ps-single-direction-data-flow",
      "severity": "BLOCK",
      "model": "claude-haiku-4.5",
      "skill_version": "1.0.0",
      "baseline_rate": 100,
      "skill_rate": 100,
      "baseline_rating": "regular",
      "skill_rating": "outstanding",
      "baseline_pass_count": "2/2",
      "skill_pass_count": "2/2",
      "improvement": 0,
      "judge_error": false,
      "results": [
        {
          "name": "fix_infinite_loop",
          "input": "We have a bug where the `ProfileEditor` component updates the `UserStore`, which triggers an event that causes `ProfileEditor` to re-render, which triggers another update... crashing the browser.\n\nDescribe the structural flaw that allows this loop to happen, and propose a data flow pattern that prevents it by design.",
          "expected": {
            "focus": "Does the solution propose a unidirectional flow (Action -> Dispatcher -> Store -> View)?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "Let me check the directory structure:\n\nThe directory appears to be empty. Let me search for files in...",
            "response_full": "Let me check the directory structure:\n\nThe directory appears to be empty. Let me search for files in the current working directory or check if there's code elsewhere:\n\nThe directory is empty, so I'll provide the answer based on the architectural problem described:\n\n## Structural Flaw\n\nThe bug occurs due to **bidirectional reactivity without update isolation**:\n\n1. **ProfileEditor renders** and reads state from UserStore\n2. **User makes changes** \u2192 ProfileEditor calls `updateUserStore()`\n3. **UserStore updates** and emits an event\n4. **Event listener in ProfileEditor** triggers (same component that initiated the change)\n5. **ProfileEditor re-renders** with new data from UserStore\n6. **Re-render triggers change detection** \u2192 step 2 repeats\n\nThe flaw is that the **component that updates the store is also listening to the store's change events**. This creates a closed feedback loop where the initiator of the change becomes the victim of its own side effects.\n\n## Preventing Pattern: Optimistic Updates + Transactional Writes\n\n**Solution: Separate read and write concerns with a transactional boundary**\n\n```\nProfileEditor (UI Component)\n    \u2193\n    Local State (optimistic)\n    \u2193\nupdateProfile() {\n  1. Update local state immediately (optimistic)\n  2. Call store.updateProfile() with a transaction ID\n  3. Subscribe ONLY to external updates (different source)\n}\n\nUserStore\n    \u2193\nupdateProfile(data, txnId) {\n  1. Apply update\n  2. Emit event WITH transaction ID\n}\n\nProfileEditor listener:\n  onStoreChange(event) {\n    if (event.txnId !== lastTxnId) {  // Reject own changes\n      syncFromStore()\n    }\n  }\n```\n\n**Key principle**: The component that initiates a write should **not re-render from that same write**\u2014only from external changes. This breaks the loop by introducing a transactional boundary that distinguishes self-caused updates (ignored) from external updates (applied)."
          },
          "skill": {
            "pass": true,
            "response_preview": "## Structural Flaw: Circular Feedback Loop\n\nThe bug violates the \"Single Direction of Data Flow\" pri...",
            "response_full": "## Structural Flaw: Circular Feedback Loop\n\nThe bug violates the \"Single Direction of Data Flow\" principle through a **bidirectional cycle**:\n\n```\nProfileEditor \u2192 writes to \u2192 UserStore\n                                 \u2193\n                          emits change event\n                                 \u2193\nProfileEditor \u2190 re-renders \u2190 UserStore\n    \u2193\n  triggers update logic in render\n    \u2193\n  writes to UserStore again\n    \u2193\n[LOOP REPEATS]\n```\n\n**Root causes:**\n1. **No clear ownership**: Both ProfileEditor and UserStore can write to the same state\n2. **Backchannel feedback**: UserStore notifies ProfileEditor, which automatically triggers another write\n3. **Re-render side effects**: ProfileEditor's render method contains update logic instead of just display logic\n\nThis violates the core principle: \"Each piece of data has exactly one owner\" and \"Only the owner may change it.\"\n\n## Solution: Unidirectional Data Flow\n\n**Pattern: Parent owns state, child emits events**\n\n```\nUserStore [OWNER]\n    \u2193 (props down)\nProfileEditor (receives: userData, onSave)\n    \u2193 (event up)\n    onSave(updatedData)\n    \u2193\nUserStore.updateUser() \n    \u2193 (notifies subscribers)\nProfileEditor re-renders with new props\n    \u2713 Render is pure\u2014no side effects, no writes\n```\n\n**Key enforcement:**\n- **UserStore alone** owns and writes user data\n- **ProfileEditor receives** data via props, has **no write access**\n- **ProfileEditor emits events** (onSave, onChange) when user acts\n- **UserStore handles** all events and state updates\n- **Render logic is side-effect free**: ProfileEditor only transforms props \u2192 UI\n\n**Result**: UserStore change \u2192 ProfileEditor gets new props \u2192 re-renders with new data \u2192 no automatic write triggered. The loop is broken by design."
          }
        },
        {
          "name": "state_sync_nightmare",
          "input": "Component A (Parent) has `isOpen` state. Component B (Child) also has a local copy of `isOpen` state. They try to keep each other in sync using `useEffect` and callbacks.\n\nThis is causing race conditions where the child is open but the parent thinks it's closed.\n\nRewrite the relationship between these components so there is only *one* source of truth.",
          "expected": {
            "focus": "Does the child become a controlled component (props only)?"
          },
          "baseline": {
            "pass": true,
            "response_preview": "# Solution: Lift State to Parent\n\n**Keep state in the parent only.** Remove the child's local `isOpe...",
            "response_full": "# Solution: Lift State to Parent\n\n**Keep state in the parent only.** Remove the child's local `isOpen` state entirely.\n\n## Parent Component\n```jsx\nconst [isOpen, setIsOpen] = useState(false);\n\nreturn <ChildComponent isOpen={isOpen} onToggle={setIsOpen} />;\n```\n\n## Child Component\n```jsx\nfunction ChildComponent({ isOpen, onToggle }) {\n  return (\n    <>\n      <button onClick={() => onToggle(!isOpen)}>Toggle</button>\n      {isOpen && <div>Content</div>}\n    </>\n  );\n}\n```\n\n**Why this works:**\n- Single source of truth (parent state)\n- No `useEffect` race conditions needed\n- Child reads from props, triggers callbacks to parent\n- Parent updates state, re-renders child with new prop value\n- Guaranteed synchronization\n\n**If the child needs to close itself independently:** Pass `onClose` callback and call it from the child.\n\n**If multiple children need to share this state:** Keep state in parent, pass it to all children via props and callbacks.\n\nThis eliminates the dual-state synchronization problem entirely."
          },
          "skill": {
            "pass": true,
            "response_preview": "# Solution: Parent Owns State, Child Receives It\n\nRemove the child's local `isOpen` state. The paren...",
            "response_full": "# Solution: Parent Owns State, Child Receives It\n\nRemove the child's local `isOpen` state. The parent owns `isOpen` and the child receives it as a prop.\n\n```javascript\n// PARENT - owns isOpen state\nfunction ComponentA() {\n    const [isOpen, setIsOpen] = useState(false);\n\n    return (\n        <ComponentB \n            isOpen={isOpen}\n            onToggle={(newValue) => setIsOpen(newValue)}\n        />\n    );\n}\n\n// CHILD - receives state, emits events only\nfunction ComponentB({ isOpen, onToggle }) {\n    return (\n        <button onClick={() => onToggle(!isOpen)}>\n            {isOpen ? 'Close' : 'Open'}\n        </button>\n    );\n}\n```\n\n**What changed:**\n- **Parent**: Owns `isOpen`. Single source of truth.\n- **Child**: Removed local `isOpen` state. Receives it as a prop.\n- **Updates**: Parent responds to `onToggle` event and updates `isOpen`. Child re-renders with new prop value.\n- **Data flow**: `isOpen` flows down (parent \u2192 child). Events flow up (child \u2192 parent).\n\n**Why this fixes the race condition:**\n- No duplicate state to sync\n- No competing writes\n- No `useEffect` fighting over state\n- Clear single path: parent updates \u2192 child receives new prop \u2192 child re-renders\n\nThe parent is the single owner and sole decision-maker. The child is stateless regarding `isOpen`."
          }
        }
      ],
      "judgment": {
        "principle_better": "B",
        "quality_better": "B",
        "overall_better": "B",
        "option_a_rating": "regular",
        "option_b_rating": "outstanding",
        "score": 100,
        "reasoning": "Solution A identifies the bidirectional problem but proposes a transactional workaround that maintains multiple writers with filtering logic\u2014this is a patch, not true unidirectional flow. Solution B directly applies the principle by establishing single ownership and eliminating competing writes entirely, providing clear visual problem representation and consistent implementation. Solution B demonstrates mastery by recognizing that the root fix is architectural (clear ownership) rather than tactical (filtering self-updates)."
      }
    }
  ]
}